"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-state";
exports.ids = ["vendor-chunks/prosemirror-state"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* binding */ AllSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   NodeSelection: () => (/* binding */ NodeSelection),\n/* harmony export */   Plugin: () => (/* binding */ Plugin),\n/* harmony export */   PluginKey: () => (/* binding */ PluginKey),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   TextSelection: () => (/* binding */ TextSelection),\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\nfunction _callSuper(_this, derived, args) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (e) {\n      return false;\n    }\n  }\n  derived = _getPrototypeOf(derived);\n  return _possibleConstructorReturn(_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf(_this).constructor) : derived.apply(_this, args));\n}\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nvar Selection = /*#__PURE__*/function () {\n  /**\n  Initialize a selection with the head and anchor and ranges. If no\n  ranges are given, constructs a single range across `$anchor` and\n  `$head`.\n  */\n  function Selection(\n  /**\n  The resolved anchor of the selection (the side that stays in\n  place when the selection is modified).\n  */\n  $anchor,\n  /**\n  The resolved head of the selection (the side that moves when\n  the selection is modified).\n  */\n  $head, ranges) {\n    _classCallCheck(this, Selection);\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  /**\n  The selection's anchor, as an unresolved position.\n  */\n  return _createClass(Selection, [{\n    key: \"anchor\",\n    get: function get() {\n      return this.$anchor.pos;\n    }\n    /**\n    The selection's head.\n    */\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.$head.pos;\n    }\n    /**\n    The lower bound of the selection's main range.\n    */\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.$from.pos;\n    }\n    /**\n    The upper bound of the selection's main range.\n    */\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.$to.pos;\n    }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n  }, {\n    key: \"$from\",\n    get: function get() {\n      return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n  }, {\n    key: \"$to\",\n    get: function get() {\n      return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n  }, {\n    key: \"empty\",\n    get: function get() {\n      var ranges = this.ranges;\n      for (var i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;\n      return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n  }, {\n    key: \"content\",\n    value: function content() {\n      return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n      // Put the new selection at the position after the inserted\n      // content. When that ended in an inline node, search backwards,\n      // to get the position after that node. If not, search forward.\n      var lastNode = content.content.lastChild,\n        lastParent = null;\n      for (var i = 0; i < content.openEnd; i++) {\n        lastParent = lastNode;\n        lastNode = lastNode.lastChild;\n      }\n      var mapFrom = tr.steps.length,\n        ranges = this.ranges;\n      for (var _i = 0; _i < ranges.length; _i++) {\n        var _ranges$_i = ranges[_i],\n          $from = _ranges$_i.$from,\n          $to = _ranges$_i.$to,\n          mapping = tr.mapping.slice(mapFrom);\n        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);\n        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n      }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(tr, node) {\n      var mapFrom = tr.steps.length,\n        ranges = this.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var _ranges$i = ranges[i],\n          $from = _ranges$i.$from,\n          $to = _ranges$i.$to,\n          mapping = tr.mapping.slice(mapFrom);\n        var from = mapping.map($from.pos),\n          to = mapping.map($to.pos);\n        if (i) {\n          tr.deleteRange(from, to);\n        } else {\n          tr.replaceRangeWith(from, to, node);\n          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n        }\n      }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n  }, {\n    key: \"getBookmark\",\n    value:\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    function getBookmark() {\n      return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n  }], [{\n    key: \"findFrom\",\n    value: function findFrom($pos, dir) {\n      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n      if (inner) return inner;\n      for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n        if (found) return found;\n      }\n      return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n  }, {\n    key: \"near\",\n    value: function near($pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n  }, {\n    key: \"atStart\",\n    value: function atStart(doc) {\n      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n  }, {\n    key: \"atEnd\",\n    value: function atEnd(doc) {\n      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\");\n      var cls = classesById[json.type];\n      if (!cls) throw new RangeError(\"No selection type \".concat(json.type, \" defined\"));\n      return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, selectionClass) {\n      if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n      classesById[id] = selectionClass;\n      selectionClass.prototype.jsonID = id;\n      return selectionClass;\n    }\n  }]);\n}();\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nvar SelectionRange = /*#__PURE__*/_createClass(\n/**\nCreate a range.\n*/\nfunction SelectionRange(\n/**\nThe lower bound of the range.\n*/\n$from,\n/**\nThe upper bound of the range.\n*/\n$to) {\n  _classCallCheck(this, SelectionRange);\n  this.$from = $from;\n  this.$to = $to;\n});\nvar warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nvar TextSelection = /*#__PURE__*/function (_Selection) {\n  /**\n  Construct a text selection between the given points.\n  */\n  function TextSelection($anchor) {\n    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;\n    _classCallCheck(this, TextSelection);\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    return _callSuper(this, TextSelection, [$anchor, $head]);\n  }\n  /**\n  Returns a resolved position if this is a cursor selection (an\n  empty text selection), and null otherwise.\n  */\n  _inherits(TextSelection, _Selection);\n  return _createClass(TextSelection, [{\n    key: \"$cursor\",\n    get: function get() {\n      return this.$anchor.pos == this.$head.pos ? this.$head : null;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $head = doc.resolve(mapping.map(this.head));\n      if (!$head.parent.inlineContent) return Selection.near($head);\n      var $anchor = doc.resolve(mapping.map(this.anchor));\n      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n      _get(_getPrototypeOf(TextSelection.prototype), \"replace\", this).call(this, tr, content);\n      if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        var marks = this.$from.marksAcross(this.$to);\n        if (marks) tr.ensureMarks(marks);\n      }\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new TextBookmark(this.anchor, this.head);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"text\",\n        anchor: this.anchor,\n        head: this.head\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n  }, {\n    key: \"create\",\n    value: function create(doc, anchor) {\n      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;\n      var $anchor = doc.resolve(anchor);\n      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n  }, {\n    key: \"between\",\n    value: function between($anchor, $head, bias) {\n      var dPos = $anchor.pos - $head.pos;\n      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;\n      if (!$head.parent.inlineContent) {\n        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n        if (found) $head = found.$head;else return Selection.near($head, bias);\n      }\n      if (!$anchor.parent.inlineContent) {\n        if (dPos == 0) {\n          $anchor = $head;\n        } else {\n          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;\n        }\n      }\n      return new TextSelection($anchor, $head);\n    }\n  }]);\n}(Selection);\nSelection.jsonID(\"text\", TextSelection);\nvar TextBookmark = /*#__PURE__*/function () {\n  function TextBookmark(anchor, head) {\n    _classCallCheck(this, TextBookmark);\n    this.anchor = anchor;\n    this.head = head;\n  }\n  return _createClass(TextBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n  }]);\n}();\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nvar NodeSelection = /*#__PURE__*/function (_Selection2) {\n  /**\n  Create a node selection. Does not verify the validity of its\n  argument.\n  */\n  function NodeSelection($pos) {\n    var _this2;\n    _classCallCheck(this, NodeSelection);\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    _this2 = _callSuper(this, NodeSelection, [$pos, $end]);\n    _this2.node = node;\n    return _this2;\n  }\n  _inherits(NodeSelection, _Selection2);\n  return _createClass(NodeSelection, [{\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var _mapping$mapResult = mapping.mapResult(this.anchor),\n        deleted = _mapping$mapResult.deleted,\n        pos = _mapping$mapResult.pos;\n      var $pos = doc.resolve(pos);\n      if (deleted) return Selection.near($pos);\n      return new NodeSelection($pos);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"node\",\n        anchor: this.anchor\n      };\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new NodeBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\") throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n      return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n  }, {\n    key: \"create\",\n    value: function create(doc, from) {\n      return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n  }, {\n    key: \"isSelectable\",\n    value: function isSelectable(node) {\n      return !node.isText && node.type.spec.selectable !== false;\n    }\n  }]);\n}(Selection);\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nvar NodeBookmark = /*#__PURE__*/function () {\n  function NodeBookmark(anchor) {\n    _classCallCheck(this, NodeBookmark);\n    this.anchor = anchor;\n  }\n  return _createClass(NodeBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      var _mapping$mapResult2 = mapping.mapResult(this.anchor),\n        deleted = _mapping$mapResult2.deleted,\n        pos = _mapping$mapResult2.pos;\n      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var $pos = doc.resolve(this.anchor),\n        node = $pos.nodeAfter;\n      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);\n      return Selection.near($pos);\n    }\n  }]);\n}();\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nvar AllSelection = /*#__PURE__*/function (_Selection3) {\n  /**\n  Create an all-selection over the given document.\n  */\n  function AllSelection(doc) {\n    _classCallCheck(this, AllSelection);\n    return _callSuper(this, AllSelection, [doc.resolve(0), doc.resolve(doc.content.size)]);\n  }\n  _inherits(AllSelection, _Selection3);\n  return _createClass(AllSelection, [{\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n      if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        tr[\"delete\"](0, tr.doc.content.size);\n        var sel = Selection.atStart(tr.doc);\n        if (!sel.eq(tr.selection)) tr.setSelection(sel);\n      } else {\n        _get(_getPrototypeOf(AllSelection.prototype), \"replace\", this).call(this, tr, content);\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"all\"\n      };\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"map\",\n    value: function map(doc) {\n      return new AllSelection(doc);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof AllSelection;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return AllBookmark;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc) {\n      return new AllSelection(doc);\n    }\n  }]);\n}(Selection);\nSelection.jsonID(\"all\", AllSelection);\nvar AllBookmark = {\n  map: function map() {\n    return this;\n  },\n  resolve: function resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir) {\n  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (node.inlineContent) return TextSelection.create(doc, pos);\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) return;\n  var step = tr.steps[last];\n  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep)) return;\n  var map = tr.mapping.maps[last],\n    end;\n  map.forEach(function (_from, _to, _newFrom, newTo) {\n    if (end == null) end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nvar UPDATED_SEL = 1,\n  UPDATED_MARKS = 2,\n  UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nvar Transaction = /*#__PURE__*/function (_Transform) {\n  /**\n  @internal\n  */\n  function Transaction(state) {\n    var _this3;\n    _classCallCheck(this, Transaction);\n    _this3 = _callSuper(this, Transaction, [state.doc]);\n    // The step count for which the current selection is valid.\n    _this3.curSelectionFor = 0;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    _this3.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    _this3.meta = Object.create(null);\n    _this3.time = Date.now();\n    _this3.curSelection = state.selection;\n    _this3.storedMarks = state.storedMarks;\n    return _this3;\n  }\n  /**\n  The transaction's current selection. This defaults to the editor\n  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n  transaction, but can be overwritten with\n  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n  */\n  _inherits(Transaction, _Transform);\n  return _createClass(Transaction, [{\n    key: \"selection\",\n    get: function get() {\n      if (this.curSelectionFor < this.steps.length) {\n        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n        this.curSelectionFor = this.steps.length;\n      }\n      return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      if (selection.$from.doc != this.doc) throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n      this.curSelection = selection;\n      this.curSelectionFor = this.steps.length;\n      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n      this.storedMarks = null;\n      return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n  }, {\n    key: \"selectionSet\",\n    get: function get() {\n      return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n  }, {\n    key: \"setStoredMarks\",\n    value: function setStoredMarks(marks) {\n      this.storedMarks = marks;\n      this.updated |= UPDATED_MARKS;\n      return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n  }, {\n    key: \"ensureMarks\",\n    value: function ensureMarks(marks) {\n      if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);\n      return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n  }, {\n    key: \"addStoredMark\",\n    value: function addStoredMark(mark) {\n      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n  }, {\n    key: \"removeStoredMark\",\n    value: function removeStoredMark(mark) {\n      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n  }, {\n    key: \"storedMarksSet\",\n    get: function get() {\n      return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      _get(_getPrototypeOf(Transaction.prototype), \"addStep\", this).call(this, step, doc);\n      this.updated = this.updated & ~UPDATED_MARKS;\n      this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.time = time;\n      return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(slice) {\n      this.selection.replace(this, slice);\n      return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n  }, {\n    key: \"replaceSelectionWith\",\n    value: function replaceSelectionWith(node) {\n      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var selection = this.selection;\n      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none));\n      selection.replaceWith(this, node);\n      return this;\n    }\n    /**\n    Delete the selection.\n    */\n  }, {\n    key: \"deleteSelection\",\n    value: function deleteSelection() {\n      this.selection.replace(this);\n      return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n  }, {\n    key: \"insertText\",\n    value: function insertText(text, from, to) {\n      var schema = this.doc.type.schema;\n      if (from == null) {\n        if (!text) return this.deleteSelection();\n        return this.replaceSelectionWith(schema.text(text), true);\n      } else {\n        if (to == null) to = from;\n        to = to == null ? from : to;\n        if (!text) return this.deleteRange(from, to);\n        var marks = this.storedMarks;\n        if (!marks) {\n          var $from = this.doc.resolve(from);\n          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n        }\n        this.replaceRangeWith(from, to, schema.text(text, marks));\n        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));\n        return this;\n      }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(key, value) {\n      this.meta[typeof key == \"string\" ? key : key.key] = value;\n      return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n  }, {\n    key: \"getMeta\",\n    value: function getMeta(key) {\n      return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n  }, {\n    key: \"isGeneric\",\n    get: function get() {\n      for (var _ in this.meta) return false;\n      return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      this.updated |= UPDATED_SCROLL;\n      return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n  }, {\n    key: \"scrolledIntoView\",\n    get: function get() {\n      return (this.updated & UPDATED_SCROLL) > 0;\n    }\n  }]);\n}(prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\nvar FieldDesc = /*#__PURE__*/_createClass(function FieldDesc(name, desc, self) {\n  _classCallCheck(this, FieldDesc);\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n});\nvar baseFields = [new FieldDesc(\"doc\", {\n  init: function init(config) {\n    return config.doc || config.schema.topNodeType.createAndFill();\n  },\n  apply: function apply(tr) {\n    return tr.doc;\n  }\n}), new FieldDesc(\"selection\", {\n  init: function init(config, instance) {\n    return config.selection || Selection.atStart(instance.doc);\n  },\n  apply: function apply(tr) {\n    return tr.selection;\n  }\n}), new FieldDesc(\"storedMarks\", {\n  init: function init(config) {\n    return config.storedMarks || null;\n  },\n  apply: function apply(tr, _marks, _old, state) {\n    return state.selection.$cursor ? tr.storedMarks : null;\n  }\n}), new FieldDesc(\"scrollToSelection\", {\n  init: function init() {\n    return 0;\n  },\n  apply: function apply(tr, prev) {\n    return tr.scrolledIntoView ? prev + 1 : prev;\n  }\n})];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = /*#__PURE__*/_createClass(function Configuration(schema, plugins) {\n  var _this4 = this;\n  _classCallCheck(this, Configuration);\n  this.schema = schema;\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  this.fields = baseFields.slice();\n  if (plugins) plugins.forEach(function (plugin) {\n    if (_this4.pluginsByKey[plugin.key]) throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n    _this4.plugins.push(plugin);\n    _this4.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state) _this4.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n  });\n});\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nvar EditorState = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function EditorState(\n  /**\n  @internal\n  */\n  config) {\n    _classCallCheck(this, EditorState);\n    this.config = config;\n  }\n  /**\n  The schema of the state's document.\n  */\n  return _createClass(EditorState, [{\n    key: \"schema\",\n    get: function get() {\n      return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n  }, {\n    key: \"apply\",\n    value: function apply(tr) {\n      return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"filterTransaction\",\n    value: function filterTransaction(tr) {\n      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      for (var i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n        var plugin = this.config.plugins[i];\n        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;\n      }\n      return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n  }, {\n    key: \"applyTransaction\",\n    value: function applyTransaction(rootTr) {\n      if (!this.filterTransaction(rootTr)) return {\n        state: this,\n        transactions: []\n      };\n      var trs = [rootTr],\n        newState = this.applyInner(rootTr),\n        seen = null;\n      // This loop repeatedly gives plugins a chance to respond to\n      // transactions as new transactions are added, making sure to only\n      // pass the transactions the plugin did not see before.\n      for (;;) {\n        var haveNew = false;\n        for (var i = 0; i < this.config.plugins.length; i++) {\n          var plugin = this.config.plugins[i];\n          if (plugin.spec.appendTransaction) {\n            var n = seen ? seen[i].n : 0,\n              oldState = seen ? seen[i].state : this;\n            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n            if (tr && newState.filterTransaction(tr, i)) {\n              tr.setMeta(\"appendedTransaction\", rootTr);\n              if (!seen) {\n                seen = [];\n                for (var j = 0; j < this.config.plugins.length; j++) seen.push(j < i ? {\n                  state: newState,\n                  n: trs.length\n                } : {\n                  state: this,\n                  n: 0\n                });\n              }\n              trs.push(tr);\n              newState = newState.applyInner(tr);\n              haveNew = true;\n            }\n            if (seen) seen[i] = {\n              state: newState,\n              n: trs.length\n            };\n          }\n        }\n        if (!haveNew) return {\n          state: newState,\n          transactions: trs\n        };\n      }\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"applyInner\",\n    value: function applyInner(tr) {\n      if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\");\n      var newInstance = new EditorState(this.config),\n        fields = this.config.fields;\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n      }\n      return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n  }, {\n    key: \"tr\",\n    get: function get() {\n      return new Transaction(this);\n    }\n    /**\n    Create a new state.\n    */\n  }, {\n    key: \"reconfigure\",\n    value:\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    function reconfigure(config) {\n      var $config = new Configuration(this.schema, config.plugins);\n      var fields = $config.fields,\n        instance = new EditorState($config);\n      for (var i = 0; i < fields.length; i++) {\n        var name = fields[i].name;\n        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n      }\n      return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pluginFields) {\n      var result = {\n        doc: this.doc.toJSON(),\n        selection: this.selection.toJSON()\n      };\n      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {\n        return m.toJSON();\n      });\n      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {\n        if (prop == \"doc\" || prop == \"selection\") throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n        var plugin = pluginFields[prop],\n          state = plugin.spec.state;\n        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n      }\n      return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n  }], [{\n    key: \"create\",\n    value: function create(config) {\n      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n      var instance = new EditorState($config);\n      for (var i = 0; i < $config.fields.length; i++) instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n      return instance;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(config, json, pluginFields) {\n      if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n      if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\");\n      var $config = new Configuration(config.schema, config.plugins);\n      var instance = new EditorState($config);\n      $config.fields.forEach(function (field) {\n        if (field.name == \"doc\") {\n          instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);\n        } else if (field.name == \"selection\") {\n          instance.selection = Selection.fromJSON(instance.doc, json.selection);\n        } else if (field.name == \"storedMarks\") {\n          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n        } else {\n          if (pluginFields) for (var prop in pluginFields) {\n            var plugin = pluginFields[prop],\n              state = plugin.spec.state;\n            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n              return;\n            }\n          }\n          instance[field.name] = field.init(config, instance);\n        }\n      });\n      return instance;\n    }\n  }]);\n}();\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) val = val.bind(self);else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nvar Plugin = /*#__PURE__*/function () {\n  /**\n  Create a plugin.\n  */\n  function Plugin(\n  /**\n  The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n  */\n  spec) {\n    _classCallCheck(this, Plugin);\n    this.spec = spec;\n    /**\n    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n    */\n    this.props = {};\n    if (spec.props) bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  /**\n  Extract the plugin's state field from an editor state.\n  */\n  return _createClass(Plugin, [{\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n}();\nvar keys = Object.create(null);\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nvar PluginKey = /*#__PURE__*/function () {\n  /**\n  Create a plugin key.\n  */\n  function PluginKey() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"key\";\n    _classCallCheck(this, PluginKey);\n    this.key = createKey(name);\n  }\n  /**\n  Get the active plugin with this key, if any, from an editor\n  state.\n  */\n  return _createClass(PluginKey, [{\n    key: \"get\",\n    value: function get(state) {\n      return state.config.pluginsByKey[this.key];\n    }\n    /**\n    Get the plugin's state from an editor state.\n    */\n  }, {\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUNrQjtBQUVsRixJQUFNTyxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUhBLElBSU1DLFNBQVM7RUFDWDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksU0FBQUE7RUFDQTtBQUNKO0FBQ0E7QUFDQTtFQUNJQyxPQUFPO0VBQ1A7QUFDSjtBQUNBO0FBQ0E7RUFDSUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFBQUMsZUFBQSxPQUFBSixTQUFBO0lBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBLE9BQU87SUFDdEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBLEtBQUs7SUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDLElBQUlFLGNBQWMsQ0FBQ0osT0FBTyxDQUFDSyxHQUFHLENBQUNKLEtBQUssQ0FBQyxFQUFFRCxPQUFPLENBQUNNLEdBQUcsQ0FBQ0wsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN4RjtFQUNBO0FBQ0o7QUFDQTtFQUZJLE9BQUFNLFlBQUEsQ0FBQVIsU0FBQTtJQUFBUyxHQUFBO0lBQUFDLEdBQUEsRUFHQSxTQUFBQSxJQUFBLEVBQWE7TUFBRSxPQUFPLElBQUksQ0FBQ1QsT0FBTyxDQUFDVSxHQUFHO0lBQUU7SUFDeEM7QUFDSjtBQUNBO0VBRkk7SUFBQUYsR0FBQTtJQUFBQyxHQUFBLEVBR0EsU0FBQUEsSUFBQSxFQUFXO01BQUUsT0FBTyxJQUFJLENBQUNSLEtBQUssQ0FBQ1MsR0FBRztJQUFFO0lBQ3BDO0FBQ0o7QUFDQTtFQUZJO0lBQUFGLEdBQUE7SUFBQUMsR0FBQSxFQUdBLFNBQUFBLElBQUEsRUFBVztNQUFFLE9BQU8sSUFBSSxDQUFDRSxLQUFL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QUFBUyxTQUFBLFFBQUFDLFNBQUEsR0FBQUQsU0FBQSxNQUFHLEtBQUs7SUFBQXBCLGVBQUEsT0FBQWdPLFNBQUE7SUFBSSxJQUFJLENBQUMzTixHQUFHLEdBQUd3TixTQUFTLENBQUMvSSxJQUFJLENBQUM7RUFBRTtFQUN4RDtBQUNKO0FBQ0E7QUFDQTtFQUhJLE9BQUExRSxZQUFBLENBQUE0TixTQUFBO0lBQUEzTixHQUFBO0lBQUFPLEtBQUEsRUFJQSxTQUFBTixHQUFHQSxDQUFDZ0ksS0FBSyxFQUFFO01BQUUsT0FBT0EsS0FBSyxDQUFDc0MsTUFBTSxDQUFDWSxZQUFZLENBQUMsSUFBSSxDQUFDbkwsR0FBRyxDQUFDO0lBQUU7SUFDekQ7QUFDSjtBQUNBO0VBRkk7SUFBQUEsR0FBQTtJQUFBTyxLQUFBLEVBR0EsU0FBQWtOLFFBQVFBLENBQUN4RixLQUFLLEVBQUU7TUFBRSxPQUFPQSxLQUFLLENBQUMsSUFBSSxDQUFDakksR0FBRyxDQUFDO0lBQUU7RUFBQztBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluc3RpbmN0aHViXFxjb2RlX3Byb2plY3RzXFxucG1cXGluc3RpbmN0aHViLXJlYWN0LXVpXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLXN0YXRlXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhXG5wcm9wZXJ0aWVzOiBpdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWVcbmB0cnVlYCB0byBzZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaFxuaW5wdXQsIGEgYFwiY29tcG9zaXRpb25cImAgcHJvcGVydHkgaG9sZGluZyBhbiBJRCBpZGVudGlmeWluZyB0aGVcbmNvbXBvc2l0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIHRyYW5zYWN0aW9ucyBjYXVzZWQgYnkgY29tcG9zZWQgRE9NXG5pbnB1dCwgYW5kIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCxcbmBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiJdLCJuYW1lcyI6WyJTbGljZSIsIkZyYWdtZW50IiwiTWFyayIsIk5vZGUiLCJSZXBsYWNlU3RlcCIsIlJlcGxhY2VBcm91bmRTdGVwIiwiVHJhbnNmb3JtIiwiY2xhc3Nlc0J5SWQiLCJPYmplY3QiLCJjcmVhdGUiLCJTZWxlY3Rpb24iLCIkYW5jaG9yIiwiJGhlYWQiLCJyYW5nZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJTZWxlY3Rpb25SYW5nZSIsIm1pbiIsIm1heCIsIl9jcmVhdGVDbGFzcyIsImtleSIsImdldCIsInBvcyIsIiRmcm9tIiwiJHRvIiwiaSIsImxlbmd0aCIsInZhbHVlIiwiY29udGVudCIsImRvYyIsInNsaWNlIiwiZnJvbSIsInRvIiwicmVwbGFjZSIsInRyIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZW1wdHkiLCJsYXN0Tm9kZSIsImxhc3RDaGlsZCIsImxhc3RQYXJlbnQiLCJvcGVuRW5kIiwibWFwRnJvbSIsInN0ZXBzIiwiX3JhbmdlcyRfaSIsIm1hcHBpbmciLCJyZXBsYWNlUmFuZ2UiLCJtYXAiLCJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsImlzSW5saW5lIiwiaXNUZXh0YmxvY2siLCJyZXBsYWNlV2l0aCIsIm5vZGUiLCJfcmFuZ2VzJGkiLCJkZWxldGVSYW5nZSIsInJlcGxhY2VSYW5nZVdpdGgiLCJnZXRCb29rbWFyayIsIlRleHRTZWxlY3Rpb24iLCJiZXR3ZWVuIiwiZmluZEZyb20iLCIkcG9zIiwiZGlyIiwidGV4dE9ubHkiLCJpbm5lciIsInBhcmVudCIsImlubGluZUNvbnRlbnQiLCJmaW5kU2VsZWN0aW9uSW4iLCJpbmRleCIsImRlcHRoIiwiZm91bmQiLCJiZWZvcmUiLCJhZnRlciIsIm5lYXIiLCJiaWFzIiwiQWxsU2VsZWN0aW9uIiwiYXRTdGFydCIsImF0RW5kIiwic2l6ZSIsImNoaWxkQ291bnQiLCJmcm9tSlNPTiIsImpzb24iLCJ0eXBlIiwiUmFuZ2VFcnJvciIsImNscyIsImNvbmNhdCIsImpzb25JRCIsImlkIiwic2VsZWN0aW9uQ2xhc3MiLCJwcm90b3R5cGUiLCJ2aXNpYmxlIiwid2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uIiwiY2hlY2tUZXh0U2VsZWN0aW9uIiwiY29uc29sZSIsIm5hbWUiLCJfU2VsZWN0aW9uIiwiX2NhbGxTdXBlciIsIl9pbmhlcml0cyIsInJlc29sdmUiLCJoZWFkIiwiYW5jaG9yIiwiX2dldCIsIl9nZXRQcm90b3R5cGVPZiIsImNhbGwiLCJtYXJrcyIsIm1hcmtzQWNyb3NzIiwiZW5zdXJlTWFya3MiLCJlcSIsIm90aGVyIiwiVGV4dEJvb2ttYXJrIiwidG9KU09OIiwiZFBvcyIsIk5vZGVTZWxlY3Rpb24iLCJfU2VsZWN0aW9uMiIsIl90aGlzMiIsIm5vZGVBZnRlciIsIiRlbmQiLCJub2RlU2l6ZSIsIl9tYXBwaW5nJG1hcFJlc3VsdCIsIm1hcFJlc3VsdCIsImRlbGV0ZWQiLCJOb2RlQm9va21hcmsiLCJpc1NlbGVjdGFibGUiLCJpc1RleHQiLCJzcGVjIiwic2VsZWN0YWJsZSIsIl9tYXBwaW5nJG1hcFJlc3VsdDIiLCJfU2VsZWN0aW9uMyIsInNlbCIsInNlbGVjdGlvbiIsInNldFNlbGVjdGlvbiIsIkFsbEJvb2ttYXJrIiwidGV4dCIsImNoaWxkIiwiaXNBdG9tIiwic3RhcnRMZW4iLCJsYXN0Iiwic3RlcCIsIm1hcHMiLCJlbmQiLCJmb3JFYWNoIiwiX2Zyb20iLCJfdG8iLCJfbmV3RnJvbSIsIm5ld1RvIiwiVVBEQVRFRF9TRUwiLCJVUERBVEVEX01BUktTIiwiVVBEQVRFRF9TQ1JPTEwiLCJUcmFuc2FjdGlvbiIsIl9UcmFuc2Zvcm0iLCJzdGF0ZSIsIl90aGlzMyIsImN1clNlbGVjdGlvbkZvciIsInVwZGF0ZWQiLCJtZXRhIiwidGltZSIsIkRhdGUiLCJub3ciLCJjdXJTZWxlY3Rpb24iLCJzdG9yZWRNYXJrcyIsInNldFN0b3JlZE1hcmtzIiwic2FtZVNldCIsImFkZFN0b3JlZE1hcmsiLCJtYXJrIiwiYWRkVG9TZXQiLCJyZW1vdmVTdG9yZWRNYXJrIiwicmVtb3ZlRnJvbVNldCIsImFkZFN0ZXAiLCJzZXRUaW1lIiwicmVwbGFjZVNlbGVjdGlvbiIsInJlcGxhY2VTZWxlY3Rpb25XaXRoIiwiaW5oZXJpdE1hcmtzIiwibm9uZSIsImRlbGV0ZVNlbGVjdGlvbiIsImluc2VydFRleHQiLCJzY2hlbWEiLCJzZXRNZXRhIiwiZ2V0TWV0YSIsIl8iLCJzY3JvbGxJbnRvVmlldyIsImJpbmQiLCJmIiwic2VsZiIsIkZpZWxkRGVzYyIsImRlc2MiLCJpbml0IiwiYXBwbHkiLCJiYXNlRmllbGRzIiwiY29uZmlnIiwidG9wTm9kZVR5cGUiLCJjcmVhdGVBbmRGaWxsIiwiaW5zdGFuY2UiLCJfbWFya3MiLCJfb2xkIiwiJGN1cnNvciIsInByZXYiLCJzY3JvbGxlZEludG9WaWV3IiwiQ29uZmlndXJhdGlvbiIsInBsdWdpbnMiLCJfdGhpczQiLCJwbHVnaW5zQnlLZXkiLCJmaWVsZHMiLCJwbHVnaW4iLCJwdXNoIiwiRWRpdG9yU3RhdGUiLCJhcHBseVRyYW5zYWN0aW9uIiwiZmlsdGVyVHJhbnNhY3Rpb24iLCJpZ25vcmUiLCJyb290VHIiLCJ0cmFuc2FjdGlvbnMiLCJ0cnMiLCJuZXdTdGF0ZSIsImFwcGx5SW5uZXIiLCJzZWVuIiwiaGF2ZU5ldyIsImFwcGVuZFRyYW5zYWN0aW9uIiwibiIsIm9sZFN0YXRlIiwiaiIsIm5ld0luc3RhbmNlIiwiZmllbGQiLCJyZWNvbmZpZ3VyZSIsIiRjb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsInBsdWdpbkZpZWxkcyIsInJlc3VsdCIsIm0iLCJfdHlwZW9mIiwicHJvcCIsIm1hcmtGcm9tSlNPTiIsImJpbmRQcm9wcyIsIm9iaiIsInRhcmdldCIsInZhbCIsIkZ1bmN0aW9uIiwiUGx1Z2luIiwicHJvcHMiLCJjcmVhdGVLZXkiLCJnZXRTdGF0ZSIsImtleXMiLCJQbHVnaW5LZXkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-state/dist/index.js\n");

/***/ })

};
;