"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-transform";
exports.ids = ["vendor-chunks/prosemirror-transform"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* binding */ AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* binding */ AttrStep),\n/* harmony export */   DocAttrStep: () => (/* binding */ DocAttrStep),\n/* harmony export */   MapResult: () => (/* binding */ MapResult),\n/* harmony export */   Mapping: () => (/* binding */ Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* binding */ RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* binding */ ReplaceStep),\n/* harmony export */   Step: () => (/* binding */ Step),\n/* harmony export */   StepMap: () => (/* binding */ StepMap),\n/* harmony export */   StepResult: () => (/* binding */ StepResult),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   canJoin: () => (/* binding */ canJoin),\n/* harmony export */   canSplit: () => (/* binding */ canSplit),\n/* harmony export */   dropPoint: () => (/* binding */ dropPoint),\n/* harmony export */   findWrapping: () => (/* binding */ findWrapping),\n/* harmony export */   insertPoint: () => (/* binding */ insertPoint),\n/* harmony export */   joinPoint: () => (/* binding */ joinPoint),\n/* harmony export */   liftTarget: () => (/* binding */ liftTarget),\n/* harmony export */   replaceStep: () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _callSuper(_this, derived, args) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (e) {\n      return false;\n    }\n  }\n  derived = _getPrototypeOf(derived);\n  return _possibleConstructorReturn(_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf(_this).constructor) : derived.apply(_this, args));\n}\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\nvar DEL_BEFORE = 1,\n  DEL_AFTER = 2,\n  DEL_ACROSS = 4,\n  DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nvar MapResult = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function MapResult(\n  /**\n  The mapped version of the position.\n  */\n  pos,\n  /**\n  @internal\n  */\n  delInfo,\n  /**\n  @internal\n  */\n  recover) {\n    _classCallCheck(this, MapResult);\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n  /**\n  Tells you whether the position was deleted, that is, whether the\n  step removed the token on the side queried (via the `assoc`)\n  argument from the document.\n  */\n  return _createClass(MapResult, [{\n    key: \"deleted\",\n    get: function get() {\n      return (this.delInfo & DEL_SIDE) > 0;\n    }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n  }, {\n    key: \"deletedBefore\",\n    get: function get() {\n      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n  }, {\n    key: \"deletedAfter\",\n    get: function get() {\n      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n  }, {\n    key: \"deletedAcross\",\n    get: function get() {\n      return (this.delInfo & DEL_ACROSS) > 0;\n    }\n  }]);\n}();\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nvar StepMap = /*#__PURE__*/function () {\n  /**\n  Create a position map. The modifications to the document are\n  represented as an array of numbers, in which each group of three\n  represents a modified chunk as `[start, oldSize, newSize]`.\n  */\n  function StepMap(\n  /**\n  @internal\n  */\n  ranges) {\n    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck(this, StepMap);\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && StepMap.empty) return StepMap.empty;\n  }\n  /**\n  @internal\n  */\n  return _createClass(StepMap, [{\n    key: \"recover\",\n    value: function recover(value) {\n      var diff = 0,\n        index = recoverIndex(value);\n      if (!this.inverted) for (var i = 0; i < index; i++) diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, true);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var diff = 0,\n        oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n          newSize = this.ranges[i + newIndex],\n          end = start + oldSize;\n        if (pos <= end) {\n          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n          var result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple) return result;\n          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n          return new MapResult(result, del, recover);\n        }\n        diff += newSize - oldSize;\n      }\n      return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"touches\",\n    value: function touches(pos, recover) {\n      var diff = 0,\n        index = recoverIndex(recover);\n      var oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n          end = start + oldSize;\n        if (pos <= end && i == index * 3) return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n      return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      var oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i],\n          oldStart = start - (this.inverted ? diff : 0),\n          newStart = start + (this.inverted ? 0 : diff);\n        var oldSize = this.ranges[i + oldIndex],\n          newSize = this.ranges[i + newIndex];\n        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n        diff += newSize - oldSize;\n      }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n  }], [{\n    key: \"offset\",\n    value: function offset(n) {\n      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n  }]);\n}();\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](https://prosemirror.net/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/\nvar Mapping = /*#__PURE__*/function () {\n  /**\n  Create a new mapping with the given position maps.\n  */\n  function Mapping(maps,\n  /**\n  @internal\n  */\n  mirror) {\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps ? maps.length : 0;\n    _classCallCheck(this, Mapping);\n    this.mirror = mirror;\n    this.from = from;\n    this.to = to;\n    this._maps = maps || [];\n    this.ownData = !(maps || mirror);\n  }\n  /**\n  The step maps in this mapping.\n  */\n  return _createClass(Mapping, [{\n    key: \"maps\",\n    get: function get() {\n      return this._maps;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;\n      return new Mapping(this._maps, this.mirror, from, to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n  }, {\n    key: \"appendMap\",\n    value: function appendMap(map, mirrors) {\n      if (!this.ownData) {\n        this._maps = this._maps.slice();\n        this.mirror = this.mirror && this.mirror.slice();\n        this.ownData = true;\n      }\n      this.to = this._maps.push(map);\n      if (mirrors != null) this.setMirror(this._maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n  }, {\n    key: \"appendMapping\",\n    value: function appendMapping(mapping) {\n      for (var i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n      }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n  }, {\n    key: \"getMirror\",\n    value: function getMirror(n) {\n      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"setMirror\",\n    value: function setMirror(n, m) {\n      if (!this.mirror) this.mirror = [];\n      this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n  }, {\n    key: \"appendMappingInverted\",\n    value: function appendMappingInverted(mapping) {\n      for (var i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n      }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var inverse = new Mapping();\n      inverse.appendMappingInverted(this);\n      return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      if (this.mirror) return this._map(pos, assoc, true);\n      for (var i = this.from; i < this.to; i++) pos = this._maps[i].map(pos, assoc);\n      return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var delInfo = 0;\n      for (var i = this.from; i < this.to; i++) {\n        var map = this._maps[i],\n          result = map.mapResult(pos, assoc);\n        if (result.recover != null) {\n          var corr = this.getMirror(i);\n          if (corr != null && corr > i && corr < this.to) {\n            i = corr;\n            pos = this._maps[corr].recover(result.recover);\n            continue;\n          }\n        }\n        delInfo |= result.delInfo;\n        pos = result.pos;\n      }\n      return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n  }]);\n}();\nvar stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nvar Step = /*#__PURE__*/function () {\n  function Step() {\n    _classCallCheck(this, Step);\n  }\n  return _createClass(Step, [{\n    key: \"getMap\",\n    value:\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    function getMap() {\n      return StepMap.empty;\n    }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      return null;\n    }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n      var type = stepsByID[json.stepType];\n      if (!type) throw new RangeError(\"No step type \".concat(json.stepType, \" defined\"));\n      return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, stepClass) {\n      if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n      stepsByID[id] = stepClass;\n      stepClass.prototype.jsonID = id;\n      return stepClass;\n    }\n  }]);\n}();\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nvar StepResult = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function StepResult(\n  /**\n  The transformed document, if successful.\n  */\n  doc,\n  /**\n  The failure message, if unsuccessful.\n  */\n  failed) {\n    _classCallCheck(this, StepResult);\n    this.doc = doc;\n    this.failed = failed;\n  }\n  /**\n  Create a successful step result.\n  */\n  return _createClass(StepResult, null, [{\n    key: \"ok\",\n    value: function ok(doc) {\n      return new StepResult(doc, null);\n    }\n    /**\n    Create a failed step result.\n    */\n  }, {\n    key: \"fail\",\n    value: function fail(message) {\n      return new StepResult(null, message);\n    }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n  }, {\n    key: \"fromReplace\",\n    value: function fromReplace(doc, from, to, slice) {\n      try {\n        return StepResult.ok(doc.replace(from, to, slice));\n      } catch (e) {\n        if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) return StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  }]);\n}();\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline) child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nvar AddMarkStep = /*#__PURE__*/function (_Step) {\n  /**\n  Create a mark step.\n  */\n  function AddMarkStep(\n  /**\n  The start of the marked range.\n  */\n  from,\n  /**\n  The end of the marked range.\n  */\n  to,\n  /**\n  The mark to add.\n  */\n  mark) {\n    var _this2;\n    _classCallCheck(this, AddMarkStep);\n    _this2 = _callSuper(this, AddMarkStep);\n    _this2.from = from;\n    _this2.to = to;\n    _this2.mark = mark;\n    return _this2;\n  }\n  _inherits(AddMarkStep, _Step);\n  return _createClass(AddMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this3 = this;\n      var oldSlice = doc.slice(this.from, this.to),\n        $from = doc.resolve(this.from);\n      var parent = $from.node($from.sharedDepth(this.to));\n      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node, parent) {\n        if (!node.isAtom || !parent.type.allowsMarkType(_this3.mark.type)) return node;\n        return node.mark(_this3.mark.addToSet(node.marks));\n      }, parent), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n}(Step);\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nvar RemoveMarkStep = /*#__PURE__*/function (_Step2) {\n  /**\n  Create a mark-removing step.\n  */\n  function RemoveMarkStep(\n  /**\n  The start of the unmarked range.\n  */\n  from,\n  /**\n  The end of the unmarked range.\n  */\n  to,\n  /**\n  The mark to remove.\n  */\n  mark) {\n    var _this4;\n    _classCallCheck(this, RemoveMarkStep);\n    _this4 = _callSuper(this, RemoveMarkStep);\n    _this4.from = from;\n    _this4.to = to;\n    _this4.mark = mark;\n    return _this4;\n  }\n  _inherits(RemoveMarkStep, _Step2);\n  return _createClass(RemoveMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this5 = this;\n      var oldSlice = doc.slice(this.from, this.to);\n      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node) {\n        return node.mark(_this5.mark.removeFromSet(node.marks));\n      }, doc), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n}(Step);\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nvar AddNodeMarkStep = /*#__PURE__*/function (_Step3) {\n  /**\n  Create a node mark step.\n  */\n  function AddNodeMarkStep(\n  /**\n  The position of the target node.\n  */\n  pos,\n  /**\n  The mark to add.\n  */\n  mark) {\n    var _this6;\n    _classCallCheck(this, AddNodeMarkStep);\n    _this6 = _callSuper(this, AddNodeMarkStep);\n    _this6.pos = pos;\n    _this6.mark = mark;\n    return _this6;\n  }\n  _inherits(AddNodeMarkStep, _Step3);\n  return _createClass(AddNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (node) {\n        var newSet = this.mark.addToSet(node.marks);\n        if (newSet.length == node.marks.length) {\n          for (var i = 0; i < node.marks.length; i++) if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);\n          return new AddNodeMarkStep(this.pos, this.mark);\n        }\n      }\n      return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n}(Step);\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nvar RemoveNodeMarkStep = /*#__PURE__*/function (_Step4) {\n  /**\n  Create a mark-removing step.\n  */\n  function RemoveNodeMarkStep(\n  /**\n  The position of the target node.\n  */\n  pos,\n  /**\n  The mark to remove.\n  */\n  mark) {\n    var _this7;\n    _classCallCheck(this, RemoveNodeMarkStep);\n    _this7 = _callSuper(this, RemoveNodeMarkStep);\n    _this7.pos = pos;\n    _this7.mark = mark;\n    return _this7;\n  }\n  _inherits(RemoveNodeMarkStep, _Step4);\n  return _createClass(RemoveNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node || !this.mark.isInSet(node.marks)) return this;\n      return new AddNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n}(Step);\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nvar ReplaceStep = /*#__PURE__*/function (_Step5) {\n  /**\n  The given `slice` should fit the 'gap' between `from` and\n  `to`—the depths must line up, and the surrounding nodes must be\n  able to be joined with the open sides of the slice. When\n  `structure` is true, the step will fail if the content between\n  from and to is not just a sequence of closing and then opening\n  tokens (this is to guard against rebased replace steps\n  overwriting something they weren't supposed to).\n  */\n  function ReplaceStep(\n  /**\n  The start position of the replaced range.\n  */\n  from,\n  /**\n  The end position of the replaced range.\n  */\n  to,\n  /**\n  The slice to insert.\n  */\n  slice) {\n    var _this8;\n    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, ReplaceStep);\n    _this8 = _callSuper(this, ReplaceStep);\n    _this8.from = from;\n    _this8.to = to;\n    _this8.slice = slice;\n    _this8.structure = structure;\n    return _this8;\n  }\n  _inherits(ReplaceStep, _Step5);\n  return _createClass(ReplaceStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n      return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deletedAcross && to.deletedAcross) return null;\n      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;\n      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n        var slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n        var _slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n        return new ReplaceStep(other.from, this.to, _slice, this.structure);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replace\",\n        from: this.from,\n        to: this.to\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n      return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n  }]);\n}(Step);\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nvar ReplaceAroundStep = /*#__PURE__*/function (_Step6) {\n  /**\n  Create a replace-around step with the given range and gap.\n  `insert` should be the point in the slice into which the content\n  of the gap should be moved. `structure` has the same meaning as\n  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n  */\n  function ReplaceAroundStep(\n  /**\n  The start position of the replaced range.\n  */\n  from,\n  /**\n  The end position of the replaced range.\n  */\n  to,\n  /**\n  The start of preserved range.\n  */\n  gapFrom,\n  /**\n  The end of preserved range.\n  */\n  gapTo,\n  /**\n  The slice to insert.\n  */\n  slice,\n  /**\n  The position in the slice where the preserved range should be\n  inserted.\n  */\n  insert) {\n    var _this9;\n    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    _classCallCheck(this, ReplaceAroundStep);\n    _this9 = _callSuper(this, ReplaceAroundStep);\n    _this9.from = from;\n    _this9.to = to;\n    _this9.gapFrom = gapFrom;\n    _this9.gapTo = gapTo;\n    _this9.slice = slice;\n    _this9.insert = insert;\n    _this9.structure = structure;\n    return _this9;\n  }\n  _inherits(ReplaceAroundStep, _Step6);\n  return _createClass(ReplaceAroundStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n      var gap = doc.slice(this.gapFrom, this.gapTo);\n      if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n      var inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n      return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var gap = this.gapTo - this.gapFrom;\n      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      var gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n      var gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replaceAround\",\n        from: this.from,\n        to: this.to,\n        gapFrom: this.gapFrom,\n        gapTo: this.gapTo,\n        insert: this.insert\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n  }]);\n}(Step);\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n    dist = to - from,\n    depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\nfunction _addMark(tr, from, to, mark) {\n  var removed = [],\n    added = [];\n  var removing, adding;\n  tr.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) return;\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from),\n        end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n        }\n      }\n      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));\n    }\n  });\n  removed.forEach(function (s) {\n    return tr.step(s);\n  });\n  added.forEach(function (s) {\n    return tr.step(s);\n  });\n}\nfunction _removeMark(tr, from, to, mark) {\n  var matched = [],\n    step = 0;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) return;\n    step++;\n    var toRemove = null;\n    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n      var set = node.marks,\n        found;\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n          _found = void 0;\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;\n        }\n        if (_found) {\n          _found.to = end;\n          _found.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n}\nfunction _clearIncompatible(tr, pos, parentType) {\n  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;\n  var clearNewlines = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var node = tr.doc.nodeAt(pos);\n  var replSteps = [],\n    cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i),\n      end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type);\n    if (!allowed) {\n      replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n      if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n        var m = void 0,\n          newline = /\\r?\\n|\\r/g,\n          slice = void 0;\n        while (m = newline.exec(child.text)) {\n          if (!slice) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n        }\n      }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n  }\n  for (var _i = replSteps.length - 1; _i >= 0; _i--) tr.step(replSteps[_i]);\n}\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth),\n      endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;\n  }\n  return null;\n}\nfunction _lift(tr, range, target) {\n  var $from = range.$from,\n    $to = range.$to,\n    depth = range.depth;\n  var gapStart = $from.before(depth + 1),\n    gapEnd = $to.after(depth + 1);\n  var start = gapStart,\n    end = gapEnd;\n  var before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,\n    openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--) if (splitting || $from.index(d) > 0) {\n    splitting = true;\n    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n    openStart++;\n  } else {\n    start--;\n  }\n  var after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,\n    openEnd = 0;\n  for (var _d = depth, _splitting = false; _d > target; _d--) if (_splitting || $to.after(_d + 1) < $to.end(_d)) {\n    _splitting = true;\n    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(_d).copy(after));\n    openEnd++;\n  } else {\n    end++;\n  }\n  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType) {\n  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) return null;\n  return around.map(withAttrs).concat({\n    type: nodeType,\n    attrs: attrs\n  }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) {\n  return {\n    type: type,\n    attrs: null\n  };\n}\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent,\n    startIndex = range.startIndex,\n    endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) return null;\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n  var parent = range.parent,\n    startIndex = range.startIndex,\n    endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) return null;\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++) innerMatch = innerMatch.matchType(parent.child(i).type);\n  if (!innerMatch || !innerMatch.validEnd) return null;\n  return inside;\n}\nfunction _wrap2(tr, range, wrappers) {\n  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd) throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n    }\n    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n  var start = range.start,\n    end = range.end;\n  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction _setBlockType(tr, from, to, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  var mapFrom = tr.steps.length;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    var attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n      var convertNewlines = null;\n      if (type.schema.linebreakReplacement) {\n        var pre = type.whitespace == \"pre\",\n          supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n        if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;\n      }\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);\n      _clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n      var mapping = tr.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1),\n        endM = mapping.map(pos + node.nodeSize, 1);\n      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n      if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);\n      return false;\n    }\n  });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n  node.forEach(function (child, offset) {\n    if (child.isText) {\n      var m,\n        newline = /\\r?\\n|\\r/g;\n      while (m = newline.exec(child.text)) {\n        var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n      }\n    }\n  });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n  node.forEach(function (child, offset) {\n    if (child.type == child.type.schema.linebreakReplacement) {\n      var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n      tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n    }\n  });\n}\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos),\n    index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction _setNodeMarkup(tr, pos, type, attrs, marks) {\n  var node = tr.doc.nodeAt(pos);\n  if (!node) throw new RangeError(\"No node at given position\");\n  if (!type) type = node.type;\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n  if (!type.validContent(node.content)) throw new RangeError(\"Invalid content for node type \" + type.name);\n  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = doc.resolve(pos),\n    base = $pos.depth - depth;\n  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d),\n      _index = $pos.index(d);\n    if (node.type.spec.isolating) return false;\n    var rest = node.content.cutByIndex(_index, node.childCount);\n    var overrideChild = typesAfter && typesAfter[i + 1];\n    if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n    var after = typesAfter && typesAfter[i] || node;\n    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction _split(tr, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = tr.doc.resolve(pos),\n    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,\n    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos),\n    index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n  if (!b.content.size) a.type.compatibleContent(b.type);\n  var match = a.contentMatchAt(a.childCount);\n  var linebreakReplacement = a.type.schema.linebreakReplacement;\n  for (var i = 0; i < b.childCount; i++) {\n    var child = b.child(i);\n    var type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n    match = match.matchType(type);\n    if (!match) return false;\n    if (!a.type.allowsMarks(child.marks)) return false;\n  }\n  return match.validEnd;\n}\nfunction joinable(a, b) {\n  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos) {\n  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = void 0,\n      after = void 0,\n      index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;\n    if (d == 0) break;\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\nfunction _join(tr, pos, depth) {\n  var convertNewlines = null;\n  var linebreakReplacement = tr.doc.type.schema.linebreakReplacement;\n  var $before = tr.doc.resolve(pos - depth),\n    beforeType = $before.node().type;\n  if (linebreakReplacement && beforeType.inlineContent) {\n    var pre = beforeType.whitespace == \"pre\";\n    var supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n    if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;\n  }\n  var mapFrom = tr.steps.length;\n  if (convertNewlines === false) {\n    var $after = tr.doc.resolve(pos + depth);\n    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n  }\n  if (beforeType.inlineContent) _clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n  var mapping = tr.mapping.slice(mapFrom),\n    start = mapping.map(pos - depth);\n  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true));\n  if (convertNewlines === true) {\n    var $full = tr.doc.resolve(start);\n    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n  }\n  return tr;\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;\n  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {\n    var index = $pos.index(d);\n    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);\n    if (index > 0) return null;\n  }\n  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {\n    var _index2 = $pos.indexAfter(_d2);\n    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);\n    if (_index2 < $pos.node(_d2).childCount) return null;\n  }\n  return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) return pos;\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) content = content.firstChild.content;\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d),\n        fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n    }\n  }\n  return null;\n}\n\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from) {\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;\n  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n  if (from == to && !slice.size) return null;\n  var $from = doc.resolve(from),\n    $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);\n  return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nvar Fitter = /*#__PURE__*/function () {\n  function Fitter($from, $to, unplaced) {\n    _classCallCheck(this, Fitter);\n    this.$from = $from;\n    this.$to = $to;\n    this.unplaced = unplaced;\n    this.frontier = [];\n    this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (var i = 0; i <= $from.depth; i++) {\n      var node = $from.node(i);\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      });\n    }\n    for (var _i2 = $from.depth; _i2 > 0; _i2--) this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(_i2).copy(this.placed));\n  }\n  return _createClass(Fitter, [{\n    key: \"depth\",\n    get: function get() {\n      return this.frontier.length - 1;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      // As long as there's unplaced content, try to place some of it.\n      // If that fails, either increase the open score of the unplaced\n      // slice, or drop nodes from it, and then try again.\n      while (this.unplaced.size) {\n        var _fit = this.findFittable();\n        if (_fit) this.placeNodes(_fit);else this.openMore() || this.dropNode();\n      }\n      // When there's inline content directly after the frontier _and_\n      // directly after `this.$to`, we must generate a `ReplaceAround`\n      // step that pulls that content into the node after the frontier.\n      // That means the fitting must be done to the end of the textblock\n      // node after `this.$to`, not `this.$to` itself.\n      var moveInline = this.mustMoveInline(),\n        placedSize = this.placed.size - this.depth - this.$from.depth;\n      var $from = this.$from,\n        $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n      if (!$to) return null;\n      // If closing to `$to` succeeded, create a step\n      var content = this.placed,\n        openStart = $from.depth,\n        openEnd = $to.depth;\n      while (openStart && openEnd && content.childCount == 1) {\n        // Normalize by dropping open parent nodes\n        content = content.firstChild.content;\n        openStart--;\n        openEnd--;\n      }\n      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n      if (slice.size || $from.pos != this.$to.pos)\n        // Don't generate no-op steps\n        return new ReplaceStep($from.pos, $to.pos, slice);\n      return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n  }, {\n    key: \"findFittable\",\n    value: function findFittable() {\n      var startDepth = this.unplaced.openStart;\n      for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n        var node = cur.firstChild;\n        if (cur.childCount > 1) openEnd = 0;\n        if (node.type.spec.isolating && openEnd <= d) {\n          startDepth = d;\n          break;\n        }\n        cur = node.content;\n      }\n      // Only try wrapping nodes (pass 2) after finding a place without\n      // wrapping failed.\n      for (var pass = 1; pass <= 2; pass++) {\n        for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n          var fragment = void 0,\n            parent = null;\n          if (sliceDepth) {\n            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n            fragment = parent.content;\n          } else {\n            fragment = this.unplaced.content;\n          }\n          var first = fragment.firstChild;\n          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n            var _this$frontier$fronti = this.frontier[frontierDepth],\n              type = _this$frontier$fronti.type,\n              match = _this$frontier$fronti.match,\n              _wrap = void 0,\n              inject = null;\n            // In pass 1, if the next node matches, or there is no next\n            // node but the parents look compatible, we've found a\n            // place.\n            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              inject: inject\n            };\n            // In pass 2, look for a set of wrapping nodes that make\n            // `first` fit here.\n            else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              wrap: _wrap\n            };\n            // Don't continue looking further up if the parent node\n            // would fit here.\n            if (parent && match.matchType(parent.type)) break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"openMore\",\n    value: function openMore() {\n      var _this$unplaced = this.unplaced,\n        content = _this$unplaced.content,\n        openStart = _this$unplaced.openStart,\n        openEnd = _this$unplaced.openEnd;\n      var inner = contentAt(content, openStart);\n      if (!inner.childCount || inner.firstChild.isLeaf) return false;\n      this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n      return true;\n    }\n  }, {\n    key: \"dropNode\",\n    value: function dropNode() {\n      var _this$unplaced2 = this.unplaced,\n        content = _this$unplaced2.content,\n        openStart = _this$unplaced2.openStart,\n        openEnd = _this$unplaced2.openEnd;\n      var inner = contentAt(content, openStart);\n      if (inner.childCount <= 1 && openStart > 0) {\n        var openAtEnd = content.size - openStart <= openStart + inner.size;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n      } else {\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n      }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n  }, {\n    key: \"placeNodes\",\n    value: function placeNodes(_ref) {\n      var sliceDepth = _ref.sliceDepth,\n        frontierDepth = _ref.frontierDepth,\n        parent = _ref.parent,\n        inject = _ref.inject,\n        wrap = _ref.wrap;\n      while (this.depth > frontierDepth) this.closeFrontierNode();\n      if (wrap) for (var i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i]);\n      var slice = this.unplaced,\n        fragment = parent ? parent.content : slice.content;\n      var openStart = slice.openStart - sliceDepth;\n      var taken = 0,\n        add = [];\n      var _this$frontier$fronti2 = this.frontier[frontierDepth],\n        match = _this$frontier$fronti2.match,\n        type = _this$frontier$fronti2.type;\n      if (inject) {\n        for (var _i3 = 0; _i3 < inject.childCount; _i3++) add.push(inject.child(_i3));\n        match = match.matchFragment(inject);\n      }\n      // Computes the amount of (end) open nodes at the end of the\n      // fragment. When 0, the parent is open, but no more. When\n      // negative, nothing is open.\n      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n      // Scan over the fragment, fitting as many child nodes as\n      // possible.\n      while (taken < fragment.childCount) {\n        var next = fragment.child(taken),\n          matches = match.matchType(next.type);\n        if (!matches) break;\n        taken++;\n        if (taken > 1 || openStart == 0 || next.content.size) {\n          // Drop empty open nodes\n          match = matches;\n          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n        }\n      }\n      var toEnd = taken == fragment.childCount;\n      if (!toEnd) openEndCount = -1;\n      this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n      this.frontier[frontierDepth].match = match;\n      // If the parent types match, and the entire node was moved, and\n      // it's not open, close this frontier node right away.\n      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();\n      // Add new frontier nodes for any open nodes at the end.\n      for (var _i4 = 0, cur = fragment; _i4 < openEndCount; _i4++) {\n        var node = cur.lastChild;\n        this.frontier.push({\n          type: node.type,\n          match: node.contentMatchAt(node.childCount)\n        });\n        cur = node.content;\n      }\n      // Update `this.unplaced`. Drop the entire node from which we\n      // placed it we got to its end, otherwise just drop the placed\n      // nodes.\n      this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n  }, {\n    key: \"mustMoveInline\",\n    value: function mustMoveInline() {\n      if (!this.$to.parent.isTextblock) return -1;\n      var top = this.frontier[this.depth],\n        level;\n      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;\n      var depth = this.$to.depth,\n        after = this.$to.after(depth);\n      while (depth > 1 && after == this.$to.end(--depth)) ++after;\n      return after;\n    }\n  }, {\n    key: \"findCloseLevel\",\n    value: function findCloseLevel($to) {\n      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        var _this$frontier$i = this.frontier[i],\n          match = _this$frontier$i.match,\n          type = _this$frontier$i.type;\n        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        var fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit) continue;\n        for (var d = i - 1; d >= 0; d--) {\n          var _this$frontier$d = this.frontier[d],\n            _match = _this$frontier$d.match,\n            _type = _this$frontier$d.type;\n          var matches = contentAfterFits($to, d, _type, _match, true);\n          if (!matches || matches.childCount) continue scan;\n        }\n        return {\n          depth: i,\n          fit: fit,\n          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n        };\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close($to) {\n      var close = this.findCloseLevel($to);\n      if (!close) return null;\n      while (this.depth > close.depth) this.closeFrontierNode();\n      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);\n      $to = close.move;\n      for (var d = close.depth + 1; d <= $to.depth; d++) {\n        var node = $to.node(d),\n          add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n        this.openFrontierNode(node.type, node.attrs, add);\n      }\n      return $to;\n    }\n  }, {\n    key: \"openFrontierNode\",\n    value: function openFrontierNode(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var top = this.frontier[this.depth];\n      top.match = top.match.matchType(type);\n      this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n      this.frontier.push({\n        type: type,\n        match: type.contentMatch\n      });\n    }\n  }, {\n    key: \"closeFrontierNode\",\n    value: function closeFrontierNode() {\n      var open = this.frontier.pop();\n      var add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n  }]);\n}();\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content);\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) fragment = fragment.firstChild.content;\n  return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node;\n  var frag = node.content;\n  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n  }\n  return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth),\n    index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null;\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++) if (!type.allowsMarks(fragment.child(i).marks)) return true;\n  return false;\n}\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent;\n}\nfunction _replaceRange(tr, from, to, slice) {\n  if (!slice.size) return tr.deleteRange(from, to);\n  var $from = tr.doc.resolve(from),\n    $to = tr.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));\n  var targetDepths = coveredDepths($from, tr.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.definingAsContext || spec.isolating) break;\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  var leftNodes = [],\n    preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) break;\n    content = node.content;\n  }\n  // Back up preferredDepth to cover defining textblocks directly\n  // above it, possibly skipping a non-defining textblock.\n  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {\n    var leftNode = leftNodes[_d3],\n      def = definesContent(leftNode.type);\n    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = _d3;else if (def || !leftNode.type.isTextblock) break;\n  }\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) continue;\n    for (var _i5 = 0; _i5 < targetDepths.length; _i5++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(_i5 + preferredTargetIndex) % targetDepths.length],\n        expand = true;\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n      var parent = $from.node(targetDepth - 1),\n        index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n    }\n  }\n  var startSteps = tr.steps.length;\n  for (var _i6 = targetDepths.length - 1; _i6 >= 0; _i6--) {\n    tr.replace(from, to, slice);\n    if (tr.steps.length > startSteps) break;\n    var depth = targetDepths[_i6];\n    if (depth < 0) continue;\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n  }\n  return fragment;\n}\nfunction _replaceRangeWith(tr, from, to, node) {\n  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(tr.doc, from, node.type);\n    if (point != null) from = to = point;\n  }\n  tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction _deleteRange(tr, from, to) {\n  var $from = tr.doc.resolve(from),\n    $to = tr.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i],\n      last = i == covered.length - 1;\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr[\"delete\"]($from.start(depth), $to.end(depth));\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr[\"delete\"]($from.before(depth), $to.after(depth));\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1))) return tr[\"delete\"]($from.before(d), to);\n  }\n  tr[\"delete\"](from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [],\n    minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);\n  }\n  return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nvar AttrStep = /*#__PURE__*/function (_Step7) {\n  /**\n  Construct an attribute step.\n  */\n  function AttrStep(\n  /**\n  The position of the target node.\n  */\n  pos,\n  /**\n  The attribute to set.\n  */\n  attr,\n  // The attribute's new value.\n  value) {\n    var _this10;\n    _classCallCheck(this, AttrStep);\n    _this10 = _callSuper(this, AttrStep);\n    _this10.pos = pos;\n    _this10.attr = attr;\n    _this10.value = value;\n    return _this10;\n  }\n  _inherits(AttrStep, _Step7);\n  return _createClass(AttrStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at attribute step's position\");\n      var attrs = Object.create(null);\n      for (var name in node.attrs) attrs[name] = node.attrs[name];\n      attrs[this.attr] = this.value;\n      var updated = node.type.create(attrs, null, node.marks);\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"attr\",\n        pos: this.pos,\n        attr: this.attr,\n        value: this.value\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\" || typeof json.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n      return new AttrStep(json.pos, json.attr, json.value);\n    }\n  }]);\n}(Step);\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/\nvar DocAttrStep = /*#__PURE__*/function (_Step8) {\n  /**\n  Construct an attribute step.\n  */\n  function DocAttrStep(\n  /**\n  The attribute to set.\n  */\n  attr,\n  // The attribute's new value.\n  value) {\n    var _this11;\n    _classCallCheck(this, DocAttrStep);\n    _this11 = _callSuper(this, DocAttrStep);\n    _this11.attr = attr;\n    _this11.value = value;\n    return _this11;\n  }\n  _inherits(DocAttrStep, _Step8);\n  return _createClass(DocAttrStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var attrs = Object.create(null);\n      for (var name in doc.attrs) attrs[name] = doc.attrs[name];\n      attrs[this.attr] = this.value;\n      var updated = doc.type.create(attrs, doc.content, doc.marks);\n      return StepResult.ok(updated);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"docAttr\",\n        attr: this.attr,\n        value: this.value\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.attr != \"string\") throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n      return new DocAttrStep(json.attr, json.value);\n    }\n  }]);\n}(Step);\nStep.jsonID(\"docAttr\", DocAttrStep);\n\n/**\n@internal\n*/\nvar TransformError = /*#__PURE__*/function (_Error) {\n  function TransformError() {\n    _classCallCheck(this, TransformError);\n    return _callSuper(this, TransformError, arguments);\n  }\n  _inherits(TransformError, _Error);\n  return _createClass(TransformError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nTransformError = function TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nvar Transform = /*#__PURE__*/function () {\n  /**\n  Create a transform that starts with the given document.\n  */\n  function Transform(\n  /**\n  The current document (the result of applying the steps in the\n  transform).\n  */\n  doc) {\n    _classCallCheck(this, Transform);\n    this.doc = doc;\n    /**\n    The steps in this transform.\n    */\n    this.steps = [];\n    /**\n    The documents before each of the steps.\n    */\n    this.docs = [];\n    /**\n    A mapping with the maps for each of the steps in this transform.\n    */\n    this.mapping = new Mapping();\n  }\n  /**\n  The starting document.\n  */\n  return _createClass(Transform, [{\n    key: \"before\",\n    get: function get() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n  }, {\n    key: \"step\",\n    value: function step(_step) {\n      var result = this.maybeStep(_step);\n      if (result.failed) throw new TransformError(result.failed);\n      return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n  }, {\n    key: \"maybeStep\",\n    value: function maybeStep(step) {\n      var result = step.apply(this.doc);\n      if (!result.failed) this.addStep(step, result.doc);\n      return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n  }, {\n    key: \"docChanged\",\n    get: function get() {\n      return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      this.docs.push(this.doc);\n      this.steps.push(step);\n      this.mapping.appendMap(step.getMap());\n      this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n  }, {\n    key: \"replace\",\n    value: function replace(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n      var step = replaceStep(this.doc, from, to, slice);\n      if (step) this.step(step);\n      return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(from, to, content) {\n      return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n  }, {\n    key: \"delete\",\n    value: function _delete(from, to) {\n      return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n  }, {\n    key: \"insert\",\n    value: function insert(pos, content) {\n      return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n  }, {\n    key: \"replaceRange\",\n    value: function replaceRange(from, to, slice) {\n      _replaceRange(this, from, to, slice);\n      return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n  }, {\n    key: \"replaceRangeWith\",\n    value: function replaceRangeWith(from, to, node) {\n      _replaceRangeWith(this, from, to, node);\n      return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n  }, {\n    key: \"deleteRange\",\n    value: function deleteRange(from, to) {\n      _deleteRange(this, from, to);\n      return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n  }, {\n    key: \"lift\",\n    value: function lift(range, target) {\n      _lift(this, range, target);\n      return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n  }, {\n    key: \"join\",\n    value: function join(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      _join(this, pos, depth);\n      return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, wrappers) {\n      _wrap2(this, range, wrappers);\n      return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n  }, {\n    key: \"setBlockType\",\n    value: function setBlockType(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var type = arguments.length > 2 ? arguments[2] : undefined;\n      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      _setBlockType(this, from, to, type, attrs);\n      return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n  }, {\n    key: \"setNodeMarkup\",\n    value: function setNodeMarkup(pos, type) {\n      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      _setNodeMarkup(this, pos, type, attrs, marks);\n      return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n  }, {\n    key: \"setNodeAttribute\",\n    value: function setNodeAttribute(pos, attr, value) {\n      this.step(new AttrStep(pos, attr, value));\n      return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n  }, {\n    key: \"setDocAttribute\",\n    value: function setDocAttribute(attr, value) {\n      this.step(new DocAttrStep(attr, value));\n      return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n  }, {\n    key: \"addNodeMark\",\n    value: function addNodeMark(pos, mark) {\n      this.step(new AddNodeMarkStep(pos, mark));\n      return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n  }, {\n    key: \"removeNodeMark\",\n    value: function removeNodeMark(pos, mark) {\n      if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n        var node = this.doc.nodeAt(pos);\n        if (!node) throw new RangeError(\"No node at position \" + pos);\n        mark = mark.isInSet(node.marks);\n        if (!mark) return this;\n      }\n      this.step(new RemoveNodeMarkStep(pos, mark));\n      return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split (with the outermost nodes coming first).\n    */\n  }, {\n    key: \"split\",\n    value: function split(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;\n      _split(this, pos, depth, typesAfter);\n      return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n  }, {\n    key: \"addMark\",\n    value: function addMark(from, to, mark) {\n      _addMark(this, from, to, mark);\n      return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n  }, {\n    key: \"removeMark\",\n    value: function removeMark(from, to, mark) {\n      _removeMark(this, from, to, mark);\n      return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n  }, {\n    key: \"clearIncompatible\",\n    value: function clearIncompatible(pos, parentType, match) {\n      _clearIncompatible(this, pos, parentType, match);\n      return this;\n    }\n  }]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1LLE9BQU8sR0FBRyxNQUFNO0FBQ3RCLElBQU1DLFFBQVEsR0FBR0MsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUNoQyxTQUFTQyxXQUFXQSxDQUFDQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtFQUFFLE9BQU9ELEtBQUssR0FBR0MsTUFBTSxHQUFHTCxRQUFRO0FBQUU7QUFDeEUsU0FBU00sWUFBWUEsQ0FBQ0MsS0FBSyxFQUFFO0VBQUUsT0FBT0EsS0FBSyxHQUFHUixPQUFPO0FBQUU7QUFDdkQsU0FBU1MsYUFBYUEsQ0FBQ0QsS0FBSyxFQUFFO0VBQUUsT0FBTyxDQUFDQSxLQUFLLElBQUlBLEtBQUssR0FBR1IsT0FBTyxDQUFDLElBQUlDLFFBQVE7QUFBRTtBQUMvRSxJQUFNUyxVQUFVLEdBQUcsQ0FBQztFQUFFQyxTQUFTLEdBQUcsQ0FBQztFQUFFQyxVQUFVLEdBQUcsQ0FBQztFQUFFQyxRQUFRLEdBQUcsQ0FBQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBSU1DLFNBQVM7RUFDWDtBQUNKO0FBQ0E7RUFDSSxTQUFBQTtFQUNBO0FBQ0o7QUFDQTtFQUNJQyxHQUFHO0VBQ0g7QUFDSjtBQUNBO0VBQ0lDLE9BQU87RUFDUDtBQUNKO0FBQ0E7RUFDSUMsT0FBTyxFQUFFO0lBQUFDLGVBQUEsT0FBQUosU0FBQTtJQUNMLElBQUksQ0FBQ0MsR0FBRyxHQUFHQSxHQUFHO0lBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUdBLE9BQU87SUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBLE9BQU87RUFD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SUFBQWpHLEdBQUE7SUFBQVosS0FBQSxFQU1BLFNBQUE4TCxpQkFBaUJBLENBQUN2TCxHQUFHLEVBQUV3TCxVQUFVLEVBQUVDLEtBQUssRUFBRTtNQUN0Q0Ysa0JBQWlCLENBQUMsSUFBSSxFQUFFdkwsR0FBRyxFQUFFd0wsVUFBVSxFQUFFQyxLQUFLLENBQUM7TUFDL0MsT0FBTyxJQUFJO0lBQ2Y7RUFBQztBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluc3RpbmN0aHViXFxjb2RlX3Byb2plY3RzXFxucG1cXGluc3RpbmN0aHViLXJlYWN0LXVpXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLXRyYW5zZm9ybVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbuKAmFtyZWJhc2luZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jdHJhbnNmb3JtLnJlYmFzaW5nKeKAmSBzdGVwcyBmb3JcbmNvbGxhYm9yYXRpb24gb3IgaGlzdG9yeSBtYW5hZ2VtZW50LilcbiovXG5jbGFzcyBNYXBwaW5nIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbWFwcGluZyB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBtYXBzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IobWFwcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzID8gbWFwcy5sZW5ndGggOiAwKSB7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuX21hcHMgPSBtYXBzIHx8IFtdO1xuICAgICAgICB0aGlzLm93bkRhdGEgPSAhKG1hcHMgfHwgbWlycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0ZXAgbWFwcyBpbiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBnZXQgbWFwcygpIHsgcmV0dXJuIHRoaXMuX21hcHM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5fbWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm93bkRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHMgPSB0aGlzLl9tYXBzLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IHRoaXMubWlycm9yICYmIHRoaXMubWlycm9yLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLm93bkRhdGEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLl9tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMuX21hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLl9tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcuX21hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLl9tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMuX21hcHMubGVuZ3RoICsgbWFwcGluZy5fbWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5fbWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5fbWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLCByZXR1cm5pbmcgYSBtYXBwaW5nXG4gICAgcmVzdWx0LlxuICAgICovXG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGVsSW5mbyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLl9tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuX21hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYOKAlHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IHRoaXMuZnJvbSA9PSB0aGlzLmdhcEZyb20gPyBmcm9tLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpO1xuICAgICAgICBsZXQgZ2FwVG8gPSB0aGlzLnRvID09IHRoaXMuZ2FwVG8gPyB0by5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICAgICAgaWYgKChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcykgfHwgZ2FwRnJvbSA8IGZyb20ucG9zIHx8IGdhcFRvID4gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbS5wb3MsIHRvLnBvcywgZ2FwRnJvbSwgZ2FwVG8sIHRoaXMuc2xpY2UsIHRoaXMuaW5zZXJ0LCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byxcbiAgICAgICAgICAgIGdhcEZyb206IHRoaXMuZ2FwRnJvbSwgZ2FwVG86IHRoaXMuZ2FwVG8sIGluc2VydDogdGhpcy5pbnNlcnQgfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuZnVuY3Rpb24gY29udGVudEJldHdlZW4oZG9jLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCBkaXN0ID0gdG8gLSBmcm9tLCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICAgIHdoaWxlIChkaXN0ID4gMCAmJiBkZXB0aCA+IDAgJiYgJGZyb20uaW5kZXhBZnRlcihkZXB0aCkgPT0gJGZyb20ubm9kZShkZXB0aCkuY2hpbGRDb3VudCkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBkaXN0LS07XG4gICAgfVxuICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICBsZXQgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBkaXN0LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCByZW1vdmVkID0gW10sIGFkZGVkID0gW107XG4gICAgbGV0IHJlbW92aW5nLCBhZGRpbmc7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1hcmtzID0gbm9kZS5tYXJrcztcbiAgICAgICAgaWYgKCFtYXJrLmlzSW5TZXQobWFya3MpICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZy50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHJlbW92aW5nID0gbmV3IFJlbW92ZU1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmtzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgYWRkaW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xuICAgIGFkZGVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBbXSwgc3RlcCA9IDA7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0ZXArKztcbiAgICAgICAgbGV0IHRvUmVtb3ZlID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrVHlwZSkge1xuICAgICAgICAgICAgbGV0IHNldCA9IG5vZGUubWFya3MsIGZvdW5kO1xuICAgICAgICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgICAgICAgICAodG9SZW1vdmUgfHwgKHRvUmVtb3ZlID0gW10pKS5wdXNoKGZvdW5kKTtcbiAgICAgICAgICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFyaykge1xuICAgICAgICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IFttYXJrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUgJiYgdG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRvUmVtb3ZlW2ldLCBmb3VuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5zdGVwID09IHN0ZXAgLSAxICYmIHN0eWxlLmVxKG1hdGNoZWRbal0uc3R5bGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKHsgc3R5bGUsIGZyb206IE1hdGgubWF4KHBvcywgZnJvbSksIHRvOiBlbmQsIHN0ZXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgbWF0Y2hlZC5mb3JFYWNoKG0gPT4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSkpO1xufVxuZnVuY3Rpb24gY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2ggPSBwYXJlbnRUeXBlLmNvbnRlbnRNYXRjaCwgY2xlYXJOZXdsaW5lcyA9IHRydWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNsZWFyTmV3bGluZXMgJiYgY2hpbGQuaXNUZXh0ICYmIHBhcmVudFR5cGUud2hpdGVzcGFjZSAhPSBcInByZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgbGV0IGF0dHJzSGVyZSA9IHR5cGVvZiBhdHRycyA9PSBcImZ1bmN0aW9uXCIgPyBhdHRycyhub2RlKSA6IGF0dHJzO1xuICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnNIZXJlKSAmJlxuICAgICAgICAgICAgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgY29udmVydE5ld2xpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmUgPSB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiwgc3VwcG9ydExpbmVicmVhayA9ICEhdHlwZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlICYmICFzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcHJlICYmIHN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgICAgICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxpbmVicmVha3ModHIsIG5vZGUsIHBvcywgbWFwRnJvbSk7XG4gICAgICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0ciwgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSwgdW5kZWZpbmVkLCBjb252ZXJ0TmV3bGluZXMgPT09IG51bGwpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzSGVyZSwgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXBsYWNlTmV3bGluZXModHIsIG5vZGUsIHBvcywgbWFwRnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKSB7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBtLCBuZXdsaW5lID0gL1xccj9cXG58XFxyL2c7XG4gICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQgKyBtLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCwgc3RhcnQgKyAxLCBub2RlLnR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50LmNyZWF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZUxpbmVicmVha3ModHIsIG5vZGUsIHBvcywgbWFwRnJvbSkge1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSBjaGlsZC50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCwgc3RhcnQgKyAxLCBub2RlLnR5cGUuc2NoZW1hLnRleHQoXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSk7XG59XG4vKipcbkNoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuKi9cbmZ1bmN0aW9uIHNldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICB0eXBlID0gbm9kZS50eXBlO1xuICAgIGxldCBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gICAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciBzcGxpdHRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGFsbG93ZWQuXG4qL1xuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8XG4gICAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGUoZCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICAgICAgbGV0IG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgICAgICBpZiAob3ZlcnJpZGVDaGlsZClcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBvdmVycmlkZUNoaWxkLnR5cGUuY3JlYXRlKG92ZXJyaWRlQ2hpbGQuYXR0cnMpKTtcbiAgICAgICAgbGV0IGFmdGVyID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXSkgfHwgbm9kZTtcbiAgICAgICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXggKyAxLCBub2RlLmNoaWxkQ291bnQpIHx8ICFhZnRlci50eXBlLnZhbGlkQ29udGVudChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICAgIGxldCBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KHRyLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSwgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIGFmdGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICBsZXQgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuLyoqXG5UZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG5qb2luZWQuXG4qL1xuZnVuY3Rpb24gY2FuSm9pbihkb2MsIHBvcykge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpIHtcbiAgICBpZiAoIWIuY29udGVudC5zaXplKVxuICAgICAgICBhLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYi50eXBlKTtcbiAgICBsZXQgbWF0Y2ggPSBhLmNvbnRlbnRNYXRjaEF0KGEuY2hpbGRDb3VudCk7XG4gICAgbGV0IHsgbGluZWJyZWFrUmVwbGFjZW1lbnQgfSA9IGEudHlwZS5zY2hlbWE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBiLmNoaWxkKGkpO1xuICAgICAgICBsZXQgdHlwZSA9IGNoaWxkLnR5cGUgPT0gbGluZWJyZWFrUmVwbGFjZW1lbnQgPyBhLnR5cGUuc2NoZW1hLm5vZGVzLnRleHQgOiBjaGlsZC50eXBlO1xuICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLnR5cGUuYWxsb3dzTWFya3MoY2hpbGQubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2gudmFsaWRFbmQ7XG59XG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gICAgcmV0dXJuICEhKGEgJiYgYiAmJiAhYS5pc0xlYWYgJiYgY2FuQXBwZW5kV2l0aFN1YnN0aXR1dGVkTGluZWJyZWFrcyhhLCBiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IGNvbnZlcnROZXdsaW5lcyA9IG51bGw7XG4gICAgbGV0IHsgbGluZWJyZWFrUmVwbGFjZW1lbnQgfSA9IHRyLmRvYy50eXBlLnNjaGVtYTtcbiAgICBsZXQgJGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHBvcyAtIGRlcHRoKSwgYmVmb3JlVHlwZSA9ICRiZWZvcmUubm9kZSgpLnR5cGU7XG4gICAgaWYgKGxpbmVicmVha1JlcGxhY2VtZW50ICYmIGJlZm9yZVR5cGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgcHJlID0gYmVmb3JlVHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCI7XG4gICAgICAgIGxldCBzdXBwb3J0TGluZWJyZWFrID0gISFiZWZvcmVUeXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgICAgICBpZiAocHJlICYmICFzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IHRydWU7XG4gICAgfVxuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShwb3MgKyBkZXB0aCk7XG4gICAgICAgIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCAkYWZ0ZXIubm9kZSgpLCAkYWZ0ZXIuYmVmb3JlKCksIG1hcEZyb20pO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlVHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zICsgZGVwdGggLSAxLCBiZWZvcmVUeXBlLCAkYmVmb3JlLm5vZGUoKS5jb250ZW50TWF0Y2hBdCgkYmVmb3JlLmluZGV4KCkpLCBjb252ZXJ0TmV3bGluZXMgPT0gbnVsbCk7XG4gICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLCBzdGFydCA9IG1hcHBpbmcubWFwKHBvcyAtIGRlcHRoKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChzdGFydCwgbWFwcGluZy5tYXAocG9zICsgZGVwdGgsIC0xKSwgU2xpY2UuZW1wdHksIHRydWUpKTtcbiAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSB0cnVlKSB7XG4gICAgICAgIGxldCAkZnVsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0KTtcbiAgICAgICAgcmVwbGFjZU5ld2xpbmVzKHRyLCAkZnVsbC5ub2RlKCksICRmdWxsLmJlZm9yZSgpLCB0ci5zdGVwcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG4vKipcblRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxubmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxubnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgJHBvcy5ub2RlKGQpLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZHMgYSBwb3NpdGlvbiBhdCBvciBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdoZXJlIHRoZSBnaXZlblxuc2xpY2UgY2FuIGJlIGluc2VydGVkLiBXaWxsIGxvb2sgYXQgcGFyZW50IG5vZGVzJyBuZWFyZXN0IGJvdW5kYXJ5XG5hbmQgdHJ5IHRoZXJlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3YXNuJ3QgZGlyZWN0bHkgYXQgdGhlXG5zdGFydCBvciBlbmQgb2YgdGhhdCBub2RlLiBSZXR1cm5zIG51bGwgd2hlbiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxu4oCYRml04oCZIGEgc2xpY2UgaW50byBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcHJvZHVjaW5nIGFcbltzdGVwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHRoYXQgaW5zZXJ0cyBpdC4gV2lsbCByZXR1cm4gbnVsbCBpZlxudGhlcmUncyBubyBtZWFuaW5nZnVsIHdheSB0byBpbnNlcnQgdGhlIHNsaWNlIGhlcmUsIG9yIGluc2VydGluZyBpdFxud291bGQgYmUgYSBuby1vcCAoYW4gZW1wdHkgc2xpY2Ugb3ZlciBhbiBlbXB0eSByYW5nZSkuXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gICAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAgICAgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbmNsYXNzIEZpdHRlciB7XG4gICAgY29uc3RydWN0b3IoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgICAgICB0aGlzLmZyb250aWVyID0gW107XG4gICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShpKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTsgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gICAgICAgIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoZml0KVxuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VOb2RlcyhmaXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGlubGluZSBjb250ZW50IGRpcmVjdGx5IGFmdGVyIHRoZSBmcm9udGllciBfYW5kX1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciBgdGhpcy4kdG9gLCB3ZSBtdXN0IGdlbmVyYXRlIGEgYFJlcGxhY2VBcm91bmRgXG4gICAgICAgIC8vIHN0ZXAgdGhhdCBwdWxscyB0aGF0IGNvbnRlbnQgaW50byB0aGUgbm9kZSBhZnRlciB0aGUgZnJvbnRpZXIuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIGZpdHRpbmcgbXVzdCBiZSBkb25lIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRibG9ja1xuICAgICAgICAvLyBub2RlIGFmdGVyIGB0aGlzLiR0b2AsIG5vdCBgdGhpcy4kdG9gIGl0c2VsZi5cbiAgICAgICAgbGV0IG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMuJGZyb20sICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgICAgaWYgKCEkdG8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICAgIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgICAgaWYgKHNsaWNlLnNpemUgfHwgJGZyb20ucG9zICE9IHRoaXMuJHRvLnBvcykgLy8gRG9uJ3QgZ2VuZXJhdGUgbm8tb3Agc3RlcHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuICAgIC8vIGNvbnRlbnQgdGhhdCBjYW4gYmUgbW92ZWQgc29tZXdoZXJlIG9uIHRoZSBmcm9udGllci4gUmV0dXJucyB0d29cbiAgICAvLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbiAgICBmaW5kRml0dGFibGUoKSB7XG4gICAgICAgIGxldCBzdGFydERlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMudW5wbGFjZWQuY29udGVudCwgZCA9IDAsIG9wZW5FbmQgPSB0aGlzLnVucGxhY2VkLm9wZW5FbmQ7IGQgPCBzdGFydERlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHRyeSB3cmFwcGluZyBub2RlcyAocGFzcyAyKSBhZnRlciBmaW5kaW5nIGEgcGxhY2Ugd2l0aG91dFxuICAgICAgICAvLyB3cmFwcGluZyBmYWlsZWQuXG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQsIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbWF0Y2ggfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sIHdyYXAsIGluamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIHdyYXAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbG9va2luZyBmdXJ0aGVyIHVwIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Nb3JlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyb3BOb2RlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSwgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbiAgICAvLyBmcm9udGllciBub2RlIGF0IGBmcm9udGllckRlcHRoYC4gQ2xvc2UgdGhhdCBmcm9udGllciBub2RlIHdoZW5cbiAgICAvLyBhcHBsaWNhYmxlLlxuICAgIHBsYWNlTm9kZXMoeyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCwgd3JhcCB9KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKHdyYXApXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gICAgICAgIGxldCB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGluamVjdC5jaGlsZChpKSk7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAgICAgICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICAgICAgICBsZXQgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgICAgICAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSwgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoVHlwZShuZXh0LnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFrZW4rKztcbiAgICAgICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgICBpZiAoIXRvRW5kKVxuICAgICAgICAgICAgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgZnJvbnRpZXJEZXB0aCwgRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgICAgdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXS5tYXRjaCA9IG1hdGNoO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gICAgICAgIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICAgICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgLy8gQWRkIG5ldyBmcm9udGllciBub2RlcyBmb3IgYW55IG9wZW4gbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ciA9IGZyYWdtZW50OyBpIDwgb3BlbkVuZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KSB9KTtcbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYHRoaXMudW5wbGFjZWRgLiBEcm9wIHRoZSBlbnRpcmUgbm9kZSBmcm9tIHdoaWNoIHdlXG4gICAgICAgIC8vIHBsYWNlZCBpdCB3ZSBnb3QgdG8gaXRzIGVuZCwgb3RoZXJ3aXNlIGp1c3QgZHJvcCB0aGUgcGxhY2VkXG4gICAgICAgIC8vIG5vZGVzLlxuICAgICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgICAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gICAgbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSwgbGV2ZWw7XG4gICAgICAgIGlmICghdG9wLnR5cGUuaXNUZXh0YmxvY2sgfHwgIWNvbnRlbnRBZnRlckZpdHModGhpcy4kdG8sIHRoaXMuJHRvLmRlcHRoLCB0b3AudHlwZSwgdG9wLm1hdGNoLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHsgZGVwdGggfSA9IHRoaXMuJHRvLCBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpXG4gICAgICAgICAgICArK2FmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICAgIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgICAgICAgbGV0IGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICAgICAgICAgIGxldCBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgICAgICBpZiAoIWZpdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltkXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCB0eXBlLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlcHRoOiBpLCBmaXQsIG1vdmU6IGRyb3BJbm5lciA/ICR0by5kb2MucmVzb2x2ZSgkdG8uYWZ0ZXIoaSArIDEpKSA6ICR0byB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCR0bykge1xuICAgICAgICBsZXQgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICAgIGlmICghY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICAgJHRvID0gY2xvc2UubW92ZTtcbiAgICAgICAgZm9yIChsZXQgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkKSwgYWRkID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgJHRvLmluZGV4KGQpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0bztcbiAgICB9XG4gICAgb3BlbkZyb250aWVyTm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZSwgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoIH0pO1xuICAgIH1cbiAgICBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICAgICAgICBsZXQgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGFkZC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmZyb250aWVyLmxlbmd0aCwgYWRkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBmcmFnbWVudC5sYXN0Q2hpbGQuY29weShhZGRUb0ZyYWdtZW50KGZyYWdtZW50Lmxhc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvbnRlbnQpKSk7XG59XG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDw9IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgICAgICBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuICAgIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgICAgICBpZiAob3BlbkVuZCA8PSAwKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpO1xuICAgIGxldCB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICAgIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKVxuICAgICAgICB0YXJnZXREZXB0aHMucG9wKCk7XG4gICAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gICAgLy8gdGhhdCBkZXB0aCwgYnV0IHJlcGxhY2luZyBmcm9tICRmcm9tLmJlZm9yZSgtRCkgdG8gJHRvLnBvcy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICAgIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gICAgLy8gVGhpcyBsb29wIHBpY2tzIGEgcHJlZmVycmVkIHRhcmdldCBkZXB0aCwgaWYgb25lIG9mIHRoZSBjb3ZlcmluZ1xuICAgIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gICAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGNyb3NzIGEgZGVmaW5pbmcgbm9kZS5cbiAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgICAgIGxldCBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpXG4gICAgICAgICAgICBwcmVmZXJyZWRUYXJnZXQgPSBkO1xuICAgICAgICBlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKVxuICAgICAgICAgICAgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gICAgLy8gdGFyZ2V0IGRlcHRoLCBzdGFydGluZyB3aXRoIHRoZSBwcmVmZXJyZWQgZGVwdGhzLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gICAgbGV0IGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgICBmb3IgKGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgLy8gQmFjayB1cCBwcmVmZXJyZWREZXB0aCB0byBjb3ZlciBkZWZpbmluZyB0ZXh0YmxvY2tzIGRpcmVjdGx5XG4gICAgLy8gYWJvdmUgaXQsIHBvc3NpYmx5IHNraXBwaW5nIGEgbm9uLWRlZmluaW5nIHRleHRibG9jay5cbiAgICBmb3IgKGxldCBkID0gcHJlZmVycmVkRGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0Tm9kZXNbZF0sIGRlZiA9IGRlZmluZXNDb250ZW50KGxlZnROb2RlLnR5cGUpO1xuICAgICAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSlcbiAgICAgICAgICAgIHByZWZlcnJlZERlcHRoID0gZDtcbiAgICAgICAgZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGxldCBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICAgICAgaWYgKCFpbnNlcnQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgICAgICAgbGV0IHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgU2xpY2UoY2xvc2VGcmFnbWVudChzbGljZS5jb250ZW50LCAwLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5EZXB0aCksIG9wZW5EZXB0aCwgc2xpY2Uub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydFN0ZXBzID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVwdGggPSB0YXJnZXREZXB0aHNbaV07XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gICAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aCh0ciwgZnJvbSwgdG8sIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICAgIGxldCBwb2ludCA9IGluc2VydFBvaW50KHRyLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICBmcm9tID0gdG8gPSBwb2ludDtcbiAgICB9XG4gICAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xufVxuZnVuY3Rpb24gZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBsZXQgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKChsYXN0ICYmIGRlcHRoID09IDApIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkICYmXG4gICAgICAgICAgICAkZnJvbS5zdGFydChkIC0gMSkgPT0gJHRvLnN0YXJ0KGQgLSAxKSAmJiAkZnJvbS5ub2RlKGQgLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGQgLSAxKSwgJHRvLmluZGV4KGQgLSAxKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIGRvYyBub2RlLlxuKi9cbmNsYXNzIERvY0F0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gZG9jLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGRvYy50eXBlLmNyZWF0ZShhdHRycywgZG9jLmNvbnRlbnQsIGRvYy5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAodGhpcy5hdHRyLCBkb2MuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImRvY0F0dHJcIiwgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIERvY0F0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJkb2NBdHRyXCIsIERvY0F0dHJTdGVwKTtcblxuLyoqXG5AaW50ZXJuYWxcbiovXG5sZXQgVHJhbnNmb3JtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiBlcnI7XG59O1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcbi8qKlxuQWJzdHJhY3Rpb24gdG8gYnVpbGQgdXAgYW5kIHRyYWNrIGFuIGFycmF5IG9mXG5bc3RlcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uXG5cbk1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xudGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxuKi9cbmNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zZm9ybSkuXG4gICAgKi9cbiAgICBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBkb2N1bWVudHMgYmVmb3JlIGVhY2ggb2YgdGhlIHN0ZXBzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7IH1cbiAgICAvKipcbiAgICBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4gICAgZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cbiAgICAqL1xuICAgIHN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAoc3RlcCk7XG4gICAgICAgIGlmIChyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuICAgIGZhaWxzLiBSZXR1cm5zIHRoZSBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNoYW5nZWQgKHdoZW4gdGhlcmUgYXJlIGFueVxuICAgIHN0ZXBzKS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbiAgICBnaXZlbiBgc2xpY2VgLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuICAgIGZyYWdtZW50LCBub2RlLCBvciBhcnJheSBvZiBub2Rlcy5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBkZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIHNsaWNlLCB1c2luZ1xuICAgIGBmcm9tYCwgYHRvYCwgYW5kIHRoZSBzbGljZSdzXG4gICAgW2BvcGVuU3RhcnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2xpY2Uub3BlblN0YXJ0KSBwcm9wZXJ0eSBhcyBoaW50cywgcmF0aGVyXG4gICAgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5IGdyb3cgdGhlXG4gICAgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0byBnZXQgYVxuICAgIGZpdCB0aGF0IGlzIG1vcmUgaW4gbGluZSB3aXRoIFdZU0lXWUcgZXhwZWN0YXRpb25zLCBieSBkcm9wcGluZ1xuICAgIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlbiB0aGV5IGFyZVxuICAgIG1hcmtlZCBbbm9uLWRlZmluaW5nIGFzXG4gICAgY29udGV4dF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nQXNDb250ZXh0KSwgb3IgaW5jbHVkaW5nIGFuXG4gICAgb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzIFtkZWZpbmluZ1xuICAgIGl0cyBjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdGb3JDb250ZW50KS5cbiAgICBcbiAgICBUaGlzIGlzIHRoZSBtZXRob2QsIGZvciBleGFtcGxlLCB0byBoYW5kbGUgcGFzdGUuIFRoZSBzaW1pbGFyXG4gICAgW2ByZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuICAgIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbiAgICByYW5nZSwgYW5kIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIG1vcmUgcHJlY2lzZVxuICAgIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4gICAgaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuICAgIGFuZCBhcmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHBhcmVudCBub2RlIGluIHdoaWNoIHRoZSBnaXZlblxuICAgIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuICAgIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgY29tcGxldGVseSBjb3ZlcnMgYSBwYXJlbnQgbm9kZSwgdGhpcyBtZXRob2QgbWF5IGNvbXBsZXRlbHkgcmVwbGFjZVxuICAgIHRoYXQgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbiAgICBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuICAgICovXG4gICAgZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4gICAgaXMgc2libGluZyBjb250ZW50IGJlZm9yZSBvciBhZnRlciBpdCwgYW5kIG1vdmUgaXQgdXAgdGhlIHRyZWUgdG9cbiAgICB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAgICBbYGxpZnRUYXJnZXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2VcbiAgICBzdXJlIHRoZSBsaWZ0IGlzIHZhbGlkLlxuICAgICovXG4gICAgbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICAgIGxpZnQodGhpcywgcmFuZ2UsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIHRoZSBibG9ja3MgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgZGVwdGggaXMgMiwgdGhlaXJcbiAgICBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIGpvaW4ocG9zLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbiAgICBUaGUgd3JhcHBlcnMgYXJlIGFzc3VtZWQgdG8gYmUgdmFsaWQgaW4gdGhpcyBwb3NpdGlvbiwgYW5kIHNob3VsZFxuICAgIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG4gICAgKi9cbiAgICB3cmFwKHJhbmdlLCB3cmFwcGVycykge1xuICAgICAgICB3cmFwKHRoaXMsIHJhbmdlLCB3cmFwcGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHR5cGUgb2YgYWxsIHRleHRibG9ja3MgKHBhcnRseSkgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgdG9cbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzZXRCbG9ja1R5cGUoZnJvbSwgdG8gPSBmcm9tLCB0eXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICAgICAgc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbiAgICBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4gICAgKi9cbiAgICBzZXROb2RlTWFya3VwKHBvcywgdHlwZSwgYXR0cnMgPSBudWxsLCBtYXJrcykge1xuICAgICAgICBzZXROb2RlTWFya3VwKHRoaXMsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYSBnaXZlbiBub2RlIHRvIGEgbmV3IHZhbHVlLlxuICAgIFRoZSBgcG9zYCBhZGRyZXNzZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQuIFVzZSBgc2V0RG9jQXR0cmlidXRlYFxuICAgIHRvIHNldCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgKi9cbiAgICBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBdHRyU3RlcChwb3MsIGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldERvY0F0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IERvY0F0dHJTdGVwKGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBub2RlIGF0IHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgYWRkTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayAob3IgYSBtYXJrIG9mIHRoZSBnaXZlbiB0eXBlKSBmcm9tIHRoZSBub2RlIGF0XG4gICAgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICByZW1vdmVOb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgaWYgKCEobWFyayBpbnN0YW5jZW9mIE1hcmspKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgICAgICBtYXJrID0gbWFyay5pc0luU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKCFtYXJrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgb3B0aW9uYWxseSwgaWYgYGRlcHRoYCBpc1xuICAgIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4gICAgcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhbiBhcnJheSBvZiB0eXBlcyBhbmQgYXR0cmlidXRlcyB0b1xuICAgIHVzZSBhZnRlciB0aGUgc3BsaXQgKHdpdGggdGhlIG91dGVybW9zdCBub2RlcyBjb21pbmcgZmlyc3QpLlxuICAgICovXG4gICAgc3BsaXQocG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICAgICAgc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICBhZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBtYXJrYCBpcyBhIHNpbmdsZSBtYXJrLCByZW1vdmUgcHJlY2lzZWx5IHRoYXQgbWFyay4gV2hlbiBpdCBpc1xuICAgIGEgbWFyayB0eXBlLCByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLFxuICAgIHJlbW92ZSBhbGwgbWFya3Mgb2YgYW55IHR5cGUuXG4gICAgKi9cbiAgICByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIHJlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyBhbGwgbWFya3MgYW5kIG5vZGVzIGZyb20gdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgYXRcbiAgICBgcG9zYCB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0c1xuICAgIGFuIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuQ29udGVudE1hdGNoKSBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgQWRkTm9kZU1hcmtTdGVwLCBBdHRyU3RlcCwgRG9jQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iXSwibmFtZXMiOlsiUmVwbGFjZUVycm9yIiwiU2xpY2UiLCJGcmFnbWVudCIsIk1hcmtUeXBlIiwiTWFyayIsImxvd2VyMTYiLCJmYWN0b3IxNiIsIk1hdGgiLCJwb3ciLCJtYWtlUmVjb3ZlciIsImluZGV4Iiwib2Zmc2V0IiwicmVjb3ZlckluZGV4IiwidmFsdWUiLCJyZWNvdmVyT2Zmc2V0IiwiREVMX0JFRk9SRSIsIkRFTF9BRlRFUiIsIkRFTF9BQ1JPU1MiLCJERUxfU0lERSIsIk1hcFJlc3VsdCIsInBvcyIsImRlbEluZm8iLCJyZWNvdmVyIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwiZ2V0IiwiU3RlcE1hcCIsInJhbmdlcyIsImludmVydGVkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZW1wdHkiLCJkaWZmIiwiaSIsIm1hcFJlc3VsdCIsImFzc29jIiwiX21hcCIsIm1hcCIsInNpbXBsZSIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJzdGFydCIsIm9sZFNpemUiLCJuZXdTaXplIiwiZW5kIiwic2lkZSIsInJlc3VsdCIsImRlbCIsInRvdWNoZXMiLCJmb3JFYWNoIiwiZiIsIm9sZFN0YXJ0IiwibmV3U3RhcnQiLCJpbnZlcnQiLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJuIiwiTWFwcGluZyIsIm1hcHMiLCJtaXJyb3IiLCJmcm9tIiwidG8iLCJfbWFwcyIsIm93bkRhdGEiLCJzbGljZSIsImFwcGVuZE1hcCIsIm1pcnJvcnMiLCJwdXNoIiwic2V0TWlycm9yIiwiYXBwZW5kTWFwcGluZyIsIm1hcHBpbmciLCJzdGFydFNpemUiLCJtaXJyIiwiZ2V0TWlycm9yIiwibSIsImFwcGVuZE1hcHBpbmdJbnZlcnRlZCIsInRvdGFsU2l6ZSIsImludmVyc2UiLCJjb3JyIiwic3RlcHNCeUlEIiwiT2JqZWN0IiwiY3JlYXRlIiwiU3RlcCIsImdldE1hcCIsIm1lcmdlIiwib3RoZXIiLCJmcm9tSlNPTiIsInNjaGVtYSIsImpzb24iLCJzdGVwVHlwZSIsIlJhbmdlRXJyb3IiLCJ0eXBlIiwiY29uY2F0IiwianNvbklEIiwiaWQiLCJzdGVwQ2xhc3MiLCJwcm90b3R5cGUiLCJTdGVwUmVzdWx0IiwiZG9jIiwiZmFpbGVkIiwib2siLCJmYWlsIiwibWVzc2FnZSIsImZyb21SZXBsYWNlIiwicmVwbGFjZSIsImUiLCJtYXBGcmFnbWVudCIsImZyYWdtZW50IiwicGFyZW50IiwibWFwcGVkIiwiY2hpbGRDb3VudCIsImNoaWxkIiwiY29udGVudCIsInNpemUiLCJjb3B5IiwiaXNJbmxpbmUiLCJmcm9tQXJyYXkiLCJBZGRNYXJrU3RlcCIsIl9TdGVwIiwibWFyayIsIl90aGlzMiIsIl9jYWxsU3VwZXIiLCJfaW5oZXJpdHMiLCJhcHBseSIsIl90aGlzMyIsIm9sZFNsaWNlIiwiJGZyb20iLCJyZXNvbHZlIiwibm9kZSIsInNoYXJlZERlcHRoIiwiaXNBdG9tIiwiYWxsb3dzTWFya1R5cGUiLCJhZGRUb1NldCIsIm1hcmtzIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIlJlbW92ZU1hcmtTdGVwIiwiZGVsZXRlZCIsImVxIiwibWluIiwibWF4IiwidG9KU09OIiwibWFya0Zyb21KU09OIiwiX1N0ZXAyIiwiX3RoaXM0IiwiX3RoaXM1IiwicmVtb3ZlRnJvbVNldCIsIkFkZE5vZGVNYXJrU3RlcCIsIl9TdGVwMyIsIl90aGlzNiIsIm5vZGVBdCIsInVwZGF0ZWQiLCJhdHRycyIsImlzTGVhZiIsIm5ld1NldCIsImlzSW5TZXQiLCJSZW1vdmVOb2RlTWFya1N0ZXAiLCJkZWxldGVkQWZ0ZXIiLCJfU3RlcDQiLCJfdGhpczciLCJSZXBsYWNlU3RlcCIsIl9TdGVwNSIsIl90aGlzOCIsInN0cnVjdHVyZSIsImNvbnRlbnRCZXR3ZWVuIiwiZGVsZXRlZEFjcm9zcyIsImFwcGVuZCIsIlJlcGxhY2VBcm91bmRTdGVwIiwiX1N0ZXA2IiwiZ2FwRnJvbSIsImdhcFRvIiwiaW5zZXJ0IiwiX3RoaXM5IiwiZ2FwIiwiaW5zZXJ0ZWQiLCJpbnNlcnRBdCIsInJlbW92ZUJldHdlZW4iLCJkaXN0IiwiZGVwdGgiLCJpbmRleEFmdGVyIiwibmV4dCIsIm1heWJlQ2hpbGQiLCJmaXJzdENoaWxkIiwiYWRkTWFyayIsInRyIiwicmVtb3ZlZCIsImFkZGVkIiwicmVtb3ZpbmciLCJhZGRpbmciLCJub2Rlc0JldHdlZW4iLCJub2RlU2l6ZSIsInMiLCJzdGVwIiwicmVtb3ZlTWFyayIsIm1hdGNoZWQiLCJ0b1JlbW92ZSIsInNldCIsImZvdW5kIiwic3R5bGUiLCJqIiwiY2xlYXJJbmNvbXBhdGlibGUiLCJwYXJlbnRUeXBlIiwibWF0Y2giLCJjb250ZW50TWF0Y2giLCJjbGVhck5ld2xpbmVzIiwicmVwbFN0ZXBzIiwiY3VyIiwiYWxsb3dlZCIsIm1hdGNoVHlwZSIsImlzVGV4dCIsIndoaXRlc3BhY2UiLCJuZXdsaW5lIiwiZXhlYyIsInRleHQiLCJhbGxvd2VkTWFya3MiLCJ2YWxpZEVuZCIsImZpbGwiLCJmaWxsQmVmb3JlIiwiY2FuQ3V0IiwiY2FuUmVwbGFjZSIsImxpZnRUYXJnZXQiLCJyYW5nZSIsImN1dEJ5SW5kZXgiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCIkdG8iLCJzcGVjIiwiaXNvbGF0aW5nIiwibGlmdCIsInRhcmdldCIsImdhcFN0YXJ0IiwiYmVmb3JlIiwiZ2FwRW5kIiwiYWZ0ZXIiLCJkIiwic3BsaXR0aW5nIiwiZmluZFdyYXBwaW5nIiwibm9kZVR5cGUiLCJpbm5lclJhbmdlIiwiYXJvdW5kIiwiZmluZFdyYXBwaW5nT3V0c2lkZSIsImlubmVyIiwiZmluZFdyYXBwaW5nSW5zaWRlIiwid2l0aEF0dHJzIiwiY29udGVudE1hdGNoQXQiLCJvdXRlciIsImNhblJlcGxhY2VXaXRoIiwiaW5zaWRlIiwibGFzdFR5cGUiLCJpbm5lck1hdGNoIiwid3JhcCIsIndyYXBwZXJzIiwibWF0Y2hGcmFnbWVudCIsInNldEJsb2NrVHlwZSIsImlzVGV4dGJsb2NrIiwibWFwRnJvbSIsInN0ZXBzIiwiYXR0cnNIZXJlIiwiaGFzTWFya3VwIiwiY2FuQ2hhbmdlVHlwZSIsImNvbnZlcnROZXdsaW5lcyIsImxpbmVicmVha1JlcGxhY2VtZW50IiwicHJlIiwic3VwcG9ydExpbmVicmVhayIsInJlcGxhY2VMaW5lYnJlYWtzIiwic3RhcnRNIiwiZW5kTSIsInJlcGxhY2VOZXdsaW5lcyIsInJlcGxhY2VXaXRoIiwiJHBvcyIsInNldE5vZGVNYXJrdXAiLCJuZXdOb2RlIiwidmFsaWRDb250ZW50IiwibmFtZSIsImNhblNwbGl0IiwidHlwZXNBZnRlciIsImJhc2UiLCJpbm5lclR5cGUiLCJyZXN0Iiwib3ZlcnJpZGVDaGlsZCIsInJlcGxhY2VDaGlsZCIsImJhc2VUeXBlIiwic3BsaXQiLCJ0eXBlQWZ0ZXIiLCJjYW5Kb2luIiwiam9pbmFibGUiLCJub2RlQmVmb3JlIiwibm9kZUFmdGVyIiwiY2FuQXBwZW5kV2l0aFN1YnN0aXR1dGVkTGluZWJyZWFrcyIsImEiLCJiIiwiY29tcGF0aWJsZUNvbnRlbnQiLCJub2RlcyIsImFsbG93c01hcmtzIiwiam9pblBvaW50IiwiZGlyIiwiam9pbiIsIiRiZWZvcmUiLCJiZWZvcmVUeXBlIiwiaW5saW5lQ29udGVudCIsIiRhZnRlciIsIiRmdWxsIiwiaW5zZXJ0UG9pbnQiLCJwYXJlbnRPZmZzZXQiLCJkcm9wUG9pbnQiLCJwYXNzIiwiYmlhcyIsImluc2VydFBvcyIsImZpdHMiLCJ3cmFwcGluZyIsInJlcGxhY2VTdGVwIiwiZml0c1RyaXZpYWxseSIsIkZpdHRlciIsImZpdCIsInVucGxhY2VkIiwiZnJvbnRpZXIiLCJwbGFjZWQiLCJmaW5kRml0dGFibGUiLCJwbGFjZU5vZGVzIiwib3Blbk1vcmUiLCJkcm9wTm9kZSIsIm1vdmVJbmxpbmUiLCJtdXN0TW92ZUlubGluZSIsInBsYWNlZFNpemUiLCJjbG9zZSIsInN0YXJ0RGVwdGgiLCJzbGljZURlcHRoIiwiY29udGVudEF0IiwiZmlyc3QiLCJmcm9udGllckRlcHRoIiwiX3RoaXMkZnJvbnRpZXIkZnJvbnRpIiwiaW5qZWN0IiwiX3RoaXMkdW5wbGFjZWQiLCJfdGhpcyR1bnBsYWNlZDIiLCJvcGVuQXRFbmQiLCJkcm9wRnJvbUZyYWdtZW50IiwiX3JlZiIsImNsb3NlRnJvbnRpZXJOb2RlIiwib3BlbkZyb250aWVyTm9kZSIsInRha2VuIiwiYWRkIiwiX3RoaXMkZnJvbnRpZXIkZnJvbnRpMiIsIm9wZW5FbmRDb3VudCIsIm1hdGNoZXMiLCJjbG9zZU5vZGVTdGFydCIsInRvRW5kIiwiYWRkVG9GcmFnbWVudCIsImxhc3RDaGlsZCIsInRvcCIsImxldmVsIiwiY29udGVudEFmdGVyRml0cyIsImZpbmRDbG9zZUxldmVsIiwic2NhbiIsIl90aGlzJGZyb250aWVyJGkiLCJkcm9wSW5uZXIiLCJfdGhpcyRmcm9udGllciRkIiwibW92ZSIsIm9wZW4iLCJwb3AiLCJjb3VudCIsImZyYWciLCJpbnZhbGlkTWFya3MiLCJkZWZpbmVzQ29udGVudCIsImRlZmluaW5nIiwiZGVmaW5pbmdGb3JDb250ZW50IiwicmVwbGFjZVJhbmdlIiwiZGVsZXRlUmFuZ2UiLCJ0YXJnZXREZXB0aHMiLCJjb3ZlcmVkRGVwdGhzIiwicHJlZmVycmVkVGFyZ2V0IiwidW5zaGlmdCIsImRlZmluaW5nQXNDb250ZXh0IiwiaW5kZXhPZiIsInNwbGljZSIsInByZWZlcnJlZFRhcmdldEluZGV4IiwibGVmdE5vZGVzIiwicHJlZmVycmVkRGVwdGgiLCJsZWZ0Tm9kZSIsImRlZiIsInNhbWVNYXJrdXAiLCJhYnMiLCJvcGVuRGVwdGgiLCJ0YXJnZXREZXB0aCIsImV4cGFuZCIsImNsb3NlRnJhZ21lbnQiLCJzdGFydFN0ZXBzIiwib2xkT3BlbiIsIm5ld09wZW4iLCJyZXBsYWNlUmFuZ2VXaXRoIiwicG9pbnQiLCJjb3ZlcmVkIiwibGFzdCIsIm1pbkRlcHRoIiwiQXR0clN0ZXAiLCJfU3RlcDciLCJhdHRyIiwiX3RoaXMxMCIsIkRvY0F0dHJTdGVwIiwiX1N0ZXA4IiwiX3RoaXMxMSIsIlRyYW5zZm9ybUVycm9yIiwiX0Vycm9yIiwiX3dyYXBOYXRpdmVTdXBlciIsIkVycm9yIiwiZXJyIiwiY2FsbCIsIl9fcHJvdG9fXyIsImNvbnN0cnVjdG9yIiwiVHJhbnNmb3JtIiwiZG9jcyIsIm1heWJlU3RlcCIsImFkZFN0ZXAiLCJkZWxldGUiLCJzZXROb2RlQXR0cmlidXRlIiwic2V0RG9jQXR0cmlidXRlIiwiYWRkTm9kZU1hcmsiLCJyZW1vdmVOb2RlTWFyayJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-transform/dist/index.js\n");

/***/ })

};
;