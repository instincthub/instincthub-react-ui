"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-model";
exports.ids = ["vendor-chunks/prosemirror-model"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* binding */ ContentMatch),\n/* harmony export */   DOMParser: () => (/* binding */ DOMParser),\n/* harmony export */   DOMSerializer: () => (/* binding */ DOMSerializer),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkType: () => (/* binding */ MarkType),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeRange: () => (/* binding */ NodeRange),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ReplaceError: () => (/* binding */ ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* binding */ ResolvedPos),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Slice: () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"(ssr)/./node_modules/orderedmap/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _callSuper(_this, derived, args) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (e) {\n      return false;\n    }\n  }\n  derived = _getPrototypeOf(derived);\n  return _possibleConstructorReturn(_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf(_this).constructor) : derived.apply(_this, args));\n}\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n    var childA = a.child(i),\n      childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction _findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) return iA == iB ? null : {\n      a: posA,\n      b: posB\n    };\n    var childA = a.child(--iA),\n      childB = b.child(--iB),\n      size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return {\n      a: posA,\n      b: posB\n    };\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n        minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\n\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/\nvar Fragment = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Fragment(\n  /**\n  The child nodes in this fragment.\n  */\n  content, size) {\n    _classCallCheck(this, Fragment);\n    this.content = content;\n    this.size = size || 0;\n    if (size == null) for (var i = 0; i < content.length; i++) this.size += content[i].nodeSize;\n  }\n  /**\n  Invoke a callback for all descendant nodes between the given two\n  positions (relative to start of this fragment). Doesn't descend\n  into a node when the callback returns `false`.\n  */\n  return _createClass(Fragment, [{\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var parent = arguments.length > 4 ? arguments[4] : undefined;\n      for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          var start = pos + 1;\n          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      var text = \"\",\n        first = true;\n      this.nodesBetween(from, to, function (node, pos) {\n        var nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n          if (first) first = false;else text += blockSeparator;\n        }\n        text += nodeText;\n      }, 0);\n      return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      if (!other.size) return this;\n      if (!this.size) return other;\n      var last = this.lastChild,\n        first = other.firstChild,\n        content = this.content.slice(),\n        i = 0;\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.withText(last.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++) content.push(other.content[i]);\n      return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      if (from == 0 && to == this.size) return this;\n      var result = [],\n        size = 0;\n      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n      return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"cutByIndex\",\n    value: function cutByIndex(from, to) {\n      if (from == to) return Fragment.empty;\n      if (from == 0 && to == this.content.length) return this;\n      return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(index, node) {\n      var current = this.content[index];\n      if (current == node) return this;\n      var copy = this.content.slice();\n      var size = this.size + node.nodeSize - current.nodeSize;\n      copy[index] = node;\n      return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(node) {\n      return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(node) {\n      return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this.content.length != other.content.length) return false;\n      for (var i = 0; i < this.content.length; i++) if (!this.content[i].eq(other.content[i])) return false;\n      return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      var found = this.content[index];\n      if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0, p = 0; i < this.content.length; i++) {\n        var child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n  }, {\n    key: \"findDiffStart\",\n    value: function findDiffStart(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n  }, {\n    key: \"findDiffEnd\",\n    value: function findDiffEnd(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;\n      return _findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos) {\n      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      if (pos == 0) return retIndex(0, pos);\n      if (pos == this.size) return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0) throw new RangeError(\"Position \".concat(pos, \" outside of fragment (\").concat(this, \")\"));\n      for (var i = 0, curPos = 0;; i++) {\n        var cur = this.child(i),\n          end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos || round > 0) return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"toStringInner\",\n    value: function toStringInner() {\n      return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.content.length ? this.content.map(function (n) {\n        return n.toJSON();\n      }) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, value) {\n      if (!value) return Fragment.empty;\n      if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      if (!array.length) return Fragment.empty;\n      var joined,\n        size = 0;\n      for (var i = 0; i < array.length; i++) {\n        var node = array[i];\n        size += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined) joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n  }, {\n    key: \"from\",\n    value: function from(nodes) {\n      if (!nodes) return Fragment.empty;\n      if (nodes instanceof Fragment) return nodes;\n      if (Array.isArray(nodes)) return this.fromArray(nodes);\n      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  }]);\n}();\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/\nFragment.empty = new Fragment([], 0);\nvar found = {\n  index: 0,\n  offset: 0\n};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\nfunction compareDeep(a, b) {\n  if (a === b) return true;\n  if (!(a && _typeof(a) == \"object\") || !(b && _typeof(b) == \"object\")) return false;\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) return false;\n  if (array) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false;\n  } else {\n    for (var p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n    for (var _p in b) if (!(_p in a)) return false;\n  }\n  return true;\n}\n\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/\nvar Mark = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Mark(\n  /**\n  The type of this mark.\n  */\n  type,\n  /**\n  The attributes associated with this mark.\n  */\n  attrs) {\n    _classCallCheck(this, Mark);\n    this.type = type;\n    this.attrs = attrs;\n  }\n  /**\n  Given a set of marks, create a new set which contains this one as\n  well, in the right position. If this mark is already in the set,\n  the set itself is returned. If any marks that are set to be\n  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n  those are replaced by this one.\n  */\n  return _createClass(Mark, [{\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      var copy,\n        placed = false;\n      for (var i = 0; i < set.length; i++) {\n        var other = set[i];\n        if (this.eq(other)) return set;\n        if (this.type.excludes(other.type)) {\n          if (!copy) copy = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy) copy = set.slice(0, i);\n            copy.push(this);\n            placed = true;\n          }\n          if (copy) copy.push(other);\n        }\n      }\n      if (!copy) copy = set.slice();\n      if (!placed) copy.push(this);\n      return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n      return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return true;\n      return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      var type = schema.marks[json.type];\n      if (!type) throw new RangeError(\"There is no mark type \".concat(json.type, \" in this schema\"));\n      var mark = type.create(json.attrs);\n      type.checkAttrs(mark.attrs);\n      return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n  }, {\n    key: \"sameSet\",\n    value: function sameSet(a, b) {\n      if (a == b) return true;\n      if (a.length != b.length) return false;\n      for (var i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;\n      return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(marks) {\n      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n      if (marks instanceof Mark) return [marks];\n      var copy = marks.slice();\n      copy.sort(function (a, b) {\n        return a.type.rank - b.type.rank;\n      });\n      return copy;\n    }\n  }]);\n}();\n/**\nThe empty set of marks.\n*/\nMark.none = [];\n\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/\nvar ReplaceError = /*#__PURE__*/function (_Error) {\n  function ReplaceError() {\n    _classCallCheck(this, ReplaceError);\n    return _callSuper(this, ReplaceError, arguments);\n  }\n  _inherits(ReplaceError, _Error);\n  return _createClass(ReplaceError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/\n/**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/\nvar Slice = /*#__PURE__*/function () {\n  /**\n  Create a slice. When specifying a non-zero open depth, you must\n  make sure that there are nodes of at least that depth at the\n  appropriate side of the fragment—i.e. if the fragment is an\n  empty paragraph node, `openStart` and `openEnd` can't be greater\n  than 1.\n  \n  It is not necessary for the content of open nodes to conform to\n  the schema's content constraints, though it should be a valid\n  start/end/middle for such a node, depending on which sides are\n  open.\n  */\n  function Slice(\n  /**\n  The slice's content.\n  */\n  content,\n  /**\n  The open depth at the start of the fragment.\n  */\n  openStart,\n  /**\n  The open depth at the end.\n  */\n  openEnd) {\n    _classCallCheck(this, Slice);\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n  /**\n  The size this slice would add when inserted into a document.\n  */\n  return _createClass(Slice, [{\n    key: \"size\",\n    get: function get() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(pos, fragment) {\n      var content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"removeBetween\",\n    value: function removeBetween(from, to) {\n      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this.content.size) return null;\n      var json = {\n        content: this.content.toJSON()\n      };\n      if (this.openStart > 0) json.openStart = this.openStart;\n      if (this.openEnd > 0) json.openEnd = this.openEnd;\n      return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) return Slice.empty;\n      var openStart = json.openStart || 0,\n        openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n  }, {\n    key: \"maxOpen\",\n    value: function maxOpen(fragment) {\n      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var openStart = 0,\n        openEnd = 0;\n      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;\n      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) openEnd++;\n      return new Slice(fragment, openStart, openEnd);\n    }\n  }]);\n}();\n/**\nThe empty slice.\n*/\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n  var _content$findIndex = content.findIndex(from),\n    index = _content$findIndex.index,\n    offset = _content$findIndex.offset,\n    child = content.maybeChild(index);\n  var _content$findIndex2 = content.findIndex(to),\n    indexTo = _content$findIndex2.index,\n    offsetTo = _content$findIndex2.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n  var _content$findIndex3 = content.findIndex(dist),\n    index = _content$findIndex3.index,\n    offset = _content$findIndex3.offset,\n    child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction _replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n    node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    // Simple, flat case\n    var parent = $from.parent,\n      content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),\n      start = _prepareSliceForRepla.start,\n      end = _prepareSliceForRepla.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n    endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) addNode(node.child(i), target);\n  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n  node.type.checkContent(content);\n  return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n    parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--) node = $along.node(i).copy(Fragment.from(node));\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\n\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/\nvar ResolvedPos = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function ResolvedPos(\n  /**\n  The position that was resolved.\n  */\n  pos,\n  /**\n  @internal\n  */\n  path,\n  /**\n  The offset this position has into its parent node.\n  */\n  parentOffset) {\n    _classCallCheck(this, ResolvedPos);\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n  /**\n  @internal\n  */\n  return _createClass(ResolvedPos, [{\n    key: \"resolveDepth\",\n    value: function resolveDepth(val) {\n      if (val == null) return this.depth;\n      if (val < 0) return this.depth + val;\n      return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */\n  }, {\n    key: \"doc\",\n    get: function get() {\n      return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n  }, {\n    key: \"node\",\n    value: function node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n  }, {\n    key: \"index\",\n    value: function index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n  }, {\n    key: \"start\",\n    value: function start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n  }, {\n    key: \"end\",\n    value: function end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n  }, {\n    key: \"before\",\n    value: function before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n  }, {\n    key: \"after\",\n    value: function after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n  }, {\n    key: \"textOffset\",\n    get: function get() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      var parent = this.parent,\n        index = this.index(this.depth);\n      if (index == parent.childCount) return null;\n      var dOff = this.pos - this.path[this.path.length - 1],\n        child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      var index = this.index(this.depth);\n      var dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff) return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n  }, {\n    key: \"posAtIndex\",\n    value: function posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      var node = this.path[depth * 3],\n        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n      for (var i = 0; i < index; i++) pos += node.child(i).nodeSize;\n      return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n  }, {\n    key: \"marks\",\n    value: function marks() {\n      var parent = this.parent,\n        index = this.index();\n      // In an empty parent, return the empty array\n      if (parent.content.size == 0) return Mark.none;\n      // When inside a text node, just return the text node's marks\n      if (this.textOffset) return parent.child(index).marks;\n      var main = parent.maybeChild(index - 1),\n        other = parent.maybeChild(index);\n      // If the `after` flag is true of there is no node before, make\n      // the node after this position the main reference.\n      if (!main) {\n        var tmp = main;\n        main = other;\n        other = tmp;\n      }\n      // Use all marks in the main node, except those that have\n      // `inclusive` set to false and are not present in the other node.\n      var marks = main.marks;\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */\n  }, {\n    key: \"marksAcross\",\n    value: function marksAcross($end) {\n      var after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline) return null;\n      var marks = after.marks,\n        next = $end.parent.maybeChild($end.index());\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n  }, {\n    key: \"sharedDepth\",\n    value: function sharedDepth(pos) {\n      for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n      return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n  }, {\n    key: \"blockRange\",\n    value: function blockRange() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n      var pred = arguments.length > 1 ? arguments[1] : undefined;\n      if (other.pos < this.pos) return other.blockRange(this);\n      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n      return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n  }, {\n    key: \"sameParent\",\n    value: function sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n  }, {\n    key: \"max\",\n    value: function max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n  }, {\n    key: \"min\",\n    value: function min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n      for (var i = 1; i <= this.depth; i++) str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"resolve\",\n    value: function resolve(doc, pos) {\n      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n      var path = [];\n      var start = 0,\n        parentOffset = pos;\n      for (var node = doc;;) {\n        var _node$content$findInd = node.content.findIndex(parentOffset),\n          index = _node$content$findInd.index,\n          offset = _node$content$findInd.offset;\n        var rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem) break;\n        node = node.child(index);\n        if (node.isText) break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"resolveCached\",\n    value: function resolveCached(doc, pos) {\n      var cache = resolveCache.get(doc);\n      if (cache) {\n        for (var i = 0; i < cache.elts.length; i++) {\n          var elt = cache.elts[i];\n          if (elt.pos == pos) return elt;\n        }\n      } else {\n        resolveCache.set(doc, cache = new ResolveCache());\n      }\n      var result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n      cache.i = (cache.i + 1) % resolveCacheSize;\n      return result;\n    }\n  }]);\n}();\nvar ResolveCache = /*#__PURE__*/_createClass(function ResolveCache() {\n  _classCallCheck(this, ResolveCache);\n  this.elts = [];\n  this.i = 0;\n});\nvar resolveCacheSize = 12,\n  resolveCache = new WeakMap();\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/\nvar NodeRange = /*#__PURE__*/function () {\n  /**\n  Construct a node range. `$from` and `$to` should point into the\n  same node until at least the given `depth`, since a node range\n  denotes an adjacent set of nodes in a single parent node.\n  */\n  function NodeRange(\n  /**\n  A resolved position along the start of the content. May have a\n  `depth` greater than this object's `depth` property, since\n  these are the positions that were used to compute the range,\n  not re-resolved positions directly at its boundaries.\n  */\n  $from,\n  /**\n  A position along the end of the content. See\n  caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n  */\n  $to,\n  /**\n  The depth of the node that this range points into.\n  */\n  depth) {\n    _classCallCheck(this, NodeRange);\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n  /**\n  The position at the start of the range.\n  */\n  return _createClass(NodeRange, [{\n    key: \"start\",\n    get: function get() {\n      return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      return this.$to.indexAfter(this.depth);\n    }\n  }]);\n}();\nvar emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](https://prosemirror.net/docs/guide/#doc) for more information.\n*/\nvar Node = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Node(\n  /**\n  The type of node that this is.\n  */\n  type,\n  /**\n  An object mapping attribute names to values. The kind of\n  attributes allowed and required are\n  [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n  */\n  attrs,\n  // A fragment holding the node's children.\n  content) {\n    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;\n    _classCallCheck(this, Node);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n  /**\n  The array of this node's child nodes.\n  */\n  return _createClass(Node, [{\n    key: \"children\",\n    get: function get() {\n      return this.content.content;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.\n    */\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n  }, {\n    key: \"sameMarkup\",\n    value: function sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */\n  }, {\n    key: \"hasMarkup\",\n    value: function hasMarkup(type, attrs, marks) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (content == this.content) return this;\n      return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      if (from == 0 && to == this.content.size) return this;\n      return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (from == to) return Slice.empty;\n      var $from = this.resolve(from),\n        $to = this.resolve(to);\n      var depth = includeParents ? 0 : $from.sharedDepth(to);\n      var start = $from.start(depth),\n        node = $from.node(depth);\n      var content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, slice) {\n      return _replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(pos) {\n      for (var node = this;;) {\n        var _node$content$findInd2 = node.content.findIndex(pos),\n          index = _node$content$findInd2.index,\n          offset = _node$content$findInd2.offset;\n        node = node.maybeChild(index);\n        if (!node) return null;\n        if (offset == pos || node.isText) return node;\n        pos -= offset + 1;\n      }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      var _this$content$findInd = this.content.findIndex(pos),\n        index = _this$content$findInd.index,\n        offset = _this$content$findInd.offset;\n      return {\n        node: this.content.maybeChild(index),\n        index: index,\n        offset: offset\n      };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      if (pos == 0) return {\n        node: null,\n        index: 0,\n        offset: 0\n      };\n      var _this$content$findInd2 = this.content.findIndex(pos),\n        index = _this$content$findInd2.index,\n        offset = _this$content$findInd2.offset;\n      if (offset < pos) return {\n        node: this.content.child(index),\n        index: index,\n        offset: offset\n      };\n      var node = this.content.child(index - 1);\n      return {\n        node: node,\n        index: index - 1,\n        offset: offset - node.nodeSize\n      };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"resolveNoCache\",\n    value: function resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n  }, {\n    key: \"rangeHasMark\",\n    value: function rangeHasMark(from, to, type) {\n      var found = false;\n      if (to > from) this.nodesBetween(from, to, function (node) {\n        if (type.isInSet(node.marks)) found = true;\n        return !found;\n      });\n      return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      var name = this.type.name;\n      if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n  }, {\n    key: \"contentMatchAt\",\n    value: function contentMatchAt(index) {\n      var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n  }, {\n    key: \"canReplace\",\n    value: function canReplace(from, to) {\n      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;\n      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;\n      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n      var two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd) return false;\n      for (var i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n      return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */\n  }, {\n    key: \"canReplaceWith\",\n    value: function canReplaceWith(from, to, type, marks) {\n      if (marks && !this.type.allowsMarks(marks)) return false;\n      var start = this.contentMatchAt(from).matchType(type);\n      var end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n  }, {\n    key: \"canAppend\",\n    value: function canAppend(other) {\n      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */\n  }, {\n    key: \"check\",\n    value: function check() {\n      this.type.checkContent(this.content);\n      this.type.checkAttrs(this.attrs);\n      var copy = Mark.none;\n      for (var i = 0; i < this.marks.length; i++) {\n        var mark = this.marks[i];\n        mark.type.checkAttrs(mark.attrs);\n        copy = mark.addToSet(copy);\n      }\n      if (!Mark.sameSet(copy, this.marks)) throw new RangeError(\"Invalid collection of marks for node \".concat(this.type.name, \": \").concat(this.marks.map(function (m) {\n        return m.type.name;\n      })));\n      this.content.forEach(function (node) {\n        return node.check();\n      });\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size) obj.content = this.content.toJSON();\n      if (this.marks.length) obj.marks = this.marks.map(function (n) {\n        return n.toJSON();\n      });\n      return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n      var marks = undefined;\n      if (json.marks) {\n        if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks = json.marks.map(schema.markFromJSON);\n      }\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n        return schema.text(json.text, marks);\n      }\n      var content = Fragment.fromJSON(schema, json.content);\n      var node = schema.nodeType(json.type).create(json.attrs, content, marks);\n      node.type.checkAttrs(node.attrs);\n      return node;\n    }\n  }]);\n}();\nNode.prototype.text = undefined;\nvar TextNode = /*#__PURE__*/function (_Node) {\n  /**\n  @internal\n  */\n  function TextNode(type, attrs, content, marks) {\n    var _this2;\n    _classCallCheck(this, TextNode);\n    _this2 = _callSuper(this, TextNode, [type, attrs, null, marks]);\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n    _this2.text = content;\n    return _this2;\n  }\n  _inherits(TextNode, _Node);\n  return _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.text;\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to) {\n      return this.text.slice(from, to);\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n  }, {\n    key: \"withText\",\n    value: function withText(text) {\n      if (text == this.text) return this;\n      return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;\n      if (from == 0 && to == this.text.length) return this;\n      return this.withText(this.text.slice(from, to));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var base = _get(_getPrototypeOf(TextNode.prototype), \"toJSON\", this).call(this);\n      base.text = this.text;\n      return base;\n    }\n  }]);\n}(Node);\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) str = marks[i].type.name + \"(\" + str + \")\";\n  return str;\n}\n\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/\nvar ContentMatch = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function ContentMatch(\n  /**\n  True when this match state represents a valid end of the node.\n  */\n  validEnd) {\n    _classCallCheck(this, ContentMatch);\n    this.validEnd = validEnd;\n    /**\n    @internal\n    */\n    this.next = [];\n    /**\n    @internal\n    */\n    this.wrapCache = [];\n  }\n  /**\n  @internal\n  */\n  return _createClass(ContentMatch, [{\n    key: \"matchType\",\n    value:\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    function matchType(type) {\n      for (var i = 0; i < this.next.length; i++) if (this.next[i].type == type) return this.next[i].next;\n      return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n  }, {\n    key: \"matchFragment\",\n    value: function matchFragment(frag) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;\n      var cur = this;\n      for (var i = start; cur && i < end; i++) cur = cur.matchType(frag.child(i).type);\n      return cur;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n  }, {\n    key: \"defaultType\",\n    get: function get() {\n      for (var i = 0; i < this.next.length; i++) {\n        var type = this.next[i].type;\n        if (!(type.isText || type.hasRequiredAttrs())) return type;\n      }\n      return null;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.next.length; i++) for (var j = 0; j < other.next.length; j++) if (this.next[i].type == other.next[j].type) return true;\n      return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n  }, {\n    key: \"fillBefore\",\n    value: function fillBefore(after) {\n      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var seen = [this];\n      function search(match, types) {\n        var finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {\n          return tp.createAndFill();\n        }));\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i = match.next[i],\n            type = _match$next$i.type,\n            next = _match$next$i.next;\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n            var _found = search(next, types.concat(type));\n            if (_found) return _found;\n          }\n        }\n        return null;\n      }\n      return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n  }, {\n    key: \"findWrapping\",\n    value: function findWrapping(target) {\n      for (var i = 0; i < this.wrapCache.length; i += 2) if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n      var computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"computeWrapping\",\n    value: function computeWrapping(target) {\n      var seen = Object.create(null),\n        active = [{\n          match: this,\n          type: null,\n          via: null\n        }];\n      while (active.length) {\n        var current = active.shift(),\n          match = current.match;\n        if (match.matchType(target)) {\n          var result = [];\n          for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);\n          return result.reverse();\n        }\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i2 = match.next[i],\n            type = _match$next$i2.type,\n            next = _match$next$i2.next;\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({\n              match: type.contentMatch,\n              type: type,\n              via: current\n            });\n            seen[type.name] = true;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n  }, {\n    key: \"edgeCount\",\n    get: function get() {\n      return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n  }, {\n    key: \"edge\",\n    value: function edge(n) {\n      if (n >= this.next.length) throw new RangeError(\"There's no \".concat(n, \"th edge in this content match\"));\n      return this.next[n];\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var seen = [];\n      function scan(m) {\n        seen.push(m);\n        for (var i = 0; i < m.next.length; i++) if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n      }\n      scan(this);\n      return seen.map(function (m, i) {\n        var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n        for (var _i = 0; _i < m.next.length; _i++) out += (_i ? \", \" : \"\") + m.next[_i].type.name + \"->\" + seen.indexOf(m.next[_i].next);\n        return out;\n      }).join(\"\\n\");\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(string, nodeTypes) {\n      var stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null) return ContentMatch.empty;\n      var expr = parseExpr(stream);\n      if (stream.next) stream.err(\"Unexpected trailing text\");\n      var match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n  }]);\n}();\n/**\n@internal\n*/\nContentMatch.empty = new ContentMatch(true);\nvar TokenStream = /*#__PURE__*/function () {\n  function TokenStream(string, nodeTypes) {\n    _classCallCheck(this, TokenStream);\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n    if (this.tokens[0] == \"\") this.tokens.shift();\n  }\n  return _createClass(TokenStream, [{\n    key: \"next\",\n    get: function get() {\n      return this.tokens[this.pos];\n    }\n  }, {\n    key: \"eat\",\n    value: function eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n  }, {\n    key: \"err\",\n    value: function err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  }]);\n}();\nfunction parseExpr(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\")) expr = {\n      type: \"plus\",\n      expr: expr\n    };else if (stream.eat(\"*\")) expr = {\n      type: \"star\",\n      expr: expr\n    };else if (stream.eat(\"?\")) expr = {\n      type: \"opt\",\n      expr: expr\n    };else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);else break;\n  }\n  return expr;\n}\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n    max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream);else max = -1;\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n    type = types[name];\n  if (type) return [type];\n  var result = [];\n  for (var typeName in types) {\n    var _type = types[typeName];\n    if (_type.isInGroup(name)) result.push(_type);\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n  function node() {\n    return nfa.push([]) - 1;\n  }\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) return next;\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var _loop = node();\n      connect(compile(expr.expr, from), _loop);\n      connect(compile(expr.expr, _loop), _loop);\n      return [edge(_loop)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var _i2 = 0; _i2 < expr.min; _i2++) {\n        var _next = node();\n        connect(compile(expr.expr, cur), _next);\n        cur = _next;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {\n          var _next2 = node();\n          edge(cur, _next2);\n          connect(compile(expr.expr, cur), _next2);\n          cur = _next2;\n        }\n      }\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, undefined, expr.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\nfunction cmp(a, b) {\n  return b - a;\n}\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var _edges$i = edges[i],\n        term = _edges$i.term,\n        to = _edges$i.to;\n      if (!term && result.indexOf(to) == -1) scan(to);\n    }\n  }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (_ref) {\n        var term = _ref.term,\n          to = _ref.to;\n        if (!term) return;\n        var set;\n        for (var i = 0; i < out.length; i++) if (out[i][0] == term) set = out[i][1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) out.push([term, set = []]);\n          if (set.indexOf(node) == -1) set.push(node);\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i++) {\n      var _states = out[i][1].sort(cmp);\n      state.next.push({\n        type: out[i][0],\n        next: labeled[_states.join(\",\")] || explore(_states)\n      });\n    }\n    return state;\n  }\n}\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n      dead = !state.validEnd,\n      nodes = [];\n    for (var j = 0; j < state.next.length; j++) {\n      var _state$next$j = state.next[j],\n        type = _state$next$j.type,\n        next = _state$next$j.next;\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n      if (work.indexOf(next) == -1) work.push(next);\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) return null;\n    defaults[attrName] = attr[\"default\"];\n  }\n  return defaults;\n}\nfunction _computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) given = attr[\"default\"];else throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n    built[name] = given;\n  }\n  return built;\n}\nfunction _checkAttrs(attrs, values, type, name) {\n  for (var _name in values) if (!(_name in attrs)) throw new RangeError(\"Unsupported attribute \".concat(_name, \" for \").concat(type, \" of type \").concat(_name));\n  for (var _name2 in attrs) {\n    var attr = attrs[_name2];\n    if (attr.validate) attr.validate(values[_name2]);\n  }\n}\nfunction initAttrs(typeName, attrs) {\n  var result = Object.create(null);\n  if (attrs) for (var name in attrs) result[name] = new Attribute(typeName, name, attrs[name]);\n  return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/\nvar NodeType = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function NodeType(\n  /**\n  The name the node type has in this schema.\n  */\n  name,\n  /**\n  A link back to the `Schema` the node type belongs to.\n  */\n  schema,\n  /**\n  The spec that this type is based on\n  */\n  spec) {\n    _classCallCheck(this, NodeType);\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    /**\n    The set of marks allowed in this node. `null` means all marks\n    are allowed.\n    */\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(name, spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n  /**\n  True if this is an inline type.\n  */\n  return _createClass(NodeType, [{\n    key: \"isInline\",\n    get: function get() {\n      return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(group) {\n      return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n  }, {\n    key: \"whitespace\",\n    get: function get() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n  }, {\n    key: \"hasRequiredAttrs\",\n    value: function hasRequiredAttrs() {\n      for (var n in this.attrs) if (this.attrs[n].isRequired) return true;\n      return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n  }, {\n    key: \"compatibleContent\",\n    value: function compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n  }, {\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */\n  }, {\n    key: \"createChecked\",\n    value: function createChecked() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      content = Fragment.from(content);\n      this.checkContent(content);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n  }, {\n    key: \"createAndFill\",\n    value: function createAndFill() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n      if (content.size) {\n        var before = this.contentMatch.fillBefore(content);\n        if (!before) return null;\n        content = before.append(content);\n      }\n      var matched = this.contentMatch.matchFragment(content);\n      var after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after) return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */\n  }, {\n    key: \"validContent\",\n    value: function validContent(content) {\n      var result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd) return false;\n      for (var i = 0; i < content.childCount; i++) if (!this.allowsMarks(content.child(i).marks)) return false;\n      return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n  }, {\n    key: \"checkContent\",\n    value: function checkContent(content) {\n      if (!this.validContent(content)) throw new RangeError(\"Invalid content for node \".concat(this.name, \": \").concat(content.toString().slice(0, 50)));\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n  }, {\n    key: \"allowsMarkType\",\n    value: function allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n  }, {\n    key: \"allowsMarks\",\n    value: function allowsMarks(marks) {\n      if (this.markSet == null) return true;\n      for (var i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false;\n      return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n  }, {\n    key: \"allowedMarks\",\n    value: function allowedMarks(marks) {\n      if (this.markSet == null) return marks;\n      var copy;\n      for (var i = 0; i < marks.length; i++) {\n        if (!this.allowsMarkType(marks[i].type)) {\n          if (!copy) copy = marks.slice(0, i);\n        } else if (copy) {\n          copy.push(marks[i]);\n        }\n      }\n      return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"compile\",\n    value: function compile(nodes, schema) {\n      var result = Object.create(null);\n      nodes.forEach(function (name, spec) {\n        return result[name] = new NodeType(name, schema, spec);\n      });\n      var topType = schema.spec.topNode || \"doc\";\n      if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n      for (var _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\");\n      return result;\n    }\n  }]);\n}();\nfunction validateType(typeName, attrName, type) {\n  var types = type.split(\"|\");\n  return function (value) {\n    var name = value === null ? \"null\" : _typeof(value);\n    if (types.indexOf(name) < 0) throw new RangeError(\"Expected value of type \".concat(types, \" for attribute \").concat(attrName, \" on type \").concat(typeName, \", got \").concat(name));\n  };\n}\n// Attribute descriptors\nvar Attribute = /*#__PURE__*/function () {\n  function Attribute(typeName, attrName, options) {\n    _classCallCheck(this, Attribute);\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this[\"default\"] = options[\"default\"];\n    this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n  }\n  return _createClass(Attribute, [{\n    key: \"isRequired\",\n    get: function get() {\n      return !this.hasDefault;\n    }\n  }]);\n}(); // Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/\nvar MarkType = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function MarkType(\n  /**\n  The name of the mark type.\n  */\n  name,\n  /**\n  @internal\n  */\n  rank,\n  /**\n  The schema that this mark type instance is part of.\n  */\n  schema,\n  /**\n  The spec on which the type is based.\n  */\n  spec) {\n    _classCallCheck(this, MarkType);\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(name, spec.attrs);\n    this.excluded = null;\n    var defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n  /**\n  Create a mark of this type. `attrs` may be `null` or an object\n  containing only some of the mark's attributes. The others, if\n  they have defaults, will be added.\n  */\n  return _createClass(MarkType, [{\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!attrs && this.instance) return this.instance;\n      return new Mark(this, _computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"removeFromSet\",\n    value:\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n        set = set.slice(0, i).concat(set.slice(i + 1));\n        i--;\n      }\n      return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) return set[i];\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n  }, {\n    key: \"excludes\",\n    value: function excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(marks, schema) {\n      var result = Object.create(null),\n        rank = 0;\n      marks.forEach(function (name, spec) {\n        return result[name] = new MarkType(name, rank++, schema, spec);\n      });\n      return result;\n    }\n  }]);\n}();\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/\nvar Schema = /*#__PURE__*/function () {\n  /**\n  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n  */\n  function Schema(spec) {\n    _classCallCheck(this, Schema);\n    /**\n    The [linebreak\n    replacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement) node defined\n    in this schema, if any.\n    */\n    this.linebreakReplacement = null;\n    /**\n    An object for storing whatever values modules may want to\n    compute and cache per schema. (If you want to store something\n    in it, try to use property names unlikely to clash.)\n    */\n    this.cached = Object.create(null);\n    var instanceSpec = this.spec = {};\n    for (var prop in spec) instanceSpec[prop] = spec[prop];\n    instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes), instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    var contentExprCache = Object.create(null);\n    for (var _prop in this.nodes) {\n      if (_prop in this.marks) throw new RangeError(_prop + \" can not be both a node and a mark\");\n      var type = this.nodes[_prop],\n        contentExpr = type.spec.content || \"\",\n        markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      if (type.spec.linebreakReplacement) {\n        if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n        if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n        this.linebreakReplacement = type;\n      }\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n    for (var _prop2 in this.marks) {\n      var _type2 = this.marks[_prop2],\n        excl = _type2.spec.excludes;\n      _type2.excluded = excl == null ? [_type2] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n    this.nodeFromJSON = this.nodeFromJSON.bind(this);\n    this.markFromJSON = this.markFromJSON.bind(this);\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = Object.create(null);\n  }\n  /**\n  Create a node in this schema. The `type` may be a string or a\n  `NodeType` instance. Attributes will be extended with defaults,\n  `content` may be a `Fragment`, `null`, a `Node`, or an array of\n  nodes.\n  */\n  return _createClass(Schema, [{\n    key: \"node\",\n    value: function node(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      if (typeof type == \"string\") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n  }, {\n    key: \"text\",\n    value: function text(_text, marks) {\n      var type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n  }, {\n    key: \"mark\",\n    value: function mark(type, attrs) {\n      if (typeof type == \"string\") type = this.marks[type];\n      return type.create(attrs);\n    }\n    /**\n    Deserialize a node from its JSON representation. This method is\n    bound.\n    */\n  }, {\n    key: \"nodeFromJSON\",\n    value: function nodeFromJSON(json) {\n      return Node.fromJSON(this, json);\n    }\n    /**\n    Deserialize a mark from its JSON representation. This method is\n    bound.\n    */\n  }, {\n    key: \"markFromJSON\",\n    value: function markFromJSON(json) {\n      return Mark.fromJSON(this, json);\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"nodeType\",\n    value: function nodeType(name) {\n      var found = this.nodes[name];\n      if (!found) throw new RangeError(\"Unknown node type: \" + name);\n      return found;\n    }\n  }]);\n}();\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n      mark = schema.marks[name],\n      ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var _mark = schema.marks[prop];\n        if (name == \"_\" || _mark.spec.group && _mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = _mark);\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found;\n}\nfunction isTagRule(rule) {\n  return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n  return rule.style != null;\n}\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/\nvar DOMParser = /*#__PURE__*/function () {\n  /**\n  Create a parser that targets the given schema, using the given\n  parsing rules.\n  */\n  function DOMParser(\n  /**\n  The schema into which the parser parses.\n  */\n  schema,\n  /**\n  The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n  uses, in order of precedence.\n  */\n  rules) {\n    var _this3 = this;\n    _classCallCheck(this, DOMParser);\n    this.schema = schema;\n    this.rules = rules;\n    /**\n    @internal\n    */\n    this.tags = [];\n    /**\n    @internal\n    */\n    this.styles = [];\n    var matchedStyles = this.matchedStyles = [];\n    rules.forEach(function (rule) {\n      if (isTagRule(rule)) {\n        _this3.tags.push(rule);\n      } else if (isStyleRule(rule)) {\n        var prop = /[^=]*/.exec(rule.style)[0];\n        if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);\n        _this3.styles.push(rule);\n      }\n    });\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(function (r) {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n      var node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n  /**\n  Parse a document from the content of a DOM node.\n  */\n  return _createClass(DOMParser, [{\n    key: \"parse\",\n    value: function parse(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, false);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n  }, {\n    key: \"parseSlice\",\n    value: function parseSlice(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, true);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"matchTag\",\n    value: function matchTag(dom, context, after) {\n      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        var rule = this.tags[i];\n        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            var result = rule.getAttrs(dom);\n            if (result === false) continue;\n            rule.attrs = result || undefined;\n          }\n          return rule;\n        }\n      }\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"matchStyle\",\n    value: function matchStyle(prop, value, context, after) {\n      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        var rule = this.styles[i],\n          style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n        if (rule.getAttrs) {\n          var result = rule.getAttrs(value);\n          if (result === false) continue;\n          rule.attrs = result || undefined;\n        }\n        return rule;\n      }\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"schemaRules\",\n    value: function schemaRules(schema) {\n      var result = [];\n      function insert(rule) {\n        var priority = rule.priority == null ? 50 : rule.priority,\n          i = 0;\n        for (; i < result.length; i++) {\n          var next = result[i],\n            nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority) break;\n        }\n        result.splice(i, 0, rule);\n      }\n      var _loop2 = function _loop2(name) {\n        var rules = schema.marks[name].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n        });\n      };\n      for (var name in schema.marks) {\n        _loop2(name);\n      }\n      var _loop3 = function _loop3(_name3) {\n        var rules = schema.nodes[_name3].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name3;\n        });\n      };\n      for (var _name3 in schema.nodes) {\n        _loop3(_name3);\n      }\n      return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).\n    */\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n  }]);\n}();\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nvar listTags = {\n  ol: true,\n  ul: true\n};\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1,\n  OPT_PRESERVE_WS_FULL = 2,\n  OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nvar NodeContext = /*#__PURE__*/function () {\n  function NodeContext(type, attrs, marks, solid, match, options) {\n    _classCallCheck(this, NodeContext);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    // Marks applied to the node's children\n    this.activeMarks = Mark.none;\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n  return _createClass(NodeContext, [{\n    key: \"findWrapping\",\n    value: function findWrapping(node) {\n      if (!this.match) {\n        if (!this.type) return [];\n        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          var start = this.type.contentMatch,\n            wrap;\n          if (wrap = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap;\n          } else {\n            return null;\n          }\n        }\n      }\n      return this.match.findWrapping(node.type);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        // Strip trailing whitespace\n        var last = this.content[this.content.length - 1],\n          m;\n        if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n          var text = last;\n          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n        }\n      }\n      var content = Fragment.from(this.content);\n      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n  }, {\n    key: \"inlineContext\",\n    value: function inlineContext(node) {\n      if (this.type) return this.type.inlineContent;\n      if (this.content.length) return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  }]);\n}();\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext(\n  // The parser we are using.\n  parser,\n  // The options passed to this parse.\n  options, isOpen) {\n    _classCallCheck(this, ParseContext);\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    this.localPreserveWS = false;\n    var topNode = options.topNode,\n      topContext;\n    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n  return _createClass(ParseContext, [{\n    key: \"top\",\n    get: function get() {\n      return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n  }, {\n    key: \"addDOM\",\n    value: function addDOM(dom, marks) {\n      if (dom.nodeType == 3) this.addTextNode(dom, marks);else if (dom.nodeType == 1) this.addElement(dom, marks);\n    }\n  }, {\n    key: \"addTextNode\",\n    value: function addTextNode(dom, marks) {\n      var value = dom.nodeValue;\n      var top = this.top,\n        preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n      if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!preserveWS) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n          // If this starts with whitespace, and there is no node before it, or\n          // a hard break, or a text node that ends with whitespace, strip the\n          // leading space.\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            var nodeBefore = top.content[top.content.length - 1];\n            var domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n          }\n        } else if (preserveWS !== \"full\") {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n        if (value) this.insertNode(this.parser.schema.text(value), marks);\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n  }, {\n    key: \"addElement\",\n    value: function addElement(dom, marks, matchAfter) {\n      var outerWS = this.localPreserveWS,\n        top = this.top;\n      if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;\n      var name = dom.nodeName.toLowerCase(),\n        ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;\n        var sync,\n          oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type) this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks);\n          break out;\n        }\n        var innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n        if (innerMarks) this.addAll(dom, innerMarks);\n        if (sync) this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        var _innerMarks = this.readStyles(dom, marks);\n        if (_innerMarks) this.addElementByRule(dom, rule, _innerMarks, rule.consuming === false ? ruleID : undefined);\n      }\n      this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n  }, {\n    key: \"leafFallback\",\n    value: function leafFallback(dom, marks) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n    // Called for ignored nodes\n  }, {\n    key: \"ignoreFallback\",\n    value: function ignoreFallback(dom, marks) {\n      // Ignored BR nodes should at least create an inline context\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"), marks);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n  }, {\n    key: \"readStyles\",\n    value: function readStyles(dom, marks) {\n      var _this4 = this;\n      var styles = dom.style;\n      // Because many properties will only show up in 'normalized' form\n      // in `style.item` (i.e. text-decoration becomes\n      // text-decoration-line, text-decoration-color, etc), we directly\n      // query the styles mentioned in our rules instead of iterating\n      // over the items.\n      if (styles && styles.length) for (var i = 0; i < this.parser.matchedStyles.length; i++) {\n        var name = this.parser.matchedStyles[i],\n          value = styles.getPropertyValue(name);\n        if (value) {\n          var _loop4 = function _loop4(_after) {\n              var rule = _this4.parser.matchStyle(name, value, _this4, _after);\n              if (!rule) {\n                after = _after;\n                return 0;\n              } // break\n              if (rule.ignore) return {\n                v: null\n              };\n              if (rule.clearMark) marks = marks.filter(function (m) {\n                return !rule.clearMark(m);\n              });else marks = marks.concat(_this4.parser.schema.marks[rule.mark].create(rule.attrs));\n              if (rule.consuming === false) _after = rule;else {\n                after = _after;\n                return 0;\n              } // break\n              after = _after;\n            },\n            _ret;\n          for (var after = undefined;;) {\n            _ret = _loop4(after);\n            if (_ret === 0) break;\n            if (_ret) return _ret.v;\n          }\n        }\n      }\n      return marks;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n  }, {\n    key: \"addElementByRule\",\n    value: function addElementByRule(dom, rule, marks, continueAfter) {\n      var _this5 = this;\n      var sync, nodeType;\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n        if (!nodeType.isLeaf) {\n          var inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n          if (inner) {\n            sync = true;\n            marks = inner;\n          }\n        } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {\n          this.leafFallback(dom, marks);\n        }\n      } else {\n        var markType = this.parser.schema.marks[rule.mark];\n        marks = marks.concat(markType.create(rule.attrs));\n      }\n      var startIn = this.top;\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, marks, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach(function (node) {\n          return _this5.insertNode(node, marks);\n        });\n      } else {\n        var contentDOM = dom;\n        if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM, marks);\n        this.findAround(dom, contentDOM, false);\n      }\n      if (sync && this.sync(startIn)) this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n  }, {\n    key: \"addAll\",\n    value: function addAll(parent, marks, startIndex, endIndex) {\n      var index = startIndex || 0;\n      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom, marks);\n      }\n      this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n  }, {\n    key: \"findPlace\",\n    value: function findPlace(node, marks) {\n      var route, sync;\n      for (var depth = this.open; depth >= 0; depth--) {\n        var cx = this.nodes[depth];\n        var _found2 = cx.findWrapping(node);\n        if (_found2 && (!route || route.length > _found2.length)) {\n          route = _found2;\n          sync = cx;\n          if (!_found2.length) break;\n        }\n        if (cx.solid) break;\n      }\n      if (!route) return null;\n      this.sync(sync);\n      for (var i = 0; i < route.length; i++) marks = this.enterInner(route[i], null, marks, false);\n      return marks;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node, marks) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        var block = this.textblockFromContext();\n        if (block) marks = this.enterInner(block, null, marks);\n      }\n      var innerMarks = this.findPlace(node, marks);\n      if (innerMarks) {\n        this.closeExtra();\n        var top = this.top;\n        if (top.match) top.match = top.match.matchType(node.type);\n        var nodeMarks = Mark.none;\n        var _iterator = _createForOfIteratorHelper(innerMarks.concat(node.marks)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var m = _step.value;\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        top.content.push(node.mark(nodeMarks));\n        return true;\n      }\n      return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n  }, {\n    key: \"enter\",\n    value: function enter(type, attrs, marks, preserveWS) {\n      var innerMarks = this.findPlace(type.create(attrs), marks);\n      if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n      return innerMarks;\n    }\n    // Open a node of the given type\n  }, {\n    key: \"enterInner\",\n    value: function enterInner(type, attrs, marks) {\n      var solid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var preserveWS = arguments.length > 4 ? arguments[4] : undefined;\n      this.closeExtra();\n      var top = this.top;\n      top.match = top.match && top.match.matchType(type);\n      var options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n      var applyMarks = Mark.none;\n      marks = marks.filter(function (m) {\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n          applyMarks = m.addToSet(applyMarks);\n          return false;\n        }\n        return true;\n      });\n      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n      this.open++;\n      return marks;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n  }, {\n    key: \"closeExtra\",\n    value: function closeExtra() {\n      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var i = this.nodes.length - 1;\n      if (i > this.open) {\n        for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        this.nodes.length = this.open + 1;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(to) {\n      for (var i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        } else if (this.localPreserveWS) {\n          this.nodes[i].options |= OPT_PRESERVE_WS;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"currentPos\",\n    get: function get() {\n      this.closeExtra();\n      var pos = 0;\n      for (var i = this.open; i >= 0; i--) {\n        var content = this.nodes[i].content;\n        for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;\n        if (i) pos++;\n      }\n      return pos;\n    }\n  }, {\n    key: \"findAtPoint\",\n    value: function findAtPoint(parent, offset) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findInside\",\n    value: function findInside(parent) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findAround\",\n    value: function findAround(parent, content, before) {\n      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          var pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }, {\n    key: \"findInText\",\n    value: function findInText(textNode) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n    // Determines whether the given context string matches this context.\n  }, {\n    key: \"matchesContext\",\n    value: function matchesContext(context) {\n      var _this6 = this;\n      if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      var parts = context.split(\"/\");\n      var option = this.options.context;\n      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n      var _match = function match(i, depth) {\n        for (; i >= 0; i--) {\n          var part = parts[i];\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0) continue;\n            for (; depth >= minDepth; depth--) if (_match(i - 1, depth)) return true;\n            return false;\n          } else {\n            var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && !next.isInGroup(part)) return false;\n            depth--;\n          }\n        }\n        return true;\n      };\n      return _match(parts.length - 1, this.open);\n    }\n  }, {\n    key: \"textblockFromContext\",\n    value: function textblockFromContext() {\n      var $context = this.options.context;\n      if ($context) for (var d = $context.depth; d >= 0; d--) {\n        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n      }\n      for (var name in this.parser.schema.nodes) {\n        var type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs) return type;\n      }\n    }\n  }]);\n}(); // Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var _loop5 = function _loop5() {\n      var parent = nodes[name];\n      if (!parent.allowsMarkType(markType)) return 0; // continue\n      var seen = [],\n        _scan = function scan(match) {\n          seen.push(match);\n          for (var i = 0; i < match.edgeCount; i++) {\n            var _match$edge = match.edge(i),\n              type = _match$edge.type,\n              next = _match$edge.next;\n            if (type == nodeType) return true;\n            if (seen.indexOf(next) < 0 && _scan(next)) return true;\n          }\n        };\n      if (_scan(parent.contentMatch)) return {\n        v: true\n      };\n    },\n    _ret2;\n  for (var name in nodes) {\n    _ret2 = _loop5();\n    if (_ret2 === 0) continue;\n    if (_ret2) return _ret2.v;\n  }\n}\n\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/\nvar DOMSerializer = /*#__PURE__*/function () {\n  /**\n  Create a serializer. `nodes` should map node names to functions\n  that take a node and return a description of the corresponding\n  DOM. `marks` does the same for mark names, but also gets an\n  argument that tells it whether the mark's content is block or\n  inline content (for typical use, it'll always be inline). A mark\n  serializer may be `null` to indicate that marks of that type\n  should not be serialized.\n  */\n  function DOMSerializer(\n  /**\n  The node serialization functions.\n  */\n  nodes,\n  /**\n  The mark serialization functions.\n  */\n  marks) {\n    _classCallCheck(this, DOMSerializer);\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n  /**\n  Serialize the content of this fragment to a DOM fragment. When\n  not in the browser, the `document` option, containing a DOM\n  document, should be passed so that the serializer can create\n  nodes.\n  */\n  return _createClass(DOMSerializer, [{\n    key: \"serializeFragment\",\n    value: function serializeFragment(fragment) {\n      var _this7 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = arguments.length > 2 ? arguments[2] : undefined;\n      if (!target) target = doc(options).createDocumentFragment();\n      var top = target,\n        active = [];\n      fragment.forEach(function (node) {\n        if (active.length || node.marks.length) {\n          var keep = 0,\n            rendered = 0;\n          while (keep < active.length && rendered < node.marks.length) {\n            var next = node.marks[rendered];\n            if (!_this7.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n            keep++;\n            rendered++;\n          }\n          while (keep < active.length) top = active.pop()[1];\n          while (rendered < node.marks.length) {\n            var add = node.marks[rendered++];\n            var markDOM = _this7.serializeMark(add, node.isInline, options);\n            if (markDOM) {\n              active.push([add, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n        top.appendChild(_this7.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"serializeNodeInner\",\n    value: function serializeNodeInner(node, options) {\n      var _renderSpec2 = _renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs),\n        dom = _renderSpec2.dom,\n        contentDOM = _renderSpec2.contentDOM;\n      if (contentDOM) {\n        if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n      return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n  }, {\n    key: \"serializeNode\",\n    value: function serializeNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dom = this.serializeNodeInner(node, options);\n      for (var i = node.marks.length - 1; i >= 0; i--) {\n        var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n        if (wrap) {\n          (wrap.contentDOM || wrap.dom).appendChild(dom);\n          dom = wrap.dom;\n        }\n      }\n      return dom;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"serializeMark\",\n    value: function serializeMark(mark, inline) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var toDOM = this.marks[mark.type.name];\n      return toDOM && _renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n  }], [{\n    key: \"renderSpec\",\n    value: function renderSpec(doc, structure) {\n      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var blockArraysIn = arguments.length > 3 ? arguments[3] : undefined;\n      return _renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n  }, {\n    key: \"nodesFromSchema\",\n    value: function nodesFromSchema(schema) {\n      var result = gatherToDOM(schema.nodes);\n      if (!result.text) result.text = function (node) {\n        return node.text;\n      };\n      return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */\n  }, {\n    key: \"marksFromSchema\",\n    value: function marksFromSchema(schema) {\n      return gatherToDOM(schema.marks);\n    }\n  }]);\n}();\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) result[name] = toDOM;\n  }\n  return result;\n}\nfunction doc(options) {\n  return options.document || window.document;\n}\nvar suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n  var value = suspiciousAttributeCache.get(attrs);\n  if (value === undefined) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n  return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n  var result = null;\n  function scan(value) {\n    if (value && _typeof(value) == \"object\") {\n      if (Array.isArray(value)) {\n        if (typeof value[0] == \"string\") {\n          if (!result) result = [];\n          result.push(value);\n        } else {\n          for (var i = 0; i < value.length; i++) scan(value[i]);\n        }\n      } else {\n        for (var prop in value) scan(value[prop]);\n      }\n    }\n  }\n  scan(attrs);\n  return result;\n}\nfunction _renderSpec(doc, structure, xmlNS, blockArraysIn) {\n  if (typeof structure == \"string\") return {\n    dom: doc.createTextNode(structure)\n  };\n  if (structure.nodeType != null) return {\n    dom: structure\n  };\n  if (structure.dom && structure.dom.nodeType != null) return structure;\n  var tagName = structure[0],\n    suspicious;\n  if (typeof tagName != \"string\") throw new RangeError(\"Invalid array passed to renderSpec\");\n  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n  var space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM;\n  var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1],\n    start = 1;\n  if (attrs && _typeof(attrs) == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) if (attrs[name] != null) {\n      var _space = name.indexOf(\" \");\n      if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);\n    }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n      return {\n        dom: dom,\n        contentDOM: dom\n      };\n    } else {\n      var _renderSpec3 = _renderSpec(doc, child, xmlNS, blockArraysIn),\n        inner = _renderSpec3.dom,\n        innerContent = _renderSpec3.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) throw new RangeError(\"Multiple content holes\");\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {\n    dom: dom,\n    contentDOM: contentDOM\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFFcEMsU0FBU0MsY0FBYUEsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUcsRUFBRTtFQUM5QixLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEdBQUdBLENBQUMsRUFBRSxFQUFFO0lBQ2xCLElBQUlBLENBQUMsSUFBSUgsQ0FBQyxDQUFDSSxVQUFVLElBQUlELENBQUMsSUFBSUYsQ0FBQyxDQUFDRyxVQUFVLEVBQ3RDLE9BQU9KLENBQUMsQ0FBQ0ksVUFBVSxJQUFJSCxDQUFDLENBQUNHLFVBQVUsR0FBRyxJQUFJLEdBQUdGLEdBQUc7SUFDcEQsSUFBSUcsTUFBTSxHQUFHTCxDQUFDLENBQUNNLEtBQUssQ0FBQ0gsQ0FBQyxDQUFDO01BQUVJLE1BQU0sR0FBR04sQ0FBQyxDQUFDSyxLQUFLLENBQUNILENBQUMsQ0FBQztJQUM1QyxJQUFJRSxNQUFNLElBQUlFLE1BQU0sRUFBRTtNQUNsQkwsR0FBRyxJQUFJRyxNQUFNLENBQUNHLFFBQVE7TUFDdEI7SUFDSjtJQUNBLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxVQUFVLENBQUNGLE1BQU0sQ0FBQyxFQUMxQixPQUFPTCxHQUFHO0lBQ2QsSUFBSUcsTUFBTSxDQUFDSyxNQUFNLElBQUlMLE1BQU0sQ0FBQ00sSUFBSSxJQUFJSixNQUFNLENBQUNJLElBQUksRUFBRTtNQUM3QyxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVQLE1BQU0sQ0FBQ00sSUFBSSxDQUFDQyxDQUFDLENBQUMsSUFBSUwsTUFBTSxDQUFDSSxJQUFJLENBQUNDLENBQUMsQ0FBQyxFQUFFQSxDQUFDLEVBQUUsRUFDakRWLEdBQUcsRUFBRTtNQUNULE9BQU9BLEdBQUc7SUFDZDtJQUNBLElBQUlHLE1BQU0sQ0FB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QUFLLEdBQUE0a0IsWUFBQSxDQUFWbE4sR0FBRztRQUFxQm1OLFlBQVksR0FBQUQsWUFBQSxDQUF4Qi9FLFVBQVU7TUFDNUJuSSxHQUFHLENBQUN3SyxXQUFXLENBQUNsaUIsS0FBSyxDQUFDO01BQ3RCLElBQUk2a0IsWUFBWSxFQUFFO1FBQ2QsSUFBSWhGLFVBQVUsRUFDVixNQUFNLElBQUloYyxVQUFVLENBQUMsd0JBQXdCLENBQUM7UUFDbERnYyxVQUFVLEdBQUdnRixZQUFZO01BQzdCO0lBQ0o7RUFDSjtFQUNBLE9BQU87SUFBRW5OLEdBQUcsRUFBSEEsR0FBRztJQUFFbUksVUFBVSxFQUFWQTtFQUFXLENBQUM7QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaW5zdGluY3RodWJcXGNvZGVfcHJvamVjdHNcXG5wbVxcaW5zdGluY3RodWItcmVhY3QtdWlcXG5vZGVfbW9kdWxlc1xccHJvc2VtaXJyb3ItbW9kZWxcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gICAgZm9yIChsZXQgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICAgICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgc2FtZSA9IDAsIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICAgICAgICAgIHNhbWUrKztcbiAgICAgICAgICAgICAgICBwb3NBLS07XG4gICAgICAgICAgICAgICAgcG9zQi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgfVxufVxuXG4vKipcbkEgZnJhZ21lbnQgcmVwcmVzZW50cyBhIG5vZGUncyBjb2xsZWN0aW9uIG9mIGNoaWxkIG5vZGVzLlxuXG5MaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG5zaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbmluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG4qL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBzaXplKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuICAgIHBvc2l0aW9ucyAocmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBmcmFnbWVudCkuIERvZXNuJ3QgZGVzY2VuZFxuICAgIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgbm9kZVN0YXJ0ID0gMCwgcGFyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQgfHwgbnVsbCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIGZyb20gLSBzdGFydCksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBgcG9zYCB3aWxsIGJlXG4gICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC4gVGhlIGNhbGxiYWNrIG1heSByZXR1cm5cbiAgICBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4gICAgW2BOb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlVGV4dCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKVxuICAgICAgICAgICAgICAgIDogIW5vZGUuaXNMZWFmID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICA6IGxlYWZUZXh0ID8gKHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZS50eXBlLnNwZWMubGVhZlRleHQgPyBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgKG5vZGUuaXNMZWFmICYmIG5vZGVUZXh0IHx8IG5vZGUuaXNUZXh0YmxvY2spICYmIGJsb2NrU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gbm9kZVRleHQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgb3RoZXIuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlci5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdENoaWxkLCBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSwgaSA9IDA7XG4gICAgICAgIGlmIChsYXN0LmlzVGV4dCAmJiBsYXN0LnNhbWVNYXJrdXAoZmlyc3QpKSB7XG4gICAgICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29udGVudC5wdXNoKG90aGVyLmNvbnRlbnRbaV0pO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluIHdoaWNoIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpc1xuICAgIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29weSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9FbmQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgZnJhZ21lbnQgdG8gYW5vdGhlciBvbmUuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggdGhpcyBmcmFnbWVudCBhbmQgYW5vdGhlclxuICAgIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuICAgICovXG4gICAgZmluZERpZmZTdGFydChvdGhlciwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24sIHNlYXJjaGluZyBmcm9tIHRoZSBlbmQsIGF0IHdoaWNoIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlXG4gICAgdGhlIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aFxuICAgIG5vZGVzLCBhbiBvYmplY3Qgd2l0aCB0d28gc2VwYXJhdGUgcG9zaXRpb25zIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZmluZERpZmZFbmQob3RoZXIsIHBvcyA9IHRoaXMuc2l6ZSwgb3RoZXJQb3MgPSBvdGhlci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4gICAgcG9zaXRpb24gaW4gdGhpcyBmcmFnbWVudC4gVGhlIHJlc3VsdCBvYmplY3Qgd2lsbCBiZSByZXVzZWRcbiAgICAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kSW5kZXgocG9zLCByb3VuZCA9IC0xKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCgwLCBwb3MpO1xuICAgICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpO1xuICAgICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IG91dHNpZGUgb2YgZnJhZ21lbnQgKCR7dGhpc30pYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXJQb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZChpKSwgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID09IHBvcyB8fCByb3VuZCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpICsgMSwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSwgY3VyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBkZWJ1Z2dpbmcgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIFwiPFwiICsgdGhpcy50b1N0cmluZ0lubmVyKCkgKyBcIj5cIjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmdJbm5lcigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIik7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKG4gPT4gbi50b0pTT04oKSkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIGZyYWdtZW50IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBGcmFnbWVudC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIGZyYWdtZW50IGZyb20gYW4gYXJyYXkgb2Ygbm9kZXMuIEVuc3VyZXMgdGhhdCBhZGphY2VudFxuICAgIHRleHQgbm9kZXMgd2l0aCB0aGUgc2FtZSBtYXJrcyBhcmUgam9pbmVkIHRvZ2V0aGVyLlxuICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICBpZiAoIWFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgbGV0IGpvaW5lZCwgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gYXJyYXlbaV07XG4gICAgICAgICAgICBzaXplICs9IG5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmVkKVxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoam9pbmVkIHx8IGFycmF5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICAgIHNldCBvZiBub2Rlcy4gRm9yIGBudWxsYCwgaXQgcmV0dXJucyB0aGUgZW1wdHkgZnJhZ21lbnQuIEZvciBhXG4gICAgZnJhZ21lbnQsIHRoZSBmcmFnbWVudCBpdHNlbGYuIEZvciBhIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMsIGFcbiAgICBmcmFnbWVudCBjb250YWluaW5nIHRob3NlIG5vZGVzLlxuICAgICovXG4gICAgc3RhdGljIGZyb20obm9kZXMpIHtcbiAgICAgICAgaWYgKCFub2RlcylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShub2Rlcyk7XG4gICAgICAgIGlmIChub2Rlcy5hdHRycylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVzXSwgbm9kZXMubm9kZVNpemUpO1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICtcbiAgICAgICAgICAgIChub2Rlcy5ub2Rlc0JldHdlZW4gPyBcIiAobG9va3MgbGlrZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBwcm9zZW1pcnJvci1tb2RlbCB3ZXJlIGxvYWRlZClcIiA6IFwiXCIpKTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGZyYWdtZW50LiBJbnRlbmRlZCB0byBiZSByZXVzZWQgd2hlbmV2ZXIgYSBub2RlIGRvZXNuJ3RcbmNvbnRhaW4gYW55dGhpbmcgKHJhdGhlciB0aGFuIGFsbG9jYXRpbmcgYSBuZXcgZW1wdHkgZnJhZ21lbnQgZm9yXG5lYWNoIGxlYWYgbm9kZSkuXG4qL1xuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xuY29uc3QgZm91bmQgPSB7IGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbmZ1bmN0aW9uIHJldEluZGV4KGluZGV4LCBvZmZzZXQpIHtcbiAgICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICAgIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEZWVwKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiKSB8fFxuICAgICAgICAhKGIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFjb21wYXJlRGVlcChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgICAgICBpZiAoIShwIGluIGIpIHx8ICFjb21wYXJlRGVlcChhW3BdLCBiW3BdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5BIG1hcmsgaXMgYSBwaWVjZSBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGUsXG5zdWNoIGFzIGl0IGJlaW5nIGVtcGhhc2l6ZWQsIGluIGNvZGUgZm9udCwgb3IgYSBsaW5rLiBJdCBoYXMgYVxudHlwZSBhbmQgb3B0aW9uYWxseSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgcHJvdmlkZSBmdXJ0aGVyXG5pbmZvcm1hdGlvbiAoc3VjaCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rKS4gTWFya3MgYXJlIGNyZWF0ZWRcbnRocm91Z2ggYSBgU2NoZW1hYCwgd2hpY2ggY29udHJvbHMgd2hpY2ggdHlwZXMgZXhpc3QgYW5kIHdoaWNoXG5hdHRyaWJ1dGVzIHRoZXkgaGF2ZS5cbiovXG5jbGFzcyBNYXJrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICBhdHRycykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgc2V0IG9mIG1hcmtzLCBjcmVhdGUgYSBuZXcgc2V0IHdoaWNoIGNvbnRhaW5zIHRoaXMgb25lIGFzXG4gICAgd2VsbCwgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLiBJZiB0aGlzIG1hcmsgaXMgYWxyZWFkeSBpbiB0aGUgc2V0LFxuICAgIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLiBJZiBhbnkgbWFya3MgdGhhdCBhcmUgc2V0IHRvIGJlXG4gICAgW2V4Y2x1c2l2ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSB3aXRoIHRoaXMgbWFyayBhcmUgcHJlc2VudCxcbiAgICB0aG9zZSBhcmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGNvcHksIHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG90aGVyID0gc2V0W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgpO1xuICAgICAgICBpZiAoIXBsYWNlZClcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSB0aGlzIG1hcmsgZnJvbSB0aGUgZ2l2ZW4gc2V0LCByZXR1cm5pbmcgYSBuZXcgc2V0LiBJZiB0aGlzXG4gICAgbWFyayBpcyBub3QgaW4gdGhlIHNldCwgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaXMgaW4gdGhlIGdpdmVuIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGhhcyB0aGUgc2FtZSB0eXBlIGFuZCBhdHRyaWJ1dGVzIGFzXG4gICAgYW5vdGhlciBtYXJrLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgbWFyayB0byBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gSlNPTi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBNYXJrLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlICR7anNvbi50eXBlfSBpbiB0aGlzIHNjaGVtYWApO1xuICAgICAgICBsZXQgbWFyayA9IHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgICAgICB0eXBlLmNoZWNrQXR0cnMobWFyay5hdHRycyk7XG4gICAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbiAgICAqL1xuICAgIHN0YXRpYyBzYW1lU2V0KGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT0gYilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuICAgIHVuc29ydGVkIGFycmF5IG9mIG1hcmtzLlxuICAgICovXG4gICAgc3RhdGljIHNldEZyb20obWFya3MpIHtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspXG4gICAgICAgICAgICByZXR1cm4gW21hcmtzXTtcbiAgICAgICAgbGV0IGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgICBjb3B5LnNvcnQoKGEsIGIpID0+IGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbmspO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG4qL1xuTWFyay5ub25lID0gW107XG5cbi8qKlxuRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG5naXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qXG5SZXBsYWNlRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKVxuICA7KGVyciBhcyBhbnkpLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGVcbiAgcmV0dXJuIGVyclxufSBhcyBhbnlcblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvclxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJSZXBsYWNlRXJyb3JcIlxuKi9cbi8qKlxuQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbnN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbmJvdGggc2lkZSBhcmUg4oCYb3BlbuKAmSAoY3V0IHRocm91Z2gpLlxuKi9cbmNsYXNzIFNsaWNlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZS4gV2hlbiBzcGVjaWZ5aW5nIGEgbm9uLXplcm8gb3BlbiBkZXB0aCwgeW91IG11c3RcbiAgICBtYWtlIHN1cmUgdGhhdCB0aGVyZSBhcmUgbm9kZXMgb2YgYXQgbGVhc3QgdGhhdCBkZXB0aCBhdCB0aGVcbiAgICBhcHByb3ByaWF0ZSBzaWRlIG9mIHRoZSBmcmFnbWVudOKAlGkuZS4gaWYgdGhlIGZyYWdtZW50IGlzIGFuXG4gICAgZW1wdHkgcGFyYWdyYXBoIG5vZGUsIGBvcGVuU3RhcnRgIGFuZCBgb3BlbkVuZGAgY2FuJ3QgYmUgZ3JlYXRlclxuICAgIHRoYW4gMS5cbiAgICBcbiAgICBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBvZiBvcGVuIG5vZGVzIHRvIGNvbmZvcm0gdG9cbiAgICB0aGUgc2NoZW1hJ3MgY29udGVudCBjb25zdHJhaW50cywgdGhvdWdoIGl0IHNob3VsZCBiZSBhIHZhbGlkXG4gICAgc3RhcnQvZW5kL21pZGRsZSBmb3Igc3VjaCBhIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlcyBhcmVcbiAgICBvcGVuLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBvcGVuU3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBvcGVuRW5kKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSB0aGlzIHNsaWNlIHdvdWxkIGFkZCB3aGVuIGluc2VydGVkIGludG8gYSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGlzIHNsaWNlIGlzIGVxdWFsIHRvIGFub3RoZXIgc2xpY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbiA9IHsgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5vcGVuRW5kID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCwgb3BlbkVuZCA9IGpzb24ub3BlbkVuZCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNsaWNlLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UgZnJvbSBhIGZyYWdtZW50IGJ5IHRha2luZyB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAgIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXhPcGVuKGZyYWdtZW50LCBvcGVuSXNvbGF0aW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQubGFzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4ubGFzdENoaWxkKVxuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNsaWNlLlxuKi9cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBsZXQgeyBpbmRleDogaW5kZXhUbywgb2Zmc2V0OiBvZmZzZXRUbyB9ID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICAgIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGluZGV4VG8pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2UoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgICBsZXQgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7IC8vIFNpbXBsZSwgZmxhdCBjYXNlXG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gICAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgICBsZXQgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gICAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgICBsZXQgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSlcbiAgICAgICAgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICBlbHNlXG4gICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICAgIGxldCBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICAgIGlmICgkc3RhcnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRzdGFydC50ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGROb2RlKCRzdGFydC5ub2RlQWZ0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gICAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpXG4gICAgICAgIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICAgIG5vZGUudHlwZS5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgICBsZXQgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICAgICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlblN0YXJ0KVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgICAgICBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKG9wZW5FbmQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgIGxldCB0eXBlID0gam9pbmFibGUoJGZyb20sICR0bywgZGVwdGggKyAxKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICAgIGxldCBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICAgIGxldCBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gICAgZm9yIChsZXQgaSA9IGV4dHJhIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKSB9O1xufVxuXG4vKipcbllvdSBjYW4gW19yZXNvbHZlX10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG5yZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHRcbmluZm9ybWF0aW9uLCBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cblxuVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxucGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG5udW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxuKi9cbmNsYXNzIFJlc29sdmVkUG9zIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXRoLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcGFyZW50T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgICAgaWYgKHZhbCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuICAgIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuICAgIHRoZSBwYXJlbnTigJR0ZXh0IG5vZGVzIGFyZSDigJhmbGF04oCZIGluIHRoaXMgbW9kZWwsIGFuZCBoYXZlIG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgZ2V0IGRvYygpIHsgcmV0dXJuIHRoaXMubm9kZSgwKTsgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4gICAgc2FtZSBhcyBgcC5wYXJlbnRgLlxuICAgICovXG4gICAgbm9kZShkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHNcbiAgICBhdCB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yXG4gICAgZXhhbXBsZSwgYHAuaW5kZXgoMClgIGlzIDEgYW5kIGBwLmluZGV4KDEpYCBpcyAyLlxuICAgICovXG4gICAgaW5kZXgoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggcG9pbnRpbmcgYWZ0ZXIgdGhpcyBwb3NpdGlvbiBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbC5cbiAgICAqL1xuICAgIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIHN0YXJ0KGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgZW5kKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYmVmb3JlIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgYmVmb3JlKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cbiAgICAqL1xuICAgIGFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuICAgIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvc2l0aW9uIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgdGV4dE9mZnNldCgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4gICAgcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVBZnRlcigpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuICAgIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuICAgIGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUJlZm9yZSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkT2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cbiAgICAqL1xuICAgIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgIHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbiAgICBtYXJrcycgW2BpbmNsdXNpdmVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuaW5jbHVzaXZlKSBwcm9wZXJ0eS4gSWYgdGhlXG4gICAgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbiAgICBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cbiAgICAqL1xuICAgIG1hcmtzKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgICBsZXQgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgYGFmdGVyYCBmbGFnIGlzIHRydWUgb2YgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUsIG1ha2VcbiAgICAgICAgLy8gdGhlIG5vZGUgYWZ0ZXIgdGhpcyBwb3NpdGlvbiB0aGUgbWFpbiByZWZlcmVuY2UuXG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbGV0IHRtcCA9IG1haW47XG4gICAgICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgICAgICAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gICAgICAgIGxldCBtYXJrcyA9IG1haW4ubWFya3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBpZiBhbnksIGV4Y2VwdCB0aG9zZVxuICAgIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuICAgIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4gICAgZGVsZXRpb24uIFdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuICAgIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG4gICAgKi9cbiAgICBtYXJrc0Fjcm9zcygkZW5kKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1hcmtzID0gYWZ0ZXIubWFya3MsIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuICAgIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cbiAgICAqL1xuICAgIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmFuZ2UgYmFzZWQgb24gdGhlIHBsYWNlIHdoZXJlIHRoaXMgcG9zaXRpb24gYW5kIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuICAgIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4gICAgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhleSBwb2ludCBpbnRvIGRpZmZlcmVudCBibG9ja3MsIHRoZSByYW5nZVxuICAgIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4gICAgcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4gICAgbm9kZSB0byBzZWUgaWYgYSByYW5nZSBpbnRvIHRoYXQgcGFyZW50IGlzIGFjY2VwdGFibGUuXG4gICAgKi9cbiAgICBibG9ja1JhbmdlKG90aGVyID0gdGhpcywgcHJlZCkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgICAgICAgICAgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBzYW1lUGFyZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1heChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICAgIHJldHVybiBzdHIgKyBcIjpcIiArIHRoaXMucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIXJlbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHJlc29sdmVDYWNoZS5nZXQoZG9jKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmVsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZWx0ID0gY2FjaGUuZWx0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWx0LnBvcyA9PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlQ2FjaGUuc2V0KGRvYywgY2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gY2FjaGUuZWx0c1tjYWNoZS5pXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICBjYWNoZS5pID0gKGNhY2hlLmkgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuY2xhc3MgUmVzb2x2ZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbHRzID0gW107XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfVxufVxuY29uc3QgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyLCByZXNvbHZlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBBbiBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLiBUaGUga2luZCBvZlxuICAgIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gICAgW2RldGVybWluZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGF0dHJzLCBcbiAgICAvLyBBIGZyYWdtZW50IGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgbWFya3MgKHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQgaXMgZW1waGFzaXplZCBvciBwYXJ0IG9mIGFcbiAgICBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIG1hcmtzID0gTWFyay5ub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYXJyYXkgb2YgdGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY29udGVudDsgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIG9mIHRoaXMgbm9kZSwgYXMgZGVmaW5lZCBieSB0aGUgaW50ZWdlci1iYXNlZCBbaW5kZXhpbmdcbiAgICBzY2hlbWVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWNebGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGVuIHRoZXkgZG8gbm90LlxuICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIHRoaXMudHlwZS5jaGVja0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gdGhpcy5tYXJrc1tpXTtcbiAgICAgICAgICAgIG1hcmsudHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgICAgICAgY29weSA9IG1hcmsuYWRkVG9TZXQoY29weSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChqc29uLm1hcmtzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIik7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICAgICAgbm9kZS50eXBlLmNoZWNrQXR0cnMobm9kZS5hdHRycyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn1cbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGF0dHJzLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnRleHQ7IH1cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKTsgfVxuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMudGV4dCwgbWFya3MpO1xuICAgIH1cbiAgICB3aXRoVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIGN1dChmcm9tID0gMCwgdG8gPSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICAgIGZvciAobGV0IGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgc3RyID0gbWFya3NbaV0udHlwZS5uYW1lICsgXCIoXCIgKyBzdHIgKyBcIilcIjtcbiAgICByZXR1cm4gc3RyO1xufVxuXG4vKipcbkluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBhIG1hdGNoIHN0YXRlIG9mIGEgbm9kZSB0eXBlJ3Ncbltjb250ZW50IGV4cHJlc3Npb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb250ZW50KSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5maW5kIG91dCB3aGV0aGVyIGZ1cnRoZXIgY29udGVudCBtYXRjaGVzIGhlcmUsIGFuZCB3aGV0aGVyIGEgZ2l2ZW5cbnBvc2l0aW9uIGlzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuKi9cbmNsYXNzIENvbnRlbnRNYXRjaCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBtYXRjaCBzdGF0ZSByZXByZXNlbnRzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuICAgICovXG4gICAgdmFsaWRFbmQpIHtcbiAgICAgICAgdGhpcy52YWxpZEVuZCA9IHZhbGlkRW5kO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcENhY2hlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHBhcnNlKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50TWF0Y2guZW1wdHk7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IGRmYShuZmEoZXhwcikpO1xuICAgICAgICBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIGEgbm9kZSB0eXBlLCByZXR1cm5pbmcgYSBtYXRjaCBhZnRlciB0aGF0IG5vZGUgaWZcbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0W2ldLm5leHQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggYSBmcmFnbWVudC4gUmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdGNoIHdoZW5cbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hGcmFnbWVudChmcmFnLCBzdGFydCA9IDAsIGVuZCA9IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgY3VyID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBjdXIgJiYgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCAhPSAwICYmIHRoaXMubmV4dFswXS50eXBlLmlzSW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgdHlwZSBhdCB0aGlzIG1hdGNoIHBvc2l0aW9uIHRoYXQgY2FuXG4gICAgYmUgZ2VuZXJhdGVkLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRUeXBlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gdGhpcy5uZXh0W2ldO1xuICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhdGlibGUob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IG90aGVyLm5leHRbal0udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIHRoZSBnaXZlbiBmcmFnbWVudCwgYW5kIGlmIHRoYXQgZmFpbHMsIHNlZSBpZiBpdCBjYW5cbiAgICBiZSBtYWRlIHRvIG1hdGNoIGJ5IGluc2VydGluZyBub2RlcyBpbiBmcm9udCBvZiBpdC4gV2hlblxuICAgIHN1Y2Nlc3NmdWwsIHJldHVybiBhIGZyYWdtZW50IG9mIGluc2VydGVkIG5vZGVzICh3aGljaCBtYXkgYmVcbiAgICBlbXB0eSBpZiBub3RoaW5nIGhhZCB0byBiZSBpbnNlcnRlZCkuIFdoZW4gYHRvRW5kYCBpcyB0cnVlLCBvbmx5XG4gICAgcmV0dXJuIGEgZnJhZ21lbnQgaWYgdGhlIHJlc3VsdGluZyBtYXRjaCBnb2VzIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZmlsbEJlZm9yZShhZnRlciwgdG9FbmQgPSBmYWxzZSwgc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbdGhpc107XG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoYWZ0ZXIsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHR5cGVzLm1hcCh0cCA9PiB0cC5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZSB0eXBlcyB0aGF0IHdvdWxkIGFsbG93IGEgbm9kZSBvZiB0aGVcbiAgICBnaXZlbiB0eXBlIHRvIGFwcGVhciBhdCB0aGlzIHBvc2l0aW9uLiBUaGUgcmVzdWx0IG1heSBiZSBlbXB0eVxuICAgICh3aGVuIGl0IGZpdHMgZGlyZWN0bHkpIGFuZCB3aWxsIGJlIG51bGwgd2hlbiBubyBzdWNoIHdyYXBwaW5nXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgZmluZFdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwQ2FjaGVbaSArIDFdO1xuICAgICAgICBsZXQgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZVdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBsZXQgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCksIGFjdGl2ZSA9IFt7IG1hdGNoOiB0aGlzLCB0eXBlOiBudWxsLCB2aWE6IG51bGwgfV07XG4gICAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLCBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzTGVhZiAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkgJiYgISh0eXBlLm5hbWUgaW4gc2VlbikgJiYgKCFjdXJyZW50LnR5cGUgfHwgbmV4dC52YWxpZEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goeyBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsIHR5cGUsIHZpYTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2Vlblt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgdGhpcyBub2RlIGhhcyBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBnZXQgZWRnZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBfbl/igIt0aCBvdXRnb2luZyBlZGdlIGZyb20gdGhpcyBub2RlIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGVkZ2Uobikge1xuICAgICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlJ3Mgbm8gJHtufXRoIGVkZ2UgaW4gdGhpcyBjb250ZW50IG1hdGNoYCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRbbl07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzZWVuID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4obS5uZXh0W2ldLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHNjYW4odGhpcyk7XG4gICAgICAgIHJldHVybiBzZWVuLm1hcCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBvdXQgKz0gKGkgPyBcIiwgXCIgOiBcIlwiKSArIG0ubmV4dFtpXS50eXBlLm5hbWUgKyBcIi0+XCIgKyBzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkNvbnRlbnRNYXRjaC5lbXB0eSA9IG5ldyBDb250ZW50TWF0Y2godHJ1ZSk7XG5jbGFzcyBUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICAgICAgICB0aGlzLmlubGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc107IH1cbiAgICBlYXQodG9rKSB7IHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpOyB9XG4gICAgZXJyKHN0cikgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7IH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU2VxKHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5uZXh0ICYmIHN0cmVhbS5uZXh0ICE9IFwiKVwiICYmIHN0cmVhbS5uZXh0ICE9IFwifFwiKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJzZXFcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgICBsZXQgZXhwciA9IHBhcnNlRXhwckF0b20oc3RyZWFtKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiK1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwicGx1c1wiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJzdGFyXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcIm9wdFwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKVxuICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICAgIGlmICgvXFxELy50ZXN0KHN0cmVhbS5uZXh0KSlcbiAgICAgICAgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIGxldCByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gICAgbGV0IG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksIG1heCA9IG1pbjtcbiAgICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ICE9IFwifVwiKVxuICAgICAgICAgICAgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4ID0gLTE7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLmVhdChcIn1cIikpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmNsb3NlZCBicmFjZWQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyYW5nZVwiLCBtaW4sIG1heCwgZXhwciB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5hbWUoc3RyZWFtLCBuYW1lKSB7XG4gICAgbGV0IHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcywgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gW3R5cGVdO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuaXNJbkdyb3VwKG5hbWUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8vIENvbnN0cnVjdCBhbiBORkEgZnJvbSBhbiBleHByZXNzaW9uIGFzIHJldHVybmVkIGJ5IHRoZSBwYXJzZXIuIFRoZVxuLy8gTkZBIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHN0YXRlcywgd2hpY2ggYXJlIHRoZW1zZWx2ZXNcbi8vIGFycmF5cyBvZiBlZGdlcywgd2hpY2ggYXJlIGB7dGVybSwgdG99YCBvYmplY3RzLiBUaGUgZmlyc3Qgc3RhdGUgaXNcbi8vIHRoZSBlbnRyeSBzdGF0ZSBhbmQgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgc3VjY2VzcyBzdGF0ZS5cbi8vXG4vLyBOb3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbi8vIHNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxuLy8gbmVjZXNzYXJ5LlxuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBjaGVja0F0dHJzKGF0dHJzLCB2YWx1ZXMsIHR5cGUsIG5hbWUpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHZhbHVlcylcbiAgICAgICAgaWYgKCEobmFtZSBpbiBhdHRycykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgYXR0cmlidXRlICR7bmFtZX0gZm9yICR7dHlwZX0gb2YgdHlwZSAke25hbWV9YCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICBpZiAoYXR0ci52YWxpZGF0ZSlcbiAgICAgICAgICAgIGF0dHIudmFsaWRhdGUodmFsdWVzW25hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0QXR0cnModHlwZU5hbWUsIGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZSh0eXBlTmFtZSwgbmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbk5vZGUgdHlwZXMgYXJlIG9iamVjdHMgYWxsb2NhdGVkIG9uY2UgcGVyIGBTY2hlbWFgIGFuZCB1c2VkIHRvXG5bdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50eXBlKSBgTm9kZWAgaW5zdGFuY2VzLiBUaGV5IGNvbnRhaW4gaW5mb3JtYXRpb25cbmFib3V0IHRoZSBub2RlIHR5cGUsIHN1Y2ggYXMgaXRzIG5hbWUgYW5kIHdoYXQga2luZCBvZiBub2RlIGl0XG5yZXByZXNlbnRzLlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIHRoZSBub2RlIHR5cGUgaGFzIGluIHRoaXMgc2NoZW1hLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQSBsaW5rIGJhY2sgdG8gdGhlIGBTY2hlbWFgIHRoZSBub2RlIHR5cGUgYmVsb25ncyB0by5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgdGhhdCB0aGlzIHR5cGUgaXMgYmFzZWQgb25cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc2V0IG9mIG1hcmtzIGFsbG93ZWQgaW4gdGhpcyBub2RlLiBgbnVsbGAgbWVhbnMgYWxsIG1hcmtzXG4gICAgICAgIGFyZSBhbGxvd2VkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKG5hbWUsIHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLmlubGluZUNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSAhKHNwZWMuaW5saW5lIHx8IG5hbWUgPT0gXCJ0ZXh0XCIpO1xuICAgICAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhbiBpbmxpbmUgdHlwZS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuICF0aGlzLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYSB0ZXh0YmxvY2sgdHlwZSwgYSBibG9jayB0aGF0IGNvbnRhaW5zIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLmlzQmxvY2sgJiYgdGhpcy5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBmb3Igbm9kZSB0eXBlcyB0aGF0IGFsbG93IG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZVxuICAgIGRpcmVjdGx5IGVkaXRhYmxlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgfHwgISF0aGlzLnNwZWMuYXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiB0cnVlIHdoZW4gdGhpcyBub2RlIHR5cGUgaXMgcGFydCBvZiB0aGUgZ2l2ZW5cbiAgICBbZ3JvdXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5ncm91cCkuXG4gICAgKi9cbiAgICBpc0luR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzLmluZGV4T2YoZ3JvdXApID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGUncyBbd2hpdGVzcGFjZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLndoaXRlc3BhY2UpIG9wdGlvbi5cbiAgICAqL1xuICAgIGdldCB3aGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLndoaXRlc3BhY2UgfHwgKHRoaXMuc3BlYy5jb2RlID8gXCJwcmVcIiA6IFwibm9ybWFsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIG5vZGUgdHlwZSBoYXMgYW55IHJlcXVpcmVkIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgICBmb3IgKGxldCBuIGluIHRoaXMuYXR0cnMpXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbm9kZSBhbGxvd3Mgc29tZSBvZiB0aGUgc2FtZSBjb250ZW50IGFzXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGNvbXBhdGlibGVDb250ZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBdHRycztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBOb2RlYCBvZiB0aGlzIHR5cGUuIFRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZVxuICAgIGNoZWNrZWQgYW5kIGRlZmF1bHRlZCAoeW91IGNhbiBwYXNzIGBudWxsYCB0byB1c2UgdGhlIHR5cGUnc1xuICAgIGRlZmF1bHRzIGVudGlyZWx5LCBpZiBubyByZXF1aXJlZCBhdHRyaWJ1dGVzIGV4aXN0KS4gYGNvbnRlbnRgXG4gICAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYSBub2RlLCBhbiBhcnJheSBvZiBub2Rlcywgb3JcbiAgICBgbnVsbGAuIFNpbWlsYXJseSBgbWFya3NgIG1heSBiZSBgbnVsbGAgdG8gZGVmYXVsdCB0byB0aGUgZW1wdHlcbiAgICBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBjaGVjayB0aGUgZ2l2ZW4gY29udGVudFxuICAgIGFnYWluc3QgdGhlIG5vZGUgdHlwZSdzIGNvbnRlbnQgcmVzdHJpY3Rpb25zLCBhbmQgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiBpdCBkb2Vzbid0IG1hdGNoLlxuICAgICovXG4gICAgY3JlYXRlQ2hlY2tlZChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgY29udGVudCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IHNlZSBpZiBpdCBpc1xuICAgIG5lY2Vzc2FyeSB0byBhZGQgbm9kZXMgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgZ2l2ZW4gZnJhZ21lbnRcbiAgICB0byBtYWtlIGl0IGZpdCB0aGUgbm9kZS4gSWYgbm8gZml0dGluZyB3cmFwcGluZyBjYW4gYmUgZm91bmQsXG4gICAgcmV0dXJuIG51bGwuIE5vdGUgdGhhdCwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcmVxdWlyZWQgbm9kZXMgY2FuXG4gICAgYWx3YXlzIGJlIGNyZWF0ZWQsIHRoaXMgd2lsbCBhbHdheXMgc3VjY2VlZCBpZiB5b3UgcGFzcyBudWxsIG9yXG4gICAgYEZyYWdtZW50LmVtcHR5YCBhcyBjb250ZW50LlxuICAgICovXG4gICAgY3JlYXRlQW5kRmlsbChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgbGV0IGFmdGVyID0gbWF0Y2hlZCAmJiBtYXRjaGVkLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyB2YWxpZCBjb250ZW50IGZvciB0aGlzIG5vZGVcbiAgICB0eXBlLlxuICAgICovXG4gICAgdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgbm90IHZhbGlkIGNvbnRlbnQgZm9yIHRoaXNcbiAgICBub2RlIHR5cGUuXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29udGVudCBmb3Igbm9kZSAke3RoaXMubmFtZX06ICR7Y29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICAgIGNoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibm9kZVwiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGFyZSBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIGxldCB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICAgICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgaXRzIHRvcCBub2RlIHR5cGUgKCdcIiArIHRvcFR5cGUgKyBcIicpXCIpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZXN1bHQudGV4dC5hdHRycylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh0eXBlTmFtZSwgYXR0ck5hbWUsIHR5cGUpIHtcbiAgICBsZXQgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKTtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgIGxldCBuYW1lID0gdmFsdWUgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YobmFtZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgJHt0eXBlc30gZm9yIGF0dHJpYnV0ZSAke2F0dHJOYW1lfSBvbiB0eXBlICR7dHlwZU5hbWV9LCBnb3QgJHtuYW1lfWApO1xuICAgIH07XG59XG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHR5cGVvZiBvcHRpb25zLnZhbGlkYXRlID09IFwic3RyaW5nXCIgPyB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zLnZhbGlkYXRlKSA6IG9wdGlvbnMudmFsaWRhdGU7XG4gICAgfVxuICAgIGdldCBpc1JlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGVmYXVsdDtcbiAgICB9XG59XG4vLyBNYXJrc1xuLyoqXG5MaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG50aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG5bdGFnZ2VkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG5pbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG4qL1xuY2xhc3MgTWFya1R5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG1hcmsgdHlwZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuaywgXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSB0aGF0IHRoaXMgbWFyayB0eXBlIGluc3RhbmNlIGlzIHBhcnQgb2YuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIG9uIHdoaWNoIHRoZSB0eXBlIGlzIGJhc2VkLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhuYW1lLCBzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBvZiB0aGlzIHR5cGUuIGBhdHRyc2AgbWF5IGJlIGBudWxsYCBvciBhbiBvYmplY3RcbiAgICBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4gICAgdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJhbmsgPSAwO1xuICAgICAgICBtYXJrcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQsIGEgbmV3IHNldFxuICAgIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tBdHRycyhhdHRycykge1xuICAgICAgICBjaGVja0F0dHJzKHRoaXMuYXR0cnMsIGF0dHJzLCBcIm1hcmtcIiwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4gICAgW2V4Y2x1ZGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG59XG4vKipcbkEgZG9jdW1lbnQgc2NoZW1hLiBIb2xkcyBbbm9kZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlKSBhbmQgW21hcmtcbnR5cGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrVHlwZSkgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIGFuZCBtYXJrcyB0aGF0IG1heVxub2NjdXIgaW4gY29uZm9ybWluZyBkb2N1bWVudHMsIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuY3JlYXRpbmcgYW5kIGRlc2VyaWFsaXppbmcgc3VjaCBkb2N1bWVudHMuXG5cbldoZW4gZ2l2ZW4sIHRoZSB0eXBlIHBhcmFtZXRlcnMgcHJvdmlkZSB0aGUgbmFtZXMgb2YgdGhlIG5vZGVzIGFuZFxubWFya3MgaW4gdGhpcyBzY2hlbWEuXG4qL1xuY2xhc3MgU2NoZW1hIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBzY2hlbWEgZnJvbSBhIHNjaGVtYSBbc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNjaGVtYVNwZWMpLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtsaW5lYnJlYWtcbiAgICAgICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5saW5lYnJlYWtSZXBsYWNlbWVudCkgbm9kZSBkZWZpbmVkXG4gICAgICAgIGluIHRoaXMgc2NoZW1hLCBpZiBhbnkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gICAgICAgIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgICAgICAgaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZVNwZWMgPSB0aGlzLnNwZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKVxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjW3Byb3BdID0gc3BlY1twcm9wXTtcbiAgICAgICAgaW5zdGFuY2VTcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpLFxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcbiAgICAgICAgbGV0IGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRoaXMubWFya3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgICAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgICAgICAgICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZS5zcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgbGluZWJyZWFrIG5vZGVzIGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzSW5saW5lIHx8ICF0eXBlLmlzTGVhZilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lYnJlYWsgcmVwbGFjZW1lbnQgbm9kZXMgbXVzdCBiZSBpbmxpbmUgbGVhZiBub2Rlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVicmVha1JlcGxhY2VtZW50ID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNUYWdSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudGFnICE9IG51bGw7IH1cbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUuc3R5bGUgIT0gbnVsbDsgfVxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2hlZFN0eWxlcyA9IHRoaXMubWF0Y2hlZFN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVGFnUnVsZShydWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHlsZVJ1bGUocnVsZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IC9bXj1dKi8uZXhlYyhydWxlLnN0eWxlKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFN0eWxlcy5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFN0eWxlcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIE1hcmsubm9uZSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2VcbiAgICBbYHBhcnNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2ZcbiAgICBvcHRpb25zLiBCdXQgdW5saWtlIHRoYXQgbWV0aG9kLCB3aGljaCBwcm9kdWNlcyBhIHdob2xlIG5vZGUsXG4gICAgdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuICAgIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4gICAgdGhlIGxlZnQgb2YgdGhlIGlucHV0IGFuZCB0aGUgZW5kIG9mIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBwYXJzZVNsaWNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBNYXJrLm5vbmUsIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5zdHlsZXNbaV0sIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHxcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgICAgICAgICAvLyBvciBoYXMgYW4gJz0nIHNpZ24gYWZ0ZXIgdGhlIHByb3AsIGZvbGxvd2VkIGJ5IHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHNjaGVtYVJ1bGVzKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBydWxlLnByaW9yaXR5ID09IG51bGwgPyA1MCA6IHJ1bGUucHJpb3JpdHksIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXSwgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm1hcmsgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5jbGVhck1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm5vZGVzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5ub2RlIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUubWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5vZGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbiAgICBzY2hlbWEncyBbbm9kZSBzcGVjc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4gICAgW3ByaW9yaXR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlLnByaW9yaXR5KS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbn1cbmNvbnN0IGJsb2NrVGFncyA9IHtcbiAgICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICAgIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICAgIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSwgaDE6IHRydWUsIGgyOiB0cnVlLCBoMzogdHJ1ZSwgaDQ6IHRydWUsIGg1OiB0cnVlLFxuICAgIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gICAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5jb25zdCBpZ25vcmVUYWdzID0ge1xuICAgIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuY29uc3QgbGlzdFRhZ3MgPSB7IG9sOiB0cnVlLCB1bDogdHJ1ZSB9O1xuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbmNvbnN0IE9QVF9QUkVTRVJWRV9XUyA9IDEsIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMiwgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHxcbiAgICAgICAgICAgIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IE9QVF9QUkVTRVJWRV9XUyB8IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogYmFzZSAmIH5PUFRfT1BFTl9MRUZUO1xufVxuY2xhc3MgTm9kZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBtYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLCB3cmFwO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sIG07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZSBpZiAoaXNPcGVuKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSwgbWFya3MpIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20sIG1hcmtzKTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcyk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSwgbWFya3MpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wLCBwcmVzZXJ2ZVdTID0gKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpID8gXCJmdWxsXCJcbiAgICAgICAgICAgIDogdGhpcy5sb2NhbFByZXNlcnZlV1MgfHwgKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSA+IDA7XG4gICAgICAgIGlmIChwcmVzZXJ2ZVdTID09PSBcImZ1bGxcIiB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZVdTKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXNlcnZlV1MgIT09IFwiZnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KHZhbHVlKSwgbWFya3MpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hcmtzLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBvdXRlcldTID0gdGhpcy5sb2NhbFByZXNlcnZlV1MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAoZG9tLnRhZ05hbWUgPT0gXCJQUkVcIiB8fCAvcHJlLy50ZXN0KGRvbS5zdHlsZSAmJiBkb20uc3R5bGUud2hpdGVTcGFjZSkpXG4gICAgICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IHRydWU7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgb3V0OiBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlubmVyTWFya3MgPSBydWxlICYmIHJ1bGUuc2tpcCA/IG1hcmtzIDogdGhpcy5yZWFkU3R5bGVzKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgaWYgKGlubmVyTWFya3MpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tLCBpbm5lck1hcmtzKTtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgaWYgKGlubmVyTWFya3MpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgaW5uZXJNYXJrcywgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IG91dGVyV1M7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgbGVhZiBET00gbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgaWdub3JlZFxuICAgIGxlYWZGYWxsYmFjayhkb20sIG1hcmtzKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSwgbWFya3MpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKSB7XG4gICAgICAgIC8vIElnbm9yZWQgQlIgbm9kZXMgc2hvdWxkIGF0IGxlYXN0IGNyZWF0ZSBhbiBpbmxpbmUgY29udGV4dFxuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpXG4gICAgICAgICAgICB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIiksIG1hcmtzKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gdXBkYXRlZCBhcnJheSBvZiBtYXJrcywgb3IgbnVsbCB0byBpbmRpY2F0ZSBzb21lIG9mIHRoZVxuICAgIC8vIHN0eWxlcyBoYWQgYSBydWxlIHdpdGggYGlnbm9yZWAgc2V0LlxuICAgIHJlYWRTdHlsZXMoZG9tLCBtYXJrcykge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9tLnN0eWxlO1xuICAgICAgICAvLyBCZWNhdXNlIG1hbnkgcHJvcGVydGllcyB3aWxsIG9ubHkgc2hvdyB1cCBpbiAnbm9ybWFsaXplZCcgZm9ybVxuICAgICAgICAvLyBpbiBgc3R5bGUuaXRlbWAgKGkuZS4gdGV4dC1kZWNvcmF0aW9uIGJlY29tZXNcbiAgICAgICAgLy8gdGV4dC1kZWNvcmF0aW9uLWxpbmUsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZXRjKSwgd2UgZGlyZWN0bHlcbiAgICAgICAgLy8gcXVlcnkgdGhlIHN0eWxlcyBtZW50aW9uZWQgaW4gb3VyIHJ1bGVzIGluc3RlYWQgb2YgaXRlcmF0aW5nXG4gICAgICAgIC8vIG92ZXIgdGhlIGl0ZW1zLlxuICAgICAgICBpZiAoc3R5bGVzICYmIHN0eWxlcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2VyLm1hdGNoZWRTdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHRoaXMucGFyc2VyLm1hdGNoZWRTdHlsZXNbaV0sIHZhbHVlID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUobmFtZSwgdmFsdWUsIHRoaXMsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmlnbm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmZpbHRlcihtID0+ICFydWxlLmNsZWFyTWFyayhtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBydWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4gICAgLy8gZmFsc2UuIE90aGVyd2lzZSwgYXBwbHkgaXQsIHVzZSBpdHMgcmV0dXJuIHZhbHVlIHRvIGRyaXZlIHRoZSB3YXlcbiAgICAvLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuICAgIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBtYXJrcywgY29udGludWVBZnRlcikge1xuICAgICAgICBsZXQgc3luYywgbm9kZVR5cGU7XG4gICAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IHRoaXMuZW50ZXIobm9kZVR5cGUsIHJ1bGUuYXR0cnMgfHwgbnVsbCwgbWFya3MsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtzID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycyksIG1hcmtzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydEluID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIG1hcmtzLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUsIG1hcmtzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudERPTSA9IGRvbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3RvcihydWxlLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSwgbWFya3MpO1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSlcbiAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIG1hcmtzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hZGRET00oZG9tLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuICAgIC8vIGNvbnRleHQuIE1heSBhZGQgaW50ZXJtZWRpYXRlIHdyYXBwZXJzIGFuZC9vciBsZWF2ZSBub24tc29saWRcbiAgICAvLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuICAgIGZpbmRQbGFjZShub2RlLCBtYXJrcykge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgbWFya3MsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlLCBtYXJrcykge1xuICAgICAgICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihibG9jaywgbnVsbCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5maW5kUGxhY2Uobm9kZSwgbWFya3MpO1xuICAgICAgICBpZiAoaW5uZXJNYXJrcykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBub2RlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBtIG9mIGlubmVyTWFya3MuY29uY2F0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA/IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG0udHlwZSkgOiBtYXJrTWF5QXBwbHkobS50eXBlLCBub2RlLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBub2RlTWFya3MgPSBtLmFkZFRvU2V0KG5vZGVNYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhub2RlTWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIG1hcmtzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpLCBtYXJrcyk7XG4gICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgaW5uZXJNYXJrcyA9IHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgICByZXR1cm4gaW5uZXJNYXJrcztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzLCBtYXJrcywgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIGxldCBhcHBseU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmZpbHRlcihtID0+IHtcbiAgICAgICAgICAgIGlmICh0b3AudHlwZSA/IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG0udHlwZSkgOiBtYXJrTWF5QXBwbHkobS50eXBlLCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5TWFya3MgPSBtLmFkZFRvU2V0KGFwcGx5TWFya3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgYXBwbHlNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuICAgIC8vIHRoZWlyIHBhcmVudHNcbiAgICBjbG9zZUV4dHJhKG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLmZpbmlzaCghISh0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMudG9wT3BlbikpO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvY2FsUHJlc2VydmVXUykge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaV0ub3B0aW9ucyB8PSBPUFRfUFJFU0VSVkVfV1M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBvcygpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29udGVudFtqXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5UZXh0KHRleHROb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGV4dCBzdHJpbmcgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG4gICAgbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgbGV0IHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgbGV0IHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICAgIGxldCBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gICAgICAgIGxldCBtYXRjaCA9IChpLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IChuZXh0Lm5hbWUgIT0gcGFydCAmJiAhbmV4dC5pc0luR3JvdXAocGFydCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcHJldkl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZJdGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJldkl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQXBwbHkgYSBDU1Mgc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gICAgbGV0IG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHNlZW4gPSBbXSwgc2NhbiA9IChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBET00gc2VyaWFsaXplciBrbm93cyBob3cgdG8gY29udmVydCBQcm9zZU1pcnJvciBub2RlcyBhbmRcbm1hcmtzIG9mIHZhcmlvdXMgdHlwZXMgdG8gRE9NIG5vZGVzLlxuKi9cbmNsYXNzIERPTVNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlcmlhbGl6ZXIuIGBub2Rlc2Agc2hvdWxkIG1hcCBub2RlIG5hbWVzIHRvIGZ1bmN0aW9uc1xuICAgIHRoYXQgdGFrZSBhIG5vZGUgYW5kIHJldHVybiBhIGRlc2NyaXB0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgRE9NLiBgbWFya3NgIGRvZXMgdGhlIHNhbWUgZm9yIG1hcmsgbmFtZXMsIGJ1dCBhbHNvIGdldHMgYW5cbiAgICBhcmd1bWVudCB0aGF0IHRlbGxzIGl0IHdoZXRoZXIgdGhlIG1hcmsncyBjb250ZW50IGlzIGJsb2NrIG9yXG4gICAgaW5saW5lIGNvbnRlbnQgKGZvciB0eXBpY2FsIHVzZSwgaXQnbGwgYWx3YXlzIGJlIGlubGluZSkuIEEgbWFya1xuICAgIHNlcmlhbGl6ZXIgbWF5IGJlIGBudWxsYCB0byBpbmRpY2F0ZSB0aGF0IG1hcmtzIG9mIHRoYXQgdHlwZVxuICAgIHNob3VsZCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbm9kZXMsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbWFya3MpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGlzIGZyYWdtZW50IHRvIGEgRE9NIGZyYWdtZW50LiBXaGVuXG4gICAgbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbiAgICBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zID0ge30sIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggfHwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQga2VlcCA9IDAsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrRE9NID0gdGhpcy5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChbYWRkLCB0b3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyBkb20sIGNvbnRlbnRET00gfSA9IHJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiByZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSwgbnVsbCwgbWFyay5hdHRycyk7XG4gICAgfVxuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwsIGJsb2NrQXJyYXlzSW4pIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cbmNvbnN0IHN1c3BpY2lvdXNBdHRyaWJ1dGVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzdXNwaWNpb3VzQXR0cmlidXRlcyhhdHRycykge1xuICAgIGxldCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVDYWNoZS5nZXQoYXR0cnMpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuc2V0KGF0dHJzLCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIoYXR0cnMpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzdXNwaWNpb3VzQXR0cmlidXRlc0lubmVyKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZnVuY3Rpb24gc2Nhbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbih2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2Nhbih2YWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NhbihhdHRycyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHsgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKSB9O1xuICAgIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHN1c3BpY2lvdXM7XG4gICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcnJheSBwYXNzZWQgdG8gcmVuZGVyU3BlY1wiKTtcbiAgICBpZiAoYmxvY2tBcnJheXNJbiAmJiAoc3VzcGljaW91cyA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzKGJsb2NrQXJyYXlzSW4pKSAmJlxuICAgICAgICBzdXNwaWNpb3VzLmluZGV4T2Yoc3RydWN0dXJlKSA+IC0xKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzaW5nIGFuIGFycmF5IGZyb20gYW4gYXR0cmlidXRlIG9iamVjdCBhcyBhIERPTSBzcGVjLiBUaGlzIG1heSBiZSBhbiBhdHRlbXB0ZWQgY3Jvc3Mgc2l0ZSBzY3JpcHRpbmcgYXR0YWNrLlwiKTtcbiAgICBsZXQgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRET007XG4gICAgbGV0IGRvbSA9ICh4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgIGxldCBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlID4gMClcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NOiBkb20gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IGRvbTogaW5uZXIsIGNvbnRlbnRET006IGlubmVyQ29udGVudCB9ID0gcmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIl0sIm5hbWVzIjpbIk9yZGVyZWRNYXAiLCJmaW5kRGlmZlN0YXJ0IiwiYSIsImIiLCJwb3MiLCJpIiwiY2hpbGRDb3VudCIsImNoaWxkQSIsImNoaWxkIiwiY2hpbGRCIiwibm9kZVNpemUiLCJzYW1lTWFya3VwIiwiaXNUZXh0IiwidGV4dCIsImoiLCJjb250ZW50Iiwic2l6ZSIsImlubmVyIiwiZmluZERpZmZFbmQiLCJwb3NBIiwicG9zQiIsImlBIiwiaUIiLCJzYW1lIiwibWluU2l6ZSIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJGcmFnbWVudCIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwibm9kZXNCZXR3ZWVuIiwiZnJvbSIsInRvIiwiZiIsIm5vZGVTdGFydCIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInBhcmVudCIsImVuZCIsInN0YXJ0IiwibWF4IiwiZGVzY2VuZGFudHMiLCJ0ZXh0QmV0d2VlbiIsImJsb2NrU2VwYXJhdG9yIiwibGVhZlRleHQiLCJmaXJzdCIsIm5vZGUiLCJub2RlVGV4dCIsInNsaWNlIiwiaXNMZWFmIiwidHlwZSIsInNwZWMiLCJpc0Jsb2NrIiwiaXNUZXh0YmxvY2siLCJhcHBlbmQiLCJvdGhlciIsImxhc3QiLCJsYXN0Q2hpbGQiLCJmaXJzdENoaWxkIiwid2l0aFRleHQiLCJwdXNoIiwiY3V0IiwicmVzdWx0IiwiY3V0QnlJbmRleCIsImVtcHR5IiwicmVwbGFjZUNoaWxkIiwiaW5kZXgiLCJjdXJyZW50IiwiY29weSIsImFkZFRvU3RhcnQiLCJjb25jYXQiLCJhZGRUb0VuZCIsImVxIiwiZ2V0IiwiZm91bmQiLCJSYW5nZUVycm9yIiwibWF5YmVDaGlsZCIsImZvckVhY2giLCJwIiwib3RoZXJQb3MiLCJmaW5kSW5kZXgiLCJyb3VuZCIsInJldEluZGV4IiwiY3VyUG9zIiwiY3VyIiwidG9TdHJpbmciLCJ0b1N0cmluZ0lubmVyIiwiam9pbiIsInRvSlNPTiIsIm1hcCIsIm4iLCJmcm9tSlNPTiIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVGcm9tSlNPTiIsImZyb21BcnJheSIsImFycmF5Iiwiam9pbmVkIiwibm9kZXMiLCJhdHRycyIsIm9mZnNldCIsImNvbXBhcmVEZWVwIiwiX3R5cGVvZiIsIk1hcmsiLCJhZGRUb1NldCIsInNldCIsInBsYWNlZCIsImV4Y2x1ZGVzIiwicmFuayIsInJlbW92ZUZyb21TZXQiLCJpc0luU2V0Iiwib2JqIiwibmFtZSIsIl8iLCJqc29uIiwibWFya3MiLCJtYXJrIiwiY3JlYXRlIiwiY2hlY2tBdHRycyIsInNhbWVTZXQiLCJzZXRGcm9tIiwibm9uZSIsInNvcnQiLCJSZXBsYWNlRXJyb3IiLCJfRXJyb3IiLCJfY2FsbFN1cGVyIiwiX2luaGVyaXRzIiwiX3dyYXBOYXRpdmVTdXBlciIsIkVycm9yIiwiU2xpY2UiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwiaW5zZXJ0QXQiLCJmcmFnbWVudCIsImluc2VydEludG8iLCJyZW1vdmVCZXR3ZWVuIiwicmVtb3ZlUmFuZ2UiLCJtYXhPcGVuIiwib3Blbklzb2xhdGluZyIsImlzb2xhdGluZyIsIl9jb250ZW50JGZpbmRJbmRleCIsIl9jb250ZW50JGZpbmRJbmRleDIiLCJpbmRleFRvIiwib2Zmc2V0VG8iLCJkaXN0IiwiaW5zZXJ0IiwiX2NvbnRlbnQkZmluZEluZGV4MyIsImNhblJlcGxhY2UiLCJyZXBsYWNlIiwiJGZyb20iLCIkdG8iLCJkZXB0aCIsInJlcGxhY2VPdXRlciIsImNsb3NlIiwicmVwbGFjZVR3b1dheSIsInBhcmVudE9mZnNldCIsIl9wcmVwYXJlU2xpY2VGb3JSZXBsYSIsInByZXBhcmVTbGljZUZvclJlcGxhY2UiLCJyZXBsYWNlVGhyZWVXYXkiLCJjaGVja0pvaW4iLCJtYWluIiwic3ViIiwiY29tcGF0aWJsZUNvbnRlbnQiLCJqb2luYWJsZSIsIiRiZWZvcmUiLCIkYWZ0ZXIiLCJhZGROb2RlIiwidGFyZ2V0IiwiYWRkUmFuZ2UiLCIkc3RhcnQiLCIkZW5kIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwidGV4dE9mZnNldCIsIm5vZGVBZnRlciIsIm5vZGVCZWZvcmUiLCJjaGVja0NvbnRlbnQiLCIkYWxvbmciLCJleHRyYSIsInJlc29sdmVOb0NhY2hlIiwiUmVzb2x2ZWRQb3MiLCJwYXRoIiwicmVzb2x2ZURlcHRoIiwidmFsIiwiaW5kZXhBZnRlciIsImJlZm9yZSIsImFmdGVyIiwiZE9mZiIsInBvc0F0SW5kZXgiLCJ0bXAiLCJpbmNsdXNpdmUiLCJtYXJrc0Fjcm9zcyIsImlzSW5saW5lIiwibmV4dCIsInNoYXJlZERlcHRoIiwiYmxvY2tSYW5nZSIsInByZWQiLCJkIiwiaW5saW5lQ29udGVudCIsIk5vZGVSYW5nZSIsInNhbWVQYXJlbnQiLCJzdHIiLCJyZXNvbHZlIiwiZG9jIiwiX25vZGUkY29udGVudCRmaW5kSW5kIiwicmVtIiwicmVzb2x2ZUNhY2hlZCIsImNhY2hlIiwicmVzb2x2ZUNhY2hlIiwiZWx0cyIsImVsdCIsIlJlc29sdmVDYWNoZSIsInJlc29sdmVDYWNoZVNpemUiLCJXZWFrTWFwIiwiZW1wdHlBdHRycyIsIk9iamVjdCIsIk5vZGUiLCJzdGFydFBvcyIsImhhc01hcmt1cCIsImRlZmF1bHRBdHRycyIsImluY2x1ZGVQYXJlbnRzIiwibm9kZUF0IiwiX25vZGUkY29udGVudCRmaW5kSW5kMiIsImNoaWxkQWZ0ZXIiLCJfdGhpcyRjb250ZW50JGZpbmRJbmQiLCJjaGlsZEJlZm9yZSIsIl90aGlzJGNvbnRlbnQkZmluZEluZDIiLCJyYW5nZUhhc01hcmsiLCJpc0F0b20iLCJ0b0RlYnVnU3RyaW5nIiwid3JhcE1hcmtzIiwiY29udGVudE1hdGNoQXQiLCJtYXRjaCIsImNvbnRlbnRNYXRjaCIsIm1hdGNoRnJhZ21lbnQiLCJyZXBsYWNlbWVudCIsIm9uZSIsInR3byIsInZhbGlkRW5kIiwiYWxsb3dzTWFya3MiLCJjYW5SZXBsYWNlV2l0aCIsIm1hdGNoVHlwZSIsImNhbkFwcGVuZCIsImNoZWNrIiwibSIsIm1hcmtGcm9tSlNPTiIsIm5vZGVUeXBlIiwicHJvdG90eXBlIiwiVGV4dE5vZGUiLCJfTm9kZSIsIl90aGlzMiIsIkpTT04iLCJzdHJpbmdpZnkiLCJiYXNlIiwiX2dldCIsIl9nZXRQcm90b3R5cGVPZiIsImNhbGwiLCJDb250ZW50TWF0Y2giLCJ3cmFwQ2FjaGUiLCJmcmFnIiwiaGFzUmVxdWlyZWRBdHRycyIsImNvbXBhdGlibGUiLCJmaWxsQmVmb3JlIiwidG9FbmQiLCJzZWVuIiwic2VhcmNoIiwidHlwZXMiLCJmaW5pc2hlZCIsInRwIiwiY3JlYXRlQW5kRmlsbCIsIl9tYXRjaCRuZXh0JGkiLCJpbmRleE9mIiwiZmluZFdyYXBwaW5nIiwiY29tcHV0ZWQiLCJjb21wdXRlV3JhcHBpbmciLCJhY3RpdmUiLCJ2aWEiLCJzaGlmdCIsInJldmVyc2UiLCJfbWF0Y2gkbmV4dCRpMiIsImVkZ2UiLCJzY2FuIiwib3V0IiwicGFyc2UiLCJzdHJpbmciLCJub2RlVHlwZXMiLCJzdHJlYW0iLCJUb2tlblN0cmVhbSIsImV4cHIiLCJwYXJzZUV4cHIiLCJlcnIiLCJkZmEiLCJuZmEiLCJjaGVja0ZvckRlYWRFbmRzIiwiaW5saW5lIiwidG9rZW5zIiwic3BsaXQiLCJwb3AiLCJlYXQiLCJ0b2siLCJTeW50YXhFcnJvciIsImV4cHJzIiwicGFyc2VFeHByU2VxIiwicGFyc2VFeHByU3Vic2NyaXB0IiwicGFyc2VFeHByQXRvbSIsInBhcnNlRXhwclJhbmdlIiwicGFyc2VOdW0iLCJ0ZXN0IiwiTnVtYmVyIiwicmVzb2x2ZU5hbWUiLCJ0eXBlTmFtZSIsImlzSW5Hcm91cCIsImNvbm5lY3QiLCJjb21waWxlIiwidGVybSIsImVkZ2VzIiwicmVkdWNlIiwibG9vcCIsImNtcCIsIm51bGxGcm9tIiwiX2VkZ2VzJGkiLCJsYWJlbGVkIiwiZXhwbG9yZSIsInN0YXRlcyIsIl9yZWYiLCJzdGF0ZSIsIndvcmsiLCJkZWFkIiwiX3N0YXRlJG5leHQkaiIsImRlZmF1bHRzIiwiYXR0ck5hbWUiLCJhdHRyIiwiaGFzRGVmYXVsdCIsImNvbXB1dGVBdHRycyIsImJ1aWx0IiwiZ2l2ZW4iLCJ2YWx1ZXMiLCJ2YWxpZGF0ZSIsImluaXRBdHRycyIsIkF0dHJpYnV0ZSIsIk5vZGVUeXBlIiwibWFya1NldCIsImdyb3VwcyIsImdyb3VwIiwiYXRvbSIsIndoaXRlc3BhY2UiLCJjb2RlIiwiaXNSZXF1aXJlZCIsImNyZWF0ZUNoZWNrZWQiLCJtYXRjaGVkIiwidmFsaWRDb250ZW50IiwiYWxsb3dzTWFya1R5cGUiLCJtYXJrVHlwZSIsImFsbG93ZWRNYXJrcyIsInRvcFR5cGUiLCJ0b3BOb2RlIiwidmFsaWRhdGVUeXBlIiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiTWFya1R5cGUiLCJleGNsdWRlZCIsImluc3RhbmNlIiwiU2NoZW1hIiwibGluZWJyZWFrUmVwbGFjZW1lbnQiLCJjYWNoZWQiLCJpbnN0YW5jZVNwZWMiLCJwcm9wIiwiY29udGVudEV4cHJDYWNoZSIsImNvbnRlbnRFeHByIiwibWFya0V4cHIiLCJnYXRoZXJNYXJrcyIsImV4Y2wiLCJiaW5kIiwidG9wTm9kZVR5cGUiLCJ3cmFwcGluZ3MiLCJvayIsImlzVGFnUnVsZSIsInJ1bGUiLCJ0YWciLCJpc1N0eWxlUnVsZSIsInN0eWxlIiwiRE9NUGFyc2VyIiwicnVsZXMiLCJfdGhpczMiLCJ0YWdzIiwic3R5bGVzIiwibWF0Y2hlZFN0eWxlcyIsImV4ZWMiLCJub3JtYWxpemVMaXN0cyIsInNvbWUiLCJyIiwiZG9tIiwiY29udGV4dCIsIlBhcnNlQ29udGV4dCIsImFkZEFsbCIsImZpbmlzaCIsInBhcnNlU2xpY2UiLCJtYXRjaFRhZyIsIm1hdGNoZXMiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VVUkkiLCJtYXRjaGVzQ29udGV4dCIsImdldEF0dHJzIiwibWF0Y2hTdHlsZSIsImNoYXJDb2RlQXQiLCJzY2hlbWFSdWxlcyIsInByaW9yaXR5IiwibmV4dFByaW9yaXR5Iiwic3BsaWNlIiwiX2xvb3AyIiwicGFyc2VET00iLCJpZ25vcmUiLCJjbGVhck1hcmsiLCJfbG9vcDMiLCJfbmFtZTMiLCJmcm9tU2NoZW1hIiwiZG9tUGFyc2VyIiwiYmxvY2tUYWdzIiwiYWRkcmVzcyIsImFydGljbGUiLCJhc2lkZSIsImJsb2NrcXVvdGUiLCJjYW52YXMiLCJkZCIsImRpdiIsImRsIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiZm9ybSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWRlciIsImhncm91cCIsImhyIiwibGkiLCJub3NjcmlwdCIsIm9sIiwib3V0cHV0IiwicHJlIiwic2VjdGlvbiIsInRhYmxlIiwidGZvb3QiLCJ1bCIsImlnbm9yZVRhZ3MiLCJoZWFkIiwib2JqZWN0Iiwic2NyaXB0IiwidGl0bGUiLCJsaXN0VGFncyIsIk9QVF9QUkVTRVJWRV9XUyIsIk9QVF9QUkVTRVJWRV9XU19GVUxMIiwiT1BUX09QRU5fTEVGVCIsIndzT3B0aW9uc0ZvciIsInByZXNlcnZlV2hpdGVzcGFjZSIsIk5vZGVDb250ZXh0Iiwic29saWQiLCJhY3RpdmVNYXJrcyIsImZpbGwiLCJ3cmFwIiwiaW5saW5lQ29udGV4dCIsInBhcmVudE5vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwicGFyc2VyIiwiaXNPcGVuIiwib3BlbiIsImxvY2FsUHJlc2VydmVXUyIsInRvcENvbnRleHQiLCJ0b3BPcHRpb25zIiwidG9wTWF0Y2giLCJmaW5kIiwiZmluZFBvc2l0aW9ucyIsIm5lZWRzQmxvY2siLCJhZGRET00iLCJhZGRUZXh0Tm9kZSIsImFkZEVsZW1lbnQiLCJub2RlVmFsdWUiLCJ0b3AiLCJwcmVzZXJ2ZVdTIiwiZG9tTm9kZUJlZm9yZSIsInByZXZpb3VzU2libGluZyIsImluc2VydE5vZGUiLCJmaW5kSW5UZXh0IiwiZmluZEluc2lkZSIsIm1hdGNoQWZ0ZXIiLCJvdXRlcldTIiwidGFnTmFtZSIsIndoaXRlU3BhY2UiLCJydWxlSUQiLCJub3JtYWxpemVMaXN0IiwicnVsZUZyb21Ob2RlIiwiaWdub3JlRmFsbGJhY2siLCJza2lwIiwiY2xvc2VQYXJlbnQiLCJzeW5jIiwib2xkTmVlZHNCbG9jayIsImxlYWZGYWxsYmFjayIsImlubmVyTWFya3MiLCJyZWFkU3R5bGVzIiwiYWRkRWxlbWVudEJ5UnVsZSIsImNvbnN1bWluZyIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImZpbmRQbGFjZSIsIl90aGlzNCIsImdldFByb3BlcnR5VmFsdWUiLCJfbG9vcDQiLCJfYWZ0ZXIiLCJ2IiwiZmlsdGVyIiwiX3JldCIsImNvbnRpbnVlQWZ0ZXIiLCJfdGhpczUiLCJlbnRlciIsInN0YXJ0SW4iLCJnZXRDb250ZW50IiwiY29udGVudERPTSIsImNvbnRlbnRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImZpbmRBcm91bmQiLCJjaGlsZE5vZGVzIiwibmV4dFNpYmxpbmciLCJmaW5kQXRQb2ludCIsInJvdXRlIiwiY3giLCJlbnRlcklubmVyIiwiYmxvY2siLCJ0ZXh0YmxvY2tGcm9tQ29udGV4dCIsImNsb3NlRXh0cmEiLCJub2RlTWFya3MiLCJfaXRlcmF0b3IiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIl9zdGVwIiwicyIsImRvbmUiLCJtYXJrTWF5QXBwbHkiLCJlIiwiYXBwbHlNYXJrcyIsInRvcE9wZW4iLCJjdXJyZW50UG9zIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInRleHROb2RlIiwiX3RoaXM2IiwicGFydHMiLCJvcHRpb24iLCJ1c2VSb290IiwibWluRGVwdGgiLCJwYXJ0IiwiJGNvbnRleHQiLCJkZWZsdCIsImRlZmF1bHRUeXBlIiwicHJldkl0ZW0iLCJhcHBlbmRDaGlsZCIsInNlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJfbG9vcDUiLCJlZGdlQ291bnQiLCJfbWF0Y2gkZWRnZSIsIl9yZXQyIiwiRE9NU2VyaWFsaXplciIsInNlcmlhbGl6ZUZyYWdtZW50IiwiX3RoaXM3IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImtlZXAiLCJyZW5kZXJlZCIsInNwYW5uaW5nIiwiYWRkIiwibWFya0RPTSIsInNlcmlhbGl6ZU1hcmsiLCJzZXJpYWxpemVOb2RlSW5uZXIiLCJfcmVuZGVyU3BlYzIiLCJyZW5kZXJTcGVjIiwic2VyaWFsaXplTm9kZSIsInRvRE9NIiwic3RydWN0dXJlIiwieG1sTlMiLCJibG9ja0FycmF5c0luIiwiZG9tU2VyaWFsaXplciIsIm5vZGVzRnJvbVNjaGVtYSIsIm1hcmtzRnJvbVNjaGVtYSIsImdhdGhlclRvRE9NIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUiLCJzdXNwaWNpb3VzQXR0cmlidXRlcyIsInN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIiLCJzdXNwaWNpb3VzIiwic3BhY2UiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGUiLCJfcmVuZGVyU3BlYzMiLCJpbm5lckNvbnRlbnQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-model/dist/index.js\n");

/***/ })

};
;