"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/linkifyjs";
exports.ids = ["vendor-chunks/linkifyjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/linkifyjs/dist/linkify.es.js":
/*!***************************************************!*\
  !*** ./node_modules/linkifyjs/dist/linkify.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiToken: () => (/* binding */ MultiToken),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   createTokenClass: () => (/* binding */ createTokenClass),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   multi: () => (/* binding */ multi),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   registerCustomProtocol: () => (/* binding */ registerCustomProtocol),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   registerTokenPlugin: () => (/* binding */ registerTokenPlugin),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray),\n/* harmony export */   test: () => (/* binding */ test),\n/* harmony export */   text: () => (/* binding */ multi),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _callSuper(_this, derived, args) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (e) {\n      return false;\n    }\n  }\n  derived = _getPrototypeOf(derived);\n  return _possibleConstructorReturn(_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf(_this).constructor) : derived.apply(_this, args));\n}\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nvar encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nvar encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */\nvar assign = function assign(target, properties) {\n  for (var key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nvar numeric = 'numeric';\nvar ascii = 'ascii';\nvar alpha = 'alpha';\nvar asciinumeric = 'asciinumeric';\nvar alphanumeric = 'alphanumeric';\nvar domain = 'domain';\nvar emoji = 'emoji';\nvar scheme = 'scheme';\nvar slashscheme = 'slashscheme';\nvar whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (var k in flags) {\n    var group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  var result = {};\n  for (var c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State() {\n  var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts: function accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go: function go(input) {\n    var state = this;\n    var nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (var i = 0; i < state.jr.length; i++) {\n      var regex = state.jr[i][0];\n      var _nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (_nextState && regex.test(input)) {\n        return _nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has: function has(input) {\n    var exactOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta: function ta(inputs, next, flags, groups) {\n    for (var i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr: function tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    var nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts: function ts(input, next, flags, groups) {\n    var state = this;\n    var len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (var i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt: function tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    var state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    var t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    var nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          var allFlags = assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nvar ta = function ta(state, input, next, flags, groups) {\n  return state.ta(input, next, flags, groups);\n};\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nvar tr = function tr(state, regexp, next, flags, groups) {\n  return state.tr(regexp, next, flags, groups);\n};\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nvar ts = function ts(state, input, next, flags, groups) {\n  return state.ts(input, next, flags, groups);\n};\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nvar tt = function tt(state, input, next, flags, groups) {\n  return state.tt(input, next, flags, groups);\n};\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nvar WORD = 'WORD'; // only contains a-z\nvar UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\nvar ASCIINUMERICAL = 'ASCIINUMERICAL'; // contains a-z, 0-9\nvar ALPHANUMERICAL = 'ALPHANUMERICAL'; // contains numbers and letters other than a-z, used for IDN\n\n// Special case of word\nvar LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nvar TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nvar UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nvar SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nvar SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nvar NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nvar WS = 'WS';\n\n// New line (unix style)\nvar NL = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nvar OPENBRACE = 'OPENBRACE'; // {\nvar CLOSEBRACE = 'CLOSEBRACE'; // }\nvar OPENBRACKET = 'OPENBRACKET'; // [\nvar CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nvar OPENPAREN = 'OPENPAREN'; // (\nvar CLOSEPAREN = 'CLOSEPAREN'; // )\nvar OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nvar CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nvar FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\nvar FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\nvar LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\nvar RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\nvar LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\nvar RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\nvar FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\nvar FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\n\n// Various symbols\nvar AMPERSAND = 'AMPERSAND'; // &\nvar APOSTROPHE = 'APOSTROPHE'; // '\nvar ASTERISK = 'ASTERISK'; // *\nvar AT = 'AT'; // @\nvar BACKSLASH = 'BACKSLASH'; // \\\nvar BACKTICK = 'BACKTICK'; // `\nvar CARET = 'CARET'; // ^\nvar COLON = 'COLON'; // :\nvar COMMA = 'COMMA'; // ,\nvar DOLLAR = 'DOLLAR'; // $\nvar DOT = 'DOT'; // .\nvar EQUALS = 'EQUALS'; // =\nvar EXCLAMATION = 'EXCLAMATION'; // !\nvar HYPHEN = 'HYPHEN'; // -\nvar PERCENT = 'PERCENT'; // %\nvar PIPE = 'PIPE'; // |\nvar PLUS = 'PLUS'; // +\nvar POUND = 'POUND'; // #\nvar QUERY = 'QUERY'; // ?\nvar QUOTE = 'QUOTE'; // \"\nvar FULLWIDTHMIDDLEDOT = 'FULLWIDTHMIDDLEDOT'; // ・\n\nvar SEMI = 'SEMI'; // ;\nvar SLASH = 'SLASH'; // /\nvar TILDE = 'TILDE'; // ~\nvar UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nvar EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nvar SYM = 'SYM';\nvar tk = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WORD: WORD,\n  UWORD: UWORD,\n  ASCIINUMERICAL: ASCIINUMERICAL,\n  ALPHANUMERICAL: ALPHANUMERICAL,\n  LOCALHOST: LOCALHOST,\n  TLD: TLD,\n  UTLD: UTLD,\n  SCHEME: SCHEME,\n  SLASH_SCHEME: SLASH_SCHEME,\n  NUM: NUM,\n  WS: WS,\n  NL: NL,\n  OPENBRACE: OPENBRACE,\n  CLOSEBRACE: CLOSEBRACE,\n  OPENBRACKET: OPENBRACKET,\n  CLOSEBRACKET: CLOSEBRACKET,\n  OPENPAREN: OPENPAREN,\n  CLOSEPAREN: CLOSEPAREN,\n  OPENANGLEBRACKET: OPENANGLEBRACKET,\n  CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n  FULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n  FULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n  LEFTCORNERBRACKET: LEFTCORNERBRACKET,\n  RIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n  LEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n  RIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n  FULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n  FULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n  AMPERSAND: AMPERSAND,\n  APOSTROPHE: APOSTROPHE,\n  ASTERISK: ASTERISK,\n  AT: AT,\n  BACKSLASH: BACKSLASH,\n  BACKTICK: BACKTICK,\n  CARET: CARET,\n  COLON: COLON,\n  COMMA: COMMA,\n  DOLLAR: DOLLAR,\n  DOT: DOT,\n  EQUALS: EQUALS,\n  EXCLAMATION: EXCLAMATION,\n  HYPHEN: HYPHEN,\n  PERCENT: PERCENT,\n  PIPE: PIPE,\n  PLUS: PLUS,\n  POUND: POUND,\n  QUERY: QUERY,\n  QUOTE: QUOTE,\n  FULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\n  SEMI: SEMI,\n  SLASH: SLASH,\n  TILDE: TILDE,\n  UNDERSCORE: UNDERSCORE,\n  EMOJI: EMOJI$1,\n  SYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nvar ASCII_LETTER = /[a-z]/;\nvar LETTER = /(?:[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CD\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7DC\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC4\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD887][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF39\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD888[\\uDC00-\\uDFAF])/; // Any Unicode character with letter data type\nvar EMOJI = /(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE89\\uDE8F-\\uDEC6\\uDECE-\\uDEDC\\uDEDF-\\uDEE9\\uDEF0-\\uDEF8])/; // Any Unicode emoji character\nvar EMOJI_VARIATION$1 = /\\ufe0f/;\nvar DIGIT = /\\d/;\nvar SPACE = /\\s/;\nvar regexp = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ASCII_LETTER: ASCII_LETTER,\n  LETTER: LETTER,\n  EMOJI: EMOJI,\n  EMOJI_VARIATION: EMOJI_VARIATION$1,\n  DIGIT: DIGIT,\n  SPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\nvar CR = '\\r'; // carriage-return character\nvar LF = '\\n'; // line-feed character\nvar EMOJI_VARIATION = \"\\uFE0F\"; // Variation selector, follows heart and others\nvar EMOJI_JOINER = \"\\u200D\"; // zero-width joiner\nvar OBJECT_REPLACEMENT = \"\\uFFFC\"; // whitespace placeholder that sometimes appears in rich text editors\n\nvar tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2() {\n  var customSchemes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  var groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  var Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\n  tt(Start, '「', LEFTCORNERBRACKET);\n  tt(Start, '」', RIGHTCORNERBRACKET);\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  tt(Start, '・', FULLWIDTHMIDDLEDOT);\n  var Num = tr(Start, DIGIT, NUM, _defineProperty({}, numeric, true));\n  tr(Num, DIGIT, Num);\n  var Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, _defineProperty({}, asciinumeric, true));\n  var Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, _defineProperty({}, alphanumeric, true));\n\n  // State which emits a word token\n  var Word = tr(Start, ASCII_LETTER, WORD, _defineProperty({}, ascii, true));\n  tr(Word, DIGIT, Asciinumeric);\n  tr(Word, ASCII_LETTER, Word);\n  tr(Asciinumeric, DIGIT, Asciinumeric);\n  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  var UWord = tr(Start, LETTER, UWORD, _defineProperty({}, alpha, true));\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, DIGIT, Alphanumeric);\n  tr(UWord, LETTER, UWord);\n  tr(Alphanumeric, DIGIT, Alphanumeric);\n  tr(Alphanumeric, ASCII_LETTER); // Non-accepting\n  tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  var Nl = tt(Start, LF, NL, _defineProperty({}, whitespace, true));\n  var Cr = tt(Start, CR, WS, _defineProperty({}, whitespace, true));\n  var Ws = tr(Start, SPACE, WS, _defineProperty({}, whitespace, true));\n  tt(Start, OBJECT_REPLACEMENT, Ws);\n  tt(Cr, LF, Nl); // \\r\\n\n  tt(Cr, OBJECT_REPLACEMENT, Ws);\n  tr(Cr, SPACE, Ws);\n  tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\n  tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n  tt(Ws, OBJECT_REPLACEMENT, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  var Emoji = tr(Start, EMOJI, EMOJI$1, _defineProperty({}, emoji, true));\n  tt(Emoji, '#'); // no transition, emoji regex seems to match #\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  var EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tt(EmojiJoiner, '#');\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  var wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];\n  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];\n  for (var i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (var _i = 0; _i < utlds.length; _i++) {\n    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort(function (a, b) {\n    return a[0] > b[0] ? 1 : -1;\n  });\n  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {\n    var sch = customSchemes[_i2][0];\n    var optionalSlashSlash = customSchemes[_i2][1];\n    var flags = optionalSlashSlash ? _defineProperty({}, scheme, true) : _defineProperty({}, slashscheme, true);\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: assign({\n      groups: groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {\n    return c.toLowerCase();\n  }));\n  var charCount = iterable.length; // <= len if there are emojis, etc\n  var tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  var cursor = 0;\n\n  // Cursor through the array-representation of the string\n  var charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    var state = start;\n    var nextState = null;\n    var tokenLength = 0;\n    var latestAccepting = null;\n    var sinceAccepts = -1;\n    var charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  var result = [];\n  var len = str.length;\n  var index = 0;\n  while (index < len) {\n    var first = str.charCodeAt(index);\n    var second = void 0;\n    var _char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(_char);\n    index += _char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  var next;\n  var len = input.length;\n  for (var i = 0; i < len - 1; i++) {\n    var _char2 = input[i];\n    if (state.j[_char2]) {\n      next = state.j[_char2];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[_char2] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  var words = [];\n  var stack = [];\n  var i = 0;\n  var digits = '0123456789';\n  while (i < encoded.length) {\n    var popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (var popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nvar defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts) {\n  var defaultRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var o = assign({}, defaults);\n  if (opts) {\n    o = assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  var ignoredTags = o.ignoreTags;\n  var uppercaseIgnoredTags = [];\n  for (var i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender: function defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check: function check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get: function get(key, operator, token) {\n    var isCallable = operator != null;\n    var option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (_typeof(option) === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj: function getObj(key, operator, token) {\n    var obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render: function render(token) {\n    var ir = token.render(this); // intermediate representation\n    var renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\nvar options = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  defaults: defaults,\n  Options: Options,\n  assign: assign\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString: function toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n   */\n  toHref: function toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString: function toFormattedString(options) {\n    var val = this.toString();\n    var truncate = options.get('truncate', val, this);\n    var formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref: function toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex: function startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex: function endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject: function toObject() {\n    var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.defaultProtocol;\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject: function toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate: function validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render: function render(options) {\n    var token = this;\n    var href = this.toHref(options.get('defaultProtocol'));\n    var formattedHref = options.get('formatHref', href, this);\n    var tagName = options.get('tagName', href, token);\n    var content = this.toFormattedString(options);\n    var attributes = {};\n    var className = options.get('className', href, token);\n    var target = options.get('target', href, token);\n    var rel = options.get('rel', href, token);\n    var attrs = options.getObj('attributes', href, token);\n    var eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes[\"class\"] = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      assign(attributes, attrs);\n    }\n    return {\n      tagName: tagName,\n      attributes: attributes,\n      content: content,\n      eventListeners: eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  var Token = /*#__PURE__*/function (_MultiToken) {\n    function Token(value, tokens) {\n      var _this2;\n      _classCallCheck(this, Token);\n      _this2 = _callSuper(this, Token, [value, tokens]);\n      _this2.t = type;\n      return _this2;\n    }\n    _inherits(Token, _MultiToken);\n    return _createClass(Token);\n  }(MultiToken);\n  for (var p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nvar Email = createTokenClass('email', {\n  isLink: true,\n  toHref: function toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nvar Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nvar Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nvar Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref: function toHref() {\n    var scheme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.defaultProtocol;\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : \"\".concat(scheme, \"://\").concat(this.v);\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol: function hasProtocol() {\n    var tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\nvar multi = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MultiToken: MultiToken,\n  Base: MultiToken,\n  createTokenClass: createTokenClass,\n  Email: Email,\n  Text: Text,\n  Nl: Nl,\n  Url: Url\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\nvar makeState = function makeState(arg) {\n  return new State(arg);\n};\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1(_ref3) {\n  var groups = _ref3.groups;\n  // Types of characters the URL can definitely end in\n  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  var qsNonAccepting = [COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  var Start = makeState();\n  var Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  var Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  var LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  var LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  var EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  var EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  var Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  var EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  var EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  var DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  var DomainDot = tt(Domain, DOT); // domain followed by DOT\n  tt(DomainHyphen, HYPHEN, DomainHyphen);\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  var DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  var DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  var DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  var Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  var UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  var SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  var SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  var SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  var UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  tt(SchemeColon, QUERY, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  var bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // （）\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // 「」\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // 『』\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\n  ];\n\n  for (var i = 0; i < bracketPairs.length; i++) {\n    var _bracketPairs$i = _slicedToArray(bracketPairs[i], 2),\n      OPEN = _bracketPairs$i[0],\n      CLOSE = _bracketPairs$i[1];\n    var UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    var UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    var UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  var len = tokens.length;\n  var cursor = 0;\n  var multis = [];\n  var textTokens = [];\n  while (cursor < len) {\n    var state = start;\n    var secondState = null;\n    var nextState = null;\n    var multiLength = 0;\n    var latestAccepting = null;\n    var sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      var Multi = latestAccepting.t;\n      var subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  var startIdx = tokens[0].s;\n  var endIdx = tokens[tokens.length - 1].e;\n  var value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\nvar warn = typeof console !== 'undefined' && console && console.warn || function () {};\nvar warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nvar INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n  return INIT;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(\"linkifyjs: Invalid token plugin \".concat(plugin, \" (expects function)\"));\n  }\n  for (var i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(\"linkifyjs: token plugin \\\"\".concat(name, \"\\\" already registered - will be overwritten\"));\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register token plugin \\\"\".concat(name, \"\\\" \").concat(warnAdvice));\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(\"linkifyjs: Invalid plugin \".concat(plugin, \" (expects function)\"));\n  }\n  for (var i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(\"linkifyjs: plugin \\\"\".concat(name, \"\\\" already registered - will be overwritten\"));\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register plugin \\\"\".concat(name, \"\\\" \").concat(warnAdvice));\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} scheme\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme) {\n  var optionalSlashSlash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register custom scheme \\\"\".concat(scheme, \"\\\" \").concat(warnAdvice));\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(\"linkifyjs: incorrect scheme format.\\n1. Must only contain digits, lowercase ASCII letters or \\\"-\\\"\\n2. Cannot start or end with \\\"-\\\"\\n3. \\\"-\\\" cannot repeat\");\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (var i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (var _i3 = 0; _i3 < INIT.pluginQueue.length; _i3++) {\n    INIT.pluginQueue[_i3][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n  return INIT;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\ntokenize.scan = run$1; // for testing\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (type && _typeof(type) === 'object') {\n    if (opts) {\n      throw Error(\"linkifyjs: Invalid link type \".concat(type, \"; must be a string\"));\n    }\n    opts = type;\n    type = null;\n  }\n  var options = new Options(opts);\n  var tokens = tokenize(str);\n  var filtered = [];\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsV0FBVyxHQUFHLHN6SkFBc3pKO0FBQzEwSjtBQUNBLElBQU1DLFlBQVksR0FBRyxtbUJBQW1tQjs7QUFFeG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsTUFBTSxHQUFHLFNBQVRBLE1BQU1BLENBQUlDLE1BQU0sRUFBRUMsVUFBVSxFQUFLO0VBQ3JDLEtBQUssSUFBTUMsR0FBRyxJQUFJRCxVQUFVLEVBQUU7SUFDNUJELE1BQU0sQ0FBQ0UsR0FBRyxDQUFDLEdBQUdELFVBQVUsQ0FBQ0MsR0FBRyxDQUFDO0VBQy9CO0VBQ0EsT0FBT0YsTUFBTTtBQUNmLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQU1HLE9BQU8sR0FBRyxTQUFTO0FBQ3pCLElBQU1DLEtBQUssR0FBRyxPQUFPO0FBQ3JCLElBQU1DLEtBQUssR0FBRyxPQUFPO0FBQ3JCLElBQU1DLFlBQVksR0FBRyxjQUFjO0FBQ25DLElBQU1DLFlBQVksR0FBRyxjQUFjO0FBQ25DLElBQU1DLE1BQU0sR0FBRyxRQUFRO0FBQ3ZCLElBQU1DLEtBQUssR0FBRyxPQUFPO0FBQ3JCLElBQU1DLE1BQU0sR0FBRyxRQUFRO0FBQ3ZCLElBQU1DLFdBQVcsR0FBRyxhQUFhO0FBQ2pDLElBQU1DLFVBQVUsR0FBRyxZQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxhQUFhQSxDQUFDQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtFQUNuQyxJQUFJLEVBQUVELElBQUksSUFBSUMsTUFBTSxDQUFDLEVBQUU7SUFDckJBLE1BQU0s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QUdrSCxNQUFNLENBQUM3SCxNQUFNLEVBQUVXLENBQUMsRUFBRSxFQUFFO0lBQ3RDLElBQU1iLEtBQUssR0FBRytILE1BQU0sQ0FBQ2xILENBQUMsQ0FBQztJQUN2QixJQUFJYixLQUFLLENBQUN1TSxNQUFNLEtBQUssQ0FBQ1MsSUFBSSxJQUFJaE4sS0FBSyxDQUFDVixDQUFDLEtBQUswTixJQUFJLENBQUMsSUFBSVosT0FBTyxDQUFDWCxLQUFLLENBQUN6TCxLQUFLLENBQUMsRUFBRTtNQUN2RTJTLFFBQVEsQ0FBQ2hULElBQUksQ0FBQ0ssS0FBSyxDQUFDbU4saUJBQWlCLENBQUNmLE9BQU8sQ0FBQyxDQUFDO0lBQ2pEO0VBQ0Y7RUFDQSxPQUFPdUcsUUFBUTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM1UixJQUFJQSxDQUFDa0gsR0FBRyxFQUFlO0VBQUEsSUFBYitFLElBQUksR0FBQS9NLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHLElBQUk7RUFDNUIsSUFBTThILE1BQU0sR0FBR3lLLFFBQVEsQ0FBQ3ZLLEdBQUcsQ0FBQztFQUM1QixPQUFPRixNQUFNLENBQUM3SCxNQUFNLEtBQUssQ0FBQyxJQUFJNkgsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDd0UsTUFBTSxLQUFLLENBQUNTLElBQUksSUFBSWpGLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ3pJLENBQUMsS0FBSzBOLElBQUksQ0FBQztBQUNuRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpbnN0aW5jdGh1YlxcY29kZV9wcm9qZWN0c1xcbnBtXFxpbnN0aW5jdGh1Yi1yZWFjdC11aVxcbm9kZV9tb2R1bGVzXFxsaW5raWZ5anNcXGRpc3RcXGxpbmtpZnkuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEIERPIE5PVCBFRElUIERJUkVDVExZXG4vLyBTZWUgdXBkYXRlLXRsZHMuanMgZm9yIGVuY29kaW5nL2RlY29kaW5nIGZvcm1hdFxuLy8gaHR0cHM6Ly9kYXRhLmlhbmEub3JnL1RMRC90bGRzLWFscGhhLWJ5LWRvbWFpbi50eHRcbmNvbnN0IGVuY29kZWRUbGRzID0gJ2FhYTFycDNiYjBvdHQzdmllNGMxbGUyb2dhZG81dWRoYWJpN2MwYWRlbXk1Y2VudHVyZTZvdW50YW50MHM5bzF0b3I0ZDBzMXVsdDRlMGcxcm8ydG5hNGYwbDFyaWNhNWcwYWtoYW41ZW5jeTVpMGcxcmJ1czNmb3JjZTV0ZWw1a2RuM2wwaWJhYmE0cGF5NGxmaW5hbno2c3RhdGU1eTJzYWNlM3RvbTVtMGF6b240ZXJpY2FuZXhwcmVzczdmYW1pbHkxMXgyZmFtM2ljYTNzdGVyZGFtOG5hbHl0aWNzN2Ryb2lkNXF1YW40ejJvMGwycGFydG1lbnRzOHAwbGU0cTB1YXJlbGxlOHIwYWIxbWNvNGNoaTNteTJwYTJ0MGUzczBkYTJpYTJzb2NpYXRlczl0MGhsZXRhNXRvcm5leTd1MGN0aW9uNWRpMGJsZTNvM3Nwb3N0NXRob3IzbzBzNHcwczJ4MGEyejB1cmU1YmEwYnkyaWR1M25hbWV4NGQxazJyMGNlbG9uYTVsYXljYXJkNHM1ZWZvb3Q1Z2FpbnM2c2ViYWxsNWtldGJhbGw4dWhhdXM1eWVybjViMGMxdDF2YTNjZzFuMmQxZTBhdHMydXR5NGVyMm50bGV5NXJsaW40c3QwYnV5NXQyZjFnMWgwYXJ0aTVpMGJsZTNkMWtlMm5nMG8zbzF6MmoxbGFjazBmcmlkYXk5b2NrYnVzdGVyOGcxb21iZXJnN3VlM20wczF3Mm4wcHBhcmliYXM5bzBhdHMzZWhyaW5nZXI4ZmEybTFuZDJvMGswaW5nNXNjaDJ0aWsyb240dDF1dGlxdWU2eDJyMGFkZXNjbzZpZGdlc3RvbmU5b2Fkd2F5NWtlcjN0aGVyNXVzc2VsczdzMXQxdWlsZDBlcnM2c2luZXNzNnkxenozdjF3MXkxejBoM2NhMGIxZmUybDBsMXZpbmtsZWluOW0wZXJhM3Aybm9uM3BldG93bjVpdGFsMG9uZThyMGF2YW40ZHMyZTBlcjBzNHMyc2ExZTFoMWlubzR0MGVyaW5nNWhvbGljN2JhMW4xcmUzYzFkMWVudGVyNG8xcm4zZjBhMWQyZzFoMGFuZWwybmVsNHJpdHk0c2UydDJlYXAzaW50YWk1cmlzdG1hczZvbWU0dXJjaDVpMHByaWFuaTZyY2xlNHNjbzN0YWRlbDRpMGMyeTNrMWwwYWltczRlYW5pbmc2aWNrMm5pYzFxdWU2b3RoaW5nNXVkM3ViMG1lZDZtMW4xbzBhY2gzZGVzM2ZmZWU0bGxlZ2U0b2duZTVtMG1iYW5rNHVuaXR5NnBhbnkycmUzdXRlcjVzZWM0bmRvczNzdHJ1Y3Rpb244dWx0aW5nN3RhY3QzcmFjdG9yczlva2luZzRsMXAycnNpY2E1dW50cnk0cG9uMHM0cnNlczZwYTJyMGVkaXQwY2FyZDR1bmlvbjlpY2tldDVvd24zczF1aXNlMHM2dTBpc2luZWxsYTl2MXcxeDF5MG1ydTNvdTN6MmRhZDFuY2UzdGExZTFpbmczc3VuNHkyY2xrM2RzMmUwYWwwZXIyczNncmVlNGxpdmVyeTVsMW9pdHRlNXRhM21vY3JhdDZudGFsMmlzdDVzaTBnbjR2MmhsMmlhbW9uZHM2ZXQyZ2l0YWw1cmVjdDBvcnk3c2NvdW50M3ZlcjVoMnkyajFrMW0xbnAybzBjczF0b3I0ZzFtYWluczV0MXdubG9hZDdyaXZlNHR2MnViYWkzbmxvcDRwb250NHJiYW41dmFnMnIyejJlYXJ0aDN0MmMwbzJkZWthM3UwY2F0aW9uOGUxZzFtYWlsM2VyY2s1bmVyZ3k0Z2luZWVyMGluZzl0ZXJwcmlzZXMxMHBzb240cXVpcG1lbnQ4cjBpY3Nzb242bmkzczBxMXRhdGU1dDF1MHJvdmlzaW9uOHMydmVudHM1eGNoYW5nZTZwZXJ0M29zZWQ0cmVzczV0cmFzcGFjZTEwZmFnZTJpbDFyd2luZHM2dGgzbWlseTRuMHMycm0wZXJzNXNoaW9uNHQzZWRleDNlZGJhY2s2cnJhcmkzZXJvNmkwZGVsaXR5NW8ybG0ybmFsMW5jZTFpYWw3cmUwc3RvbmU2bWRhbGU2c2gwaW5nNXQwbmVzczZqMWsxbGlja3IzZ2h0czRyMm9yaXN0NHdlcnM1eTJtMW8wbzBkMXRiYWxsNnJkMWV4MnNhbGU0dW0zdW5kYXRpb244eDJyMGVlMXNlbml1czdsMW9nYW5zNG50aWVyN3RyMnVqaXRzdTVuMGQycm5pdHVyZTd0Ym9sNXlpM2dhMGwwbGVyeTNvMXVwNG1lMHMzcDFyZGVuNHkyYjBpejNkMG4yZTBhMW50MGluZzVvcmdlNWYxZzBlZTNoMWkwZnQwczN2ZXMyaW5nNWwwYXNzM2Uxb2JhbDJvNG0wYWlsM2JoMm8xeDJuMW9kYWRkeTVsZDBwb2ludDZmMm8wZHllYXI1ZzBsZTRwMXQxdjJwMXExcjBhaW5nZXI1cGhpY3M1dGlzNGVlbjNpcGUzb2Nlcnk0dXA0czF0MXUwY2NpM2dlMmlkZTJ0YXJzNXJ1M3cxeTJoYWlyMm1idXJnNW5nb3V0NXVzM2JvMmRmYzBiYW5rN2VhbHRoMGNhcmU4bHAxc2lua2k2cmUxbWVzNWlwaG9wNHNhbWl0c3U3dGFjaGk1djJrMHQybTFuMW9ja2V5NGxkaW5nczVpZGF5NW1lZGVwb3Q1Z29vZHM1czBlbnNlN25kYTNyc2Uzc3BpdGFsNXQwaW5nNXQwZWxzM21haWw1dXNlM3cycjFzYmMzdDF1MGdoZXM1eWF0dDN1bmRhaTdpYm0yY2JjMmUxdTJkMWUwZWUzZm0ya2FubzRsMW0wYW1hdDRkYjJtbzBiaWxpZW45bjBjMWR1c3RyaWVzOGZpbml0aTVvMmcxazFzdGl0dXRlNnVyYW5jZTRlNHQwZXJuYXRpb25hbDEwdWl0NHZlc3RtZW50czEwbzFwaXJhbmdhN3ExcjBpc2g0czBtYWlsaTV0MGFuYnVsN3QwYXUydjNqYWd1YXI0dmEzY2IyZTBlcDJ0enQzd2Vscnk2aW8ybGwybTBwMm5qMm8wYnMxdXJnNHQxeTJwMG1vcmdhbjZyczN1ZWdvczRuaXBlcjdrYXVmZW41ZGRpM2UwcnJ5aG90ZWxzNmxvZ2lzdGljczlwcm9wZXJ0aWVzMTRmaDJnMWgxaTBhMWRzMm0xbmRsZTR0Y2hlbjV3aTNtMW4xb2VsbjNtYXRzdTVzaGVyNXAwbWcybjJyMGQxZWQzdW9rZ3JvdXA4dzF5MG90bzR6MmxhMGNhaXhhNW1ib3JnaGluaThlcjNuY2FzdGVyNmQwcm92ZXI2eGVzczVzYWxsZTV0MGlubzNyb2JlNXcweWVyNWIxYzFkczJlYXNlM2NsZXJjNWZyYWs0Z2FsMm8yeHVzNGdidDNpMGRsMmZlMGluc3VyYW5jZTlzdHlsZTdnaHRpbmc2a2UybGx5M21pdGVkNG8ybmNvbG40azJwc3kzdmUxaW5nNWsxbGMxcDJvYW4wczNja2VyM3VzM2wxbmRvbjR0dGUxbzN2ZTNwbDBmaW5hbmNpYWwxMXIxczF0MGQwYTN1MG5kYmVjazZ4ZTF1cnk1djF5Mm1hMGRyaWQ0aWYxc29uNGtldXA0bjBhZ2VtZW50N2dvM3AxcmtldDBpbmczczRyaW90dDVzaGFsbHM3dHRlbDViYTJjMGtpbnNleTdkMWUwZDBpYTNldDJsYm91cm5lN21lMW9yaWFsNm4wdTJyY2ttc2Q3ZzFoMWlhbWkzY3Jvc29mdDdsMW5pMXQydDBzdWJpc2hpOWsxbDBiMXMybTBhMm4xbzBiaTBsZTRkYTJlMWkxbTFuYXNoM2V5MnN0ZXI1cm1vbjN0Z2FnZTZzY293NHRvMHJjeWNsZXM5djBpZTRwMXExcjFzMGQydDBuMXIydTBzZXVtM2ljNHYxdzF4MXkxejJuYTBiMWdveWE0bWUydnkzYmEyYzFlMGMxdDBiYW5rNGZsaXg0d29yazV1c3RhcjV3MHMyeHQwZGlyZWN0N3VzNGYwbDJnMG8yaGsyaTBjbzJrZTFvbjNuamEzc3NhbjF5NWwxbzBraWEzcnRvbjR3MHJ1ejN0djRwMXIwYTF3MnR0MnUxeWMyejJvYmkxc2VydmVyN2ZmaWNlNWtpbmF3YTZsYXlhbjBncm91cDlsbzNtMGVnYTRuZTFnMWwwaW5lNW9vMnBlbjNyYWNsZTNuZ2U0ZzBhbmljNWlnaW5zNnNha2E0dHN1a2E0dDJ2aDNwYTBnZTJuYXNvbmljN3JpczJzMXRuZXJzNHMxeTN5MmNjdzNlMHQyZjBpemVyNWcxaDBhcm1hY3k2ZDFpbGlwczVvbmUydG8wZ3JhcGh5NnM0eXNpbzVpY3MxdGV0MnVyZXM2ZDFuMGcxazJvbmVlcjV6emE0azFsMGFjZTJ5MHN0YXRpb245dW1iaW5nNXMzbTFuMGMyb2hsMmtlcjNsaXRpZTVybjJzdDNyMGFtZXJpY2E2eGkzZXNzM2ltZTNvMGQwdWN0aW9uczhmMWdyZXNzaXZlOG1vMnBlcnRpZXMzeTV0ZWN0aW9uOHUwZGVudGlhbDlzMXQxdWIydzBjMnkycWExcG9uM3VlYmVjM3N0NXJhY2luZzRkaW80ZTBhZDFsZXN0YXRlNnRvcjJ5NGNpcGVzNWQwc3RvbmU1dW1icmVsbGE5aGFiM2lzZTBuM3QybGlhbmNlNm4wdDBhbHM1cGFpcjNvcnQzdWJsaWNhbjhzdDBhdXJhbnQ4dmlldzBzNXhyb3RoNmljaDBhcmRsaTZvaDNsMW8xcDJvMGNrczNkZW8zZ2VyczRvbTNzMHZwM3UwZ2J5M2hyMm4ydzBlMnl1a3l1NnNhMGFybGFuZDZmZTB0eTRrdXJhNGxlMW9uM21zY2x1YjR1bmc1bmR2aWswY29yb21hbnQxMm9maTRwMXJsMnMxdmUyeG8zYjBpMXMyYzBiMWhhZWZmbGVyN21pZHQ0b2xhcnNoaXBzOG9sM3VsZTN3YXJ6NWllbmNlNW90M2QxZTBhcmNoM3QyY3VyZTFpdHk2ZWsybGVjdDRuZXIzcnZpY2VzNnZlbjN3MXgweTNmcjJnMWgwYW5ncmlsYTZycDNlbGwzaWExa3NoYTVvZXMycDBwaW5nNXVqaTN3M2kwbGsybmExZ2xlczV0ZTNqMWswaTBuMnkwcGU0bDBpbmc0bTBhcnQzaWxlNG4wY2YzbzBjY2VyM2lhbDRmdGJhbms0d2FyZTZodTJsYXIydXRpb25zN25nMXkyeTJwYTBjZTNvcnQydDNyMGwyczF0MGFkYTJwbGVzNHIxdGViYW5rNGZhcm03YzBncm91cDZvY2tob2xtNnJhZ2UzZTNyZWFtNHVkaW8yeTN5bGU0dTBja3MzcHBsaWVzM3kyb3J0NXJmMWdlcnk1enVraTV2MXdhdGNoNGlzczR4MXkwZG5leTRzdGVtczZ6MnRhYjFpcGVpNGxrMm9iYW80cmdldDR0YW1vdG9yczZyMnRvbzR4MGkzYzBpMmQwazJlYW0yY2gwbm9sb2d5OGwxbWFzZWs1bm5pczR2YTNmMWcxaDBkMWVhdGVyMnJlNmlhYTJja2V0czVlbmRhNHBzMnJlczJvbDRqMG1heHg0eDJrMG1heHg1bDFtMGFsbDRuMW8wZGF5M2t5bzNvbHMzcDFyYXkzc2hpYmE1dGFsM3VyczN3bjJ5b3RhM3MzcjBhZGUxaW5nNGluaW5nNXZlbDBlcnMwaW5zdXJhbmNlMTZ1c3QzdjJ0MXViZTJpMW5lczNzaHU0djBzMncxejJ1YTFiYW5rM3MyZzFrMW5pY29tM3ZlcnNpdHk4bzJvbDJwczJzMXkxejJ2YTBjYXRpb25zN25hMWd1YXJkN2MxZTBnYXMzbnR1cmVzNnJpc2lnbjVtw7ZnZW5zYmVyYXRlcjJ1bmcxNHNpY2hlcnVuZzEwdDJnMWkwYWplczRkZW8zZzFraW5nNGxsYXM0bjFwMXJnaW40c2ExaW9uNHZhMW8zbGFhbmRlcmVuOW4xb2RrYTNsdm8zdGUxaW5nM28yeWFnZTV1MndhbGVzMm1hcnQ0dGVyNG5nMGdvdTV0Y2gwZXM2ZWF0aGVyMGNoYW5uZWwxMmJjYW0zZXIyc2l0ZTVkMGRpbmc1aWJvMnIzZjFob3N3aG82aWVuMmtpMmxsaWFtaGlsbDluMGRvd3M0ZTFuZXJzNm1lMm9sdGVyc2tsdXdlcjExb2RzaWRlNnJrMHMybGQzdzJzMXRjMWYzeGJveDNlcm94NGlodWFuNG4yeHgyeXozeWFjaHRzNGhvbzNtYXh1bjVuZGV4NWUxb2RvYmFzaGk3Z2Eya29oYW1hNnUwdHViZTZ0MXVuM3phMHBwb3M0cmEzZXJvM2lwMm0xb25lM3VlcmljaDZ3Mic7XG4vLyBJbnRlcm5hdGlvbmFsaXplZCBkb21haW4gbmFtZXMgY29udGFpbmluZyBub24tQVNDSUlcbmNvbnN0IGVuY29kZWRVdGxkcyA9ICfOtc67Mc+FMtCx0LMx0LXQuzPQtNC10YLQuDTQtdGOMtC60LDRgtC+0LvQuNC6NtC+0Lwz0LzQutC0MtC+0L0x0YHQutCy0LA20L7QvdC70LDQudC9NdGA0LMz0YDRg9GBMtGEMtGB0LDQudGCM9GA0LEz0YPQutGAM9Kb0LDQtzPVsNWh1bUz15nXqdeo15DXnDXXp9eV150z2KfYqNmI2LjYqNmKNdix2KfZhdmD2Yg12YTYp9ix2K/ZhjTYqNit2LHZitmGNdis2LLYp9im2LE12LPYudmI2K/ZitipNti52YTZitin2YY12YXYutix2Kg12YXYp9ix2KfYqjXbjNix2KfZhjXYqNin2LHYqjLYstin2LE02YrYqtmDM9q+2KfYsdiqNdiq2YjZhtizNNiz2YjYr9in2YYz2LHZitipNdi02KjZg9ipNNi52LHYp9mCMtioMtmF2KfZhjTZgdmE2LPYt9mK2YY22YLYt9ixM9mD2KfYq9mI2YTZitmDNtmI2YUz2YXYtdixMtmE2YrYs9mK2Kc12YjYsdmK2KrYp9mG2YrYpzfZgti5NNmH2YXYsdin2Yc12b7Yp9qp2LPYqtin2YY32oDYp9ix2Ko04KSV4KWJ4KSuM+CkqOClh+CknzPgpK3gpL7gpLDgpKQw4KSu4KWNM+Cli+CkpDXgpLjgpILgpJfgpKDgpKg14Kas4Ka+4KaC4Kay4Ka+NeCmreCmvuCmsOCmpDLgp7DgpqQ04Kit4Ki+4Kiw4KikNOCqreCqvuCqsOCqpDTgrK3grL7grLDgrKQ04K6H4K6o4K+N4K6k4K6/4K6v4K6+NuCusuCumeCvjeCuleCviDbgrprgrr/grpngr43grpXgrqrgr43grqrgr4LgrrDgr40xMeCwreCwvuCwsOCwpOCxjTXgsq3gsr7gsrDgsqQ04LSt4LS+4LSw4LSk4LSCNeC2veC2guC2muC3jzTguITguK3guKEz4LmE4LiX4LiiM+C6peC6suC6pzPhg5Lhg5Qy44G/44KT44GqM+OCouODnuOCvuODszTjgq/jg6njgqbjg4k044Kw44O844Kw44OrNOOCs+ODoDLjgrnjg4jjgqIz44K744O844OrM+ODleOCoeODg+OCt+ODp+ODszbjg53jgqTjg7Pjg4g05LiW55WMMuS4reS/oTHlm70x5ZyLMeaWh+e9kTPkuprpqazpgIoz5LyB5LiaMuS9m+WxsTLkv6Hmga8y5YGl5bq3MuWFq+WNpjLlhazlj7gx55uKMuWPsOa5vjHngaMy5ZWG5Z+OMeW6lzHmoIcy5ZiJ6YeMMOWkp+mFkuW6lzXlnKjnur8y5aSn5ou/MuWkqeS4u+aVmTPlqLHkuZAy5a626Zu7MuW5v+S4nDLlvq7ljZoy5oWI5ZaEMuaIkeeIseS9oDPmiYvmnLoy5oub6IGYMuaUv+WKoTHlupwy5paw5Yqg5Z2hMumXuzLml7blsJoy5pu457GNMuacuuaehDLmt6HpqazplKEz5ri45oiPMua+s+mWgDLngrnnnIsy56e75YqoMue7hOe7h+acuuaehDTnvZHlnYAx5bqXMeermTHnu5wy6IGU6YCaMuiwt+atjDLotK3niaky6YCa6LKpMumbhuWbojLpm7voqIrnm4jnp5E06aOe5Yip5rWmM+mjn+WTgTLppJDljoUy6aaZ5qC86YeM5ouJM+a4rzLri7frhLcx7Lu0MuyCvOyEsTLtlZzqta0yJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICogQHRlbXBsYXRlIEJcbiAqIEBwYXJhbSB7QX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0J9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0EgJiBCfVxuICovXG5jb25zdCBhc3NpZ24gPSAodGFyZ2V0LCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICB0YXJnZXRba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSBnZW5lcmF0aW9uIHV0aWxpdGllc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBbZ3JvdXA6IHN0cmluZ106IHRydWUgfX0gRmxhZ3NcbiAqL1xuXG4vLyBLZXlzIGluIHNjYW5uZXIgQ29sbGVjdGlvbnMgaW5zdGFuY2VzXG5jb25zdCBudW1lcmljID0gJ251bWVyaWMnO1xuY29uc3QgYXNjaWkgPSAnYXNjaWknO1xuY29uc3QgYWxwaGEgPSAnYWxwaGEnO1xuY29uc3QgYXNjaWludW1lcmljID0gJ2FzY2lpbnVtZXJpYyc7XG5jb25zdCBhbHBoYW51bWVyaWMgPSAnYWxwaGFudW1lcmljJztcbmNvbnN0IGRvbWFpbiA9ICdkb21haW4nO1xuY29uc3QgZW1vamkgPSAnZW1vamknO1xuY29uc3Qgc2NoZW1lID0gJ3NjaGVtZSc7XG5jb25zdCBzbGFzaHNjaGVtZSA9ICdzbGFzaHNjaGVtZSc7XG5jb25zdCB3aGl0ZXNwYWNlID0gJ3doaXRlc3BhY2UnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzIHRvIHJlZ2lzdGVyIGluXG4gKiBAcmV0dXJucyB7VFtdfSBDdXJyZW50IGxpc3Qgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyR3JvdXAobmFtZSwgZ3JvdXBzKSB7XG4gIGlmICghKG5hbWUgaW4gZ3JvdXBzKSkge1xuICAgIGdyb3Vwc1tuYW1lXSA9IFtdO1xuICB9XG4gIHJldHVybiBncm91cHNbbmFtZV07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBhZGRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3Vwc1xuICogQHBhcmFtIHtGbGFnc30gZmxhZ3NcbiAqL1xuZnVuY3Rpb24gYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcykge1xuICBpZiAoZmxhZ3NbbnVtZXJpY10pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWldKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWludW1lcmljXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYV0pIHtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYWxwaGFudW1lcmljXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1tlbW9qaV0pIHtcbiAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gZmxhZ3MpIHtcbiAgICBjb25zdCBncm91cCA9IHJlZ2lzdGVyR3JvdXAoaywgZ3JvdXBzKTtcbiAgICBpZiAoZ3JvdXAuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgIGdyb3VwLnB1c2godCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBjaGVja1xuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcmV0dXJucyB7RmxhZ3N9IGdyb3VwIGZsYWdzIHRoYXQgY29udGFpbiB0aGlzIHRva2VuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzRm9yVG9rZW4odCwgZ3JvdXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGMgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3Vwc1tjXS5pbmRleE9mKHQpID49IDApIHtcbiAgICAgIHJlc3VsdFtjXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtudWxsIHwgVCB9IFRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZSBhIGJhc2ljIHN0YXRlIG1hY2hpbmUgc3RhdGUuIGogaXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVyIHRyYW5zaXRpb25zLFxuICoganIgaXMgdGhlIGxpc3Qgb2YgcmVnZXgtbWF0Y2ggdHJhbnNpdGlvbnMsIGpkIGlzIHRoZSBkZWZhdWx0IHN0YXRlIHRvXG4gKiB0cmFuc2l0aW9uIHRvIHQgaXMgdGhlIGFjY2VwdGluZyB0b2tlbiB0eXBlLCBpZiBhbnkuIElmIHRoaXMgaXMgdGhlIHRlcm1pbmFsXG4gKiBzdGF0ZSwgdGhlbiBpdCBkb2VzIG5vdCBlbWl0IGEgdG9rZW4uXG4gKlxuICogVGhlIHRlbXBsYXRlIHR5cGUgVCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGlzIHN0YXRlIGFjY2VwdHMuIFRoaXNcbiAqIHNob3VsZCBiZSBhIHN0cmluZyAoc3VjaCBhcyBvZiB0aGUgdG9rZW4gZXhwb3J0cyBpbiBgdGV4dC5qc2ApIG9yIGFcbiAqIE11bHRpVG9rZW4gc3ViY2xhc3MgKGZyb20gYG11bHRpLmpzYClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdG9rZW5dIFRva2VuIHRoYXQgdGhpcyBzdGF0ZSBlbWl0c1xuICovXG5mdW5jdGlvbiBTdGF0ZSh0b2tlbiA9IG51bGwpIHtcbiAgLy8gdGhpcy5uID0gbnVsbDsgLy8gREVCVUc6IFN0YXRlIG5hbWVcbiAgLyoqIEB0eXBlIHt7IFtpbnB1dDogc3RyaW5nXTogU3RhdGU8VD4gfX0gaiAqL1xuICB0aGlzLmogPSB7fTsgLy8gSU1QTEVNRU5UQVRJT04gMVxuICAvLyB0aGlzLmogPSBbXTsgLy8gSU1QTEVNRU5UQVRJT04gMlxuICAvKiogQHR5cGUge1tSZWdFeHAsIFN0YXRlPFQ+XVtdfSBqciAqL1xuICB0aGlzLmpyID0gW107XG4gIC8qKiBAdHlwZSB7P1N0YXRlPFQ+fSBqZCAqL1xuICB0aGlzLmpkID0gbnVsbDtcbiAgLyoqIEB0eXBlIHs/VH0gdCAqL1xuICB0aGlzLnQgPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBTY2FubmVyIHRva2VuIGdyb3Vwc1xuICogQHR5cGUgQ29sbGVjdGlvbnM8c3RyaW5nPlxuICovXG5TdGF0ZS5ncm91cHMgPSB7fTtcblN0YXRlLnByb3RvdHlwZSA9IHtcbiAgYWNjZXB0cygpIHtcbiAgICByZXR1cm4gISF0aGlzLnQ7XG4gIH0sXG4gIC8qKlxuICAgKiBGb2xsb3cgYW4gZXhpc3RpbmcgdHJhbnNpdGlvbiBmcm9tIHRoZSBnaXZlbiBpbnB1dCB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICogRG9lcyBub3QgbXV0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgY2hhcmFjdGVyIG9yIHRva2VuIHR5cGUgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcmV0dXJucyB7P1N0YXRlPFQ+fSB0aGUgbmV4dCBzdGF0ZSwgaWYgYW55XG4gICAqL1xuICBnbyhpbnB1dCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qW2lucHV0XTtcbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmpyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWdleCA9IHN0YXRlLmpyW2ldWzBdO1xuICAgICAgY29uc3QgbmV4dFN0YXRlID0gc3RhdGUuanJbaV1bMV07IC8vIG5vdGU6IG1pZ2h0IGJlIGVtcHR5IHRvIHByZXZlbnQgZGVmYXVsdCBqdW1wXG4gICAgICBpZiAobmV4dFN0YXRlICYmIHJlZ2V4LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vd2hlcmUgbGVmdCB0byBqdW1wISBSZXR1cm4gZGVmYXVsdCwgaWYgYW55XG4gICAgcmV0dXJuIHN0YXRlLmpkO1xuICB9LFxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3RhdGUgaGFzIGEgdHJhbnNpdGlvbiBmb3IgdGhlIGdpdmVuIGlucHV0LiBTZXQgdGhlIHNlY29uZFxuICAgKiBhcmd1bWVudCB0byB0cnVlIHRvIG9ubHkgbG9vayBmb3IgYW4gZXhhY3QgbWF0Y2ggKGFuZCBub3QgYSBkZWZhdWx0IG9yXG4gICAqIHJlZ3VsYXItZXhwcmVzc2lvbi1iYXNlZCB0cmFuc2l0aW9uKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICogQHBhcmFtIHtib29sZWFufSBleGFjdE9ubHlcbiAgICovXG4gIGhhcyhpbnB1dCwgZXhhY3RPbmx5ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZXhhY3RPbmx5ID8gaW5wdXQgaW4gdGhpcy5qIDogISF0aGlzLmdvKGlucHV0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRyYW5zaXRpb24gYWxsXCI7IGNyZWF0ZSBhIHRyYW5zaXRpb24gZnJvbSB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICogaW4gdGhlIGdpdmVuIGxpc3QgdG8gdGhlIHNhbWUgZmluYWwgcmVzdWx0aW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dHMgR3JvdXAgb2YgaW5wdXRzIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uPFQ+IHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzXG4gICAqL1xuICB0YShpbnB1dHMsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50dChpbnB1dHNbaV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgcmVnZXhwIHRyYW5zaXRpb25cIjsgZGVmaW5lcyBhIHRyYW5zaXRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgdG9rZW4gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIHRyYW5zaXRpb24gKHBvcHVsYXRlIGZpcnN0KVxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRva2VuIHdpdGggbWF5YmUgdG9rZW4gZ3JvdXBzXG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUobmV4dCk7XG4gICAgICBpZiAoZmxhZ3MgJiYgZ3JvdXBzKSB7XG4gICAgICAgIGFkZFRvR3JvdXBzKG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmpyLnB1c2goW3JlZ2V4cCwgbmV4dFN0YXRlXSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvbnNcIiwgd2lsbCB0YWtlIGFzIG1hbnkgc2VxdWVudGlhbCB0cmFuc2l0aW9ucyBhc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBpbnB1dCBhbmQgcmV0dXJucyB0aGVcbiAgICogcmVzdWx0aW5nIGZpbmFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudHQoaW5wdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUudHQoaW5wdXRbbGVuIC0gMV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uXCIsIHRoaXMgaXMgYSBtZXRob2QgZm9yIGJ1aWxkaW5nL3dvcmtpbmcgd2l0aFxuICAgKiBzdGF0ZSBtYWNoaW5lcy5cbiAgICpcbiAgICogSWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIGdpdmVuIGlucHV0LCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBJZiBhIHRva2VuIGlzIHNwZWNpZmllZCwgdGhhdCBzdGF0ZSB3aWxsIGVtaXQgdGhhdCB0b2tlbiB3aGVuIHJlYWNoZWQgYnlcbiAgICogdGhlIGxpbmtpZnkgZW5naW5lLlxuICAgKlxuICAgKiBJZiBubyBzdGF0ZSBleGlzdHMsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzb21lIGRlZmF1bHQgdHJhbnNpdGlvbnNcbiAgICogdGhhdCByZXNlbWJsZSBleGlzdGluZyBkZWZhdWx0IHRyYW5zaXRpb25zLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGlzIGdpdmVuIGZvciB0aGUgc2Vjb25kIGFyZ3VtZW50LCB0aGF0IHN0YXRlIHdpbGwgYmVcbiAgICogdHJhbnNpdGlvbmVkIHRvIG9uIHRoZSBnaXZlbiBpbnB1dCByZWdhcmRsZXNzIG9mIHdoYXQgdGhhdCBpbnB1dFxuICAgKiBwcmV2aW91c2x5IGRpZC5cbiAgICpcbiAgICogU3BlY2lmeSBhIHRva2VuIGdyb3VwIGZsYWdzIHRvIGRlZmluZSBncm91cHMgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8uXG4gICAqIFRoZSB0b2tlbiB3aWxsIGJlIGFkZGVkIHRvIGNvcnJlc3BvbmRpbmcgZW50aXJlcyBpbiB0aGUgZ2l2ZW4gZ3JvdXBzXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciwgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBncm91cHMgPSBncm91cHMgfHwgU3RhdGUuZ3JvdXBzO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIGV4aXN0aW5nIHN0YXRlIGdpdmVuLCBqdXN0IGEgYmFzaWMgdHJhbnNpdGlvblxuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgc3RhdGUualtpbnB1dF0gPSBuZXh0O1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGNvbnN0IHQgPSBuZXh0O1xuXG4gICAgLy8gVGFrZSB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSB1c3VhbCBkZWZhdWx0IG1lY2hhbmlzbXMgYW5kIHVzZSB0aGF0IGFzXG4gICAgLy8gYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgdGhlIG5leHQgc3RhdGVcbiAgICBsZXQgbmV4dFN0YXRlLFxuICAgICAgdGVtcGxhdGVTdGF0ZSA9IHN0YXRlLmdvKGlucHV0KTtcbiAgICBpZiAodGVtcGxhdGVTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHQpIHtcbiAgICAgIC8vIEVuc3VyZSBuZXdseSB0b2tlbiBpcyBpbiB0aGUgc2FtZSBncm91cHMgYXMgdGhlIG9sZCB0b2tlblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBpZiAobmV4dFN0YXRlLnQgJiYgdHlwZW9mIG5leHRTdGF0ZS50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGFsbEZsYWdzID0gYXNzaWduKGZsYWdzRm9yVG9rZW4obmV4dFN0YXRlLnQsIGdyb3VwcyksIGZsYWdzKTtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBhbGxGbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncykge1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGUudCA9IHQ7IC8vIG92ZXJ3cml0ZSBhbnl0aGluZyB0aGF0IHdhcyBwcmV2aW91c2x5IHRoZXJlXG4gICAgfVxuICAgIHN0YXRlLmpbaW5wdXRdID0gbmV4dFN0YXRlO1xuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgdG8gaW1wcm92ZSBtaW5pZmljYXRpb24gKG5vdCBleHBvcnRlZCBvdXRzaWRlIGxpbmtpZnlqcyBtb2R1bGUpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdGEgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50YShpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0ciA9IChzdGF0ZSwgcmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50cihyZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRzID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHMoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICovXG5jb25zdCB0dCA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnR0KGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuVGV4dCBUb2tlbnNcbklkZW50aWZpZXJzIGZvciB0b2tlbiBvdXRwdXRzIGZyb20gdGhlIHJlZ2V4cCBzY2FubmVyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEEgdmFsaWQgd2ViIGRvbWFpbiB0b2tlblxuY29uc3QgV09SRCA9ICdXT1JEJzsgLy8gb25seSBjb250YWlucyBhLXpcbmNvbnN0IFVXT1JEID0gJ1VXT1JEJzsgLy8gY29udGFpbnMgbGV0dGVycyBvdGhlciB0aGFuIGEteiwgdXNlZCBmb3IgSUROXG5jb25zdCBBU0NJSU5VTUVSSUNBTCA9ICdBU0NJSU5VTUVSSUNBTCc7IC8vIGNvbnRhaW5zIGEteiwgMC05XG5jb25zdCBBTFBIQU5VTUVSSUNBTCA9ICdBTFBIQU5VTUVSSUNBTCc7IC8vIGNvbnRhaW5zIG51bWJlcnMgYW5kIGxldHRlcnMgb3RoZXIgdGhhbiBhLXosIHVzZWQgZm9yIElETlxuXG4vLyBTcGVjaWFsIGNhc2Ugb2Ygd29yZFxuY29uc3QgTE9DQUxIT1NUID0gJ0xPQ0FMSE9TVCc7XG5cbi8vIFZhbGlkIHRvcC1sZXZlbCBkb21haW4sIHNwZWNpYWwgY2FzZSBvZiBXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFRMRCA9ICdUTEQnO1xuXG4vLyBWYWxpZCBJRE4gVExELCBzcGVjaWFsIGNhc2Ugb2YgVVdPUkQgKHNlZSB0bGRzLmpzKVxuY29uc3QgVVRMRCA9ICdVVExEJztcblxuLy8gVGhlIHNjaGVtZSBwb3J0aW9uIG9mIGEgd2ViIFVSSSBwcm90b2NvbC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGU6IGBtYWlsdG9gLFxuLy8gYGZpbGVgLCBhbmQgdXNlci1kZWZpbmVkIGN1c3RvbSBwcm90b2NvbHMuIExpbWl0ZWQgdG8gc2NoZW1lcyB0aGF0IGNvbnRhaW5cbi8vIG9ubHkgbGV0dGVyc1xuY29uc3QgU0NIRU1FID0gJ1NDSEVNRSc7XG5cbi8vIFNpbWlsYXIgdG8gU0NIRU1FLCBleGNlcHQgbWFrZXMgZGlzdGluY3Rpb24gZm9yIHNjaGVtZXMgdGhhdCBtdXN0IGFsd2F5cyBiZVxuLy8gZm9sbG93ZWQgYnkgYDovL2AsIG5vdCBqdXN0IGA6YC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGUgYGh0dHBgLCBgaHR0cHNgLFxuLy8gYGZ0cGAsIGBmdHBzYFxuY29uc3QgU0xBU0hfU0NIRU1FID0gJ1NMQVNIX1NDSEVNRSc7XG5cbi8vIEFueSBzZXF1ZW5jZSBvZiBkaWdpdHMgMC05XG5jb25zdCBOVU0gPSAnTlVNJztcblxuLy8gQW55IG51bWJlciBvZiBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IG5ld2xpbmVcbmNvbnN0IFdTID0gJ1dTJztcblxuLy8gTmV3IGxpbmUgKHVuaXggc3R5bGUpXG5jb25zdCBOTCA9ICdOTCc7IC8vIFxcblxuXG4vLyBPcGVuaW5nL2Nsb3NpbmcgYnJhY2tldCBjbGFzc2VzXG4vLyBUT0RPOiBSZW5hbWUgT1BFTiAtPiBMRUZUIGFuZCBDTE9TRSAtPiBSSUdIVCBpbiB2NSB0byBmaXQgd2l0aCBVbmljb2RlIG5hbWVzXG4vLyBBbHNvIHJlbmFtZSBhbmdsZSBicmFja2VzIHRvIExFU1NUSEFOIGFuZCBHUkVBVEVSIFRIQU5cbmNvbnN0IE9QRU5CUkFDRSA9ICdPUEVOQlJBQ0UnOyAvLyB7XG5jb25zdCBDTE9TRUJSQUNFID0gJ0NMT1NFQlJBQ0UnOyAvLyB9XG5jb25zdCBPUEVOQlJBQ0tFVCA9ICdPUEVOQlJBQ0tFVCc7IC8vIFtcbmNvbnN0IENMT1NFQlJBQ0tFVCA9ICdDTE9TRUJSQUNLRVQnOyAvLyBdXG5jb25zdCBPUEVOUEFSRU4gPSAnT1BFTlBBUkVOJzsgLy8gKFxuY29uc3QgQ0xPU0VQQVJFTiA9ICdDTE9TRVBBUkVOJzsgLy8gKVxuY29uc3QgT1BFTkFOR0xFQlJBQ0tFVCA9ICdPUEVOQU5HTEVCUkFDS0VUJzsgLy8gPFxuY29uc3QgQ0xPU0VBTkdMRUJSQUNLRVQgPSAnQ0xPU0VBTkdMRUJSQUNLRVQnOyAvLyA+XG5jb25zdCBGVUxMV0lEVEhMRUZUUEFSRU4gPSAnRlVMTFdJRFRITEVGVFBBUkVOJzsgLy8g77yIXG5jb25zdCBGVUxMV0lEVEhSSUdIVFBBUkVOID0gJ0ZVTExXSURUSFJJR0hUUEFSRU4nOyAvLyDvvIlcbmNvbnN0IExFRlRDT1JORVJCUkFDS0VUID0gJ0xFRlRDT1JORVJCUkFDS0VUJzsgLy8g44CMXG5jb25zdCBSSUdIVENPUk5FUkJSQUNLRVQgPSAnUklHSFRDT1JORVJCUkFDS0VUJzsgLy8g44CNXG5jb25zdCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUID0gJ0xFRlRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyDjgI5cbmNvbnN0IFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUID0gJ1JJR0hUV0hJVEVDT1JORVJCUkFDS0VUJzsgLy8g44CPXG5jb25zdCBGVUxMV0lEVEhMRVNTVEhBTiA9ICdGVUxMV0lEVEhMRVNTVEhBTic7IC8vIO+8nFxuY29uc3QgRlVMTFdJRFRIR1JFQVRFUlRIQU4gPSAnRlVMTFdJRFRIR1JFQVRFUlRIQU4nOyAvLyDvvJ5cblxuLy8gVmFyaW91cyBzeW1ib2xzXG5jb25zdCBBTVBFUlNBTkQgPSAnQU1QRVJTQU5EJzsgLy8gJlxuY29uc3QgQVBPU1RST1BIRSA9ICdBUE9TVFJPUEhFJzsgLy8gJ1xuY29uc3QgQVNURVJJU0sgPSAnQVNURVJJU0snOyAvLyAqXG5jb25zdCBBVCA9ICdBVCc7IC8vIEBcbmNvbnN0IEJBQ0tTTEFTSCA9ICdCQUNLU0xBU0gnOyAvLyBcXFxuY29uc3QgQkFDS1RJQ0sgPSAnQkFDS1RJQ0snOyAvLyBgXG5jb25zdCBDQVJFVCA9ICdDQVJFVCc7IC8vIF5cbmNvbnN0IENPTE9OID0gJ0NPTE9OJzsgLy8gOlxuY29uc3QgQ09NTUEgPSAnQ09NTUEnOyAvLyAsXG5jb25zdCBET0xMQVIgPSAnRE9MTEFSJzsgLy8gJFxuY29uc3QgRE9UID0gJ0RPVCc7IC8vIC5cbmNvbnN0IEVRVUFMUyA9ICdFUVVBTFMnOyAvLyA9XG5jb25zdCBFWENMQU1BVElPTiA9ICdFWENMQU1BVElPTic7IC8vICFcbmNvbnN0IEhZUEhFTiA9ICdIWVBIRU4nOyAvLyAtXG5jb25zdCBQRVJDRU5UID0gJ1BFUkNFTlQnOyAvLyAlXG5jb25zdCBQSVBFID0gJ1BJUEUnOyAvLyB8XG5jb25zdCBQTFVTID0gJ1BMVVMnOyAvLyArXG5jb25zdCBQT1VORCA9ICdQT1VORCc7IC8vICNcbmNvbnN0IFFVRVJZID0gJ1FVRVJZJzsgLy8gP1xuY29uc3QgUVVPVEUgPSAnUVVPVEUnOyAvLyBcIlxuY29uc3QgRlVMTFdJRFRITUlERExFRE9UID0gJ0ZVTExXSURUSE1JRERMRURPVCc7IC8vIOODu1xuXG5jb25zdCBTRU1JID0gJ1NFTUknOyAvLyA7XG5jb25zdCBTTEFTSCA9ICdTTEFTSCc7IC8vIC9cbmNvbnN0IFRJTERFID0gJ1RJTERFJzsgLy8gflxuY29uc3QgVU5ERVJTQ09SRSA9ICdVTkRFUlNDT1JFJzsgLy8gX1xuXG4vLyBFbW9qaSBzeW1ib2xcbmNvbnN0IEVNT0pJJDEgPSAnRU1PSkknO1xuXG4vLyBEZWZhdWx0IHRva2VuIC0gYW55dGhpbmcgdGhhdCBpcyBub3Qgb25lIG9mIHRoZSBhYm92ZVxuY29uc3QgU1lNID0gJ1NZTSc7XG5cbnZhciB0ayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRXT1JEOiBXT1JELFxuXHRVV09SRDogVVdPUkQsXG5cdEFTQ0lJTlVNRVJJQ0FMOiBBU0NJSU5VTUVSSUNBTCxcblx0QUxQSEFOVU1FUklDQUw6IEFMUEhBTlVNRVJJQ0FMLFxuXHRMT0NBTEhPU1Q6IExPQ0FMSE9TVCxcblx0VExEOiBUTEQsXG5cdFVUTEQ6IFVUTEQsXG5cdFNDSEVNRTogU0NIRU1FLFxuXHRTTEFTSF9TQ0hFTUU6IFNMQVNIX1NDSEVNRSxcblx0TlVNOiBOVU0sXG5cdFdTOiBXUyxcblx0Tkw6IE5MLFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0Q0xPU0VCUkFDRTogQ0xPU0VCUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRDTE9TRUJSQUNLRVQ6IENMT1NFQlJBQ0tFVCxcblx0T1BFTlBBUkVOOiBPUEVOUEFSRU4sXG5cdENMT1NFUEFSRU46IENMT1NFUEFSRU4sXG5cdE9QRU5BTkdMRUJSQUNLRVQ6IE9QRU5BTkdMRUJSQUNLRVQsXG5cdENMT1NFQU5HTEVCUkFDS0VUOiBDTE9TRUFOR0xFQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVGVFBBUkVOOiBGVUxMV0lEVEhMRUZUUEFSRU4sXG5cdEZVTExXSURUSFJJR0hUUEFSRU46IEZVTExXSURUSFJJR0hUUEFSRU4sXG5cdExFRlRDT1JORVJCUkFDS0VUOiBMRUZUQ09STkVSQlJBQ0tFVCxcblx0UklHSFRDT1JORVJCUkFDS0VUOiBSSUdIVENPUk5FUkJSQUNLRVQsXG5cdExFRlRXSElURUNPUk5FUkJSQUNLRVQ6IExFRlRXSElURUNPUk5FUkJSQUNLRVQsXG5cdFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUOiBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVTU1RIQU46IEZVTExXSURUSExFU1NUSEFOLFxuXHRGVUxMV0lEVEhHUkVBVEVSVEhBTjogRlVMTFdJRFRIR1JFQVRFUlRIQU4sXG5cdEFNUEVSU0FORDogQU1QRVJTQU5ELFxuXHRBUE9TVFJPUEhFOiBBUE9TVFJPUEhFLFxuXHRBU1RFUklTSzogQVNURVJJU0ssXG5cdEFUOiBBVCxcblx0QkFDS1NMQVNIOiBCQUNLU0xBU0gsXG5cdEJBQ0tUSUNLOiBCQUNLVElDSyxcblx0Q0FSRVQ6IENBUkVULFxuXHRDT0xPTjogQ09MT04sXG5cdENPTU1BOiBDT01NQSxcblx0RE9MTEFSOiBET0xMQVIsXG5cdERPVDogRE9ULFxuXHRFUVVBTFM6IEVRVUFMUyxcblx0RVhDTEFNQVRJT046IEVYQ0xBTUFUSU9OLFxuXHRIWVBIRU46IEhZUEhFTixcblx0UEVSQ0VOVDogUEVSQ0VOVCxcblx0UElQRTogUElQRSxcblx0UExVUzogUExVUyxcblx0UE9VTkQ6IFBPVU5ELFxuXHRRVUVSWTogUVVFUlksXG5cdFFVT1RFOiBRVU9URSxcblx0RlVMTFdJRFRITUlERExFRE9UOiBGVUxMV0lEVEhNSURETEVET1QsXG5cdFNFTUk6IFNFTUksXG5cdFNMQVNIOiBTTEFTSCxcblx0VElMREU6IFRJTERFLFxuXHRVTkRFUlNDT1JFOiBVTkRFUlNDT1JFLFxuXHRFTU9KSTogRU1PSkkkMSxcblx0U1lNOiBTWU1cbn0pO1xuXG4vLyBOb3RlIHRoYXQgdGhlc2UgdHdvIFVuaWNvZGUgb25lcyBleHBhbmQgaW50byBhIHJlYWxseSBiaWcgb25lIHdpdGggQmFiZWxcbmNvbnN0IEFTQ0lJX0xFVFRFUiA9IC9bYS16XS87XG5jb25zdCBMRVRURVIgPSAvXFxwe0x9L3U7IC8vIEFueSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGxldHRlciBkYXRhIHR5cGVcbmNvbnN0IEVNT0pJID0gL1xccHtFbW9qaX0vdTsgLy8gQW55IFVuaWNvZGUgZW1vamkgY2hhcmFjdGVyXG5jb25zdCBFTU9KSV9WQVJJQVRJT04kMSA9IC9cXHVmZTBmLztcbmNvbnN0IERJR0lUID0gL1xcZC87XG5jb25zdCBTUEFDRSA9IC9cXHMvO1xuXG52YXIgcmVnZXhwID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEFTQ0lJX0xFVFRFUjogQVNDSUlfTEVUVEVSLFxuXHRMRVRURVI6IExFVFRFUixcblx0RU1PSkk6IEVNT0pJLFxuXHRFTU9KSV9WQVJJQVRJT046IEVNT0pJX1ZBUklBVElPTiQxLFxuXHRESUdJVDogRElHSVQsXG5cdFNQQUNFOiBTUEFDRVxufSk7XG5cbi8qKlxuXHRUaGUgc2Nhbm5lciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCB0YWtlcyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0LCBhbmRcblx0b3V0cHV0cyBhbiBhcnJheSBvZiB0b2tlbnMgaW5zdGFuY2VzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGVhc3kgVVJMIHBhcnNpbmcuXG4qL1xuY29uc3QgQ1IgPSAnXFxyJzsgLy8gY2FycmlhZ2UtcmV0dXJuIGNoYXJhY3RlclxuY29uc3QgTEYgPSAnXFxuJzsgLy8gbGluZS1mZWVkIGNoYXJhY3RlclxuY29uc3QgRU1PSklfVkFSSUFUSU9OID0gJ1xcdWZlMGYnOyAvLyBWYXJpYXRpb24gc2VsZWN0b3IsIGZvbGxvd3MgaGVhcnQgYW5kIG90aGVyc1xuY29uc3QgRU1PSklfSk9JTkVSID0gJ1xcdTIwMGQnOyAvLyB6ZXJvLXdpZHRoIGpvaW5lclxuY29uc3QgT0JKRUNUX1JFUExBQ0VNRU5UID0gJ1xcdWZmZmMnOyAvLyB3aGl0ZXNwYWNlIHBsYWNlaG9sZGVyIHRoYXQgc29tZXRpbWVzIGFwcGVhcnMgaW4gcmljaCB0ZXh0IGVkaXRvcnNcblxubGV0IHRsZHMgPSBudWxsLFxuICB1dGxkcyA9IG51bGw7IC8vIGRvbid0IGNoYW5nZSBzbyBvbmx5IGhhdmUgdG8gYmUgY29tcHV0ZWQgb25jZVxuXG4vKipcbiAqIFNjYW5uZXIgb3V0cHV0IHRva2VuOlxuICogLSBgdGAgaXMgdGhlIHRva2VuIG5hbWUgKGUuZy4sICdOVU0nLCAnRU1PSkknLCAnVExEJylcbiAqIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gKGUuZy4sICcxMjMnLCAn4p2k77iPJywgJ2NvbScpXG4gKiAtIGBzYCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIC0gYGVgIGlzIHRoZSBlbmQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIEB0eXBlZGVmIHt7dDogc3RyaW5nLCB2OiBzdHJpbmcsIHM6IG51bWJlciwgZTogbnVtYmVyfX0gVG9rZW5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7eyBbY29sbGVjdGlvbjogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY2FubmVyIGNoYXJhY3Rlci1iYXNlZCBzdGF0ZSBtYWNoaW5lIGZvciB0aGUgZ2l2ZW4gc3RhcnRcbiAqIHN0YXRlXG4gKiBAcGFyYW0ge1tzdHJpbmcsIGJvb2xlYW5dW119IGN1c3RvbVNjaGVtZXMgTGlzdCBvZiBjdXN0b20gc2NoZW1lcywgd2hlcmUgZWFjaFxuICogaXRlbSBpcyBhIGxlbmd0aC0yIHR1cGxlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgc2V0IHRvIHRoZSBzdHJpbmcgc2NoZW1lLCBhbmRcbiAqIHRoZSBzZWNvbmQgZWxlbWVudCBzZXQgdG8gYHRydWVgIGlmIHRoZSBgOi8vYCBhZnRlciB0aGUgc2NoZW1lIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGluaXQkMihjdXN0b21TY2hlbWVzID0gW10pIHtcbiAgLy8gRnJlcXVlbnRseSB1c2VkIHN0YXRlcyAobmFtZSBhcmd1bWVudCByZW1vdmVkIGR1cmluZyBtaW5pZmljYXRpb24pXG4gIC8qKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+ICovXG4gIGNvbnN0IGdyb3VwcyA9IHt9OyAvLyBvZiB0b2tlbnNcbiAgU3RhdGUuZ3JvdXBzID0gZ3JvdXBzO1xuICAvKiogQHR5cGUgU3RhdGU8c3RyaW5nPiAqL1xuICBjb25zdCBTdGFydCA9IG5ldyBTdGF0ZSgpO1xuICBpZiAodGxkcyA9PSBudWxsKSB7XG4gICAgdGxkcyA9IGRlY29kZVRsZHMoZW5jb2RlZFRsZHMpO1xuICB9XG4gIGlmICh1dGxkcyA9PSBudWxsKSB7XG4gICAgdXRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRVdGxkcyk7XG4gIH1cblxuICAvLyBTdGF0ZXMgZm9yIHNwZWNpYWwgVVJMIHN5bWJvbHMgdGhhdCBhY2NlcHQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgdHQoU3RhcnQsIFwiJ1wiLCBBUE9TVFJPUEhFKTtcbiAgdHQoU3RhcnQsICd7JywgT1BFTkJSQUNFKTtcbiAgdHQoU3RhcnQsICd9JywgQ0xPU0VCUkFDRSk7XG4gIHR0KFN0YXJ0LCAnWycsIE9QRU5CUkFDS0VUKTtcbiAgdHQoU3RhcnQsICddJywgQ0xPU0VCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcoJywgT1BFTlBBUkVOKTtcbiAgdHQoU3RhcnQsICcpJywgQ0xPU0VQQVJFTik7XG4gIHR0KFN0YXJ0LCAnPCcsIE9QRU5BTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJz4nLCBDTE9TRUFOR0xFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn77yIJywgRlVMTFdJRFRITEVGVFBBUkVOKTtcbiAgdHQoU3RhcnQsICfvvIknLCBGVUxMV0lEVEhSSUdIVFBBUkVOKTtcbiAgdHQoU3RhcnQsICfjgIwnLCBMRUZUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn44CNJywgUklHSFRDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICfjgI4nLCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICfjgI8nLCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn77ycJywgRlVMTFdJRFRITEVTU1RIQU4pO1xuICB0dChTdGFydCwgJ++8nicsIEZVTExXSURUSEdSRUFURVJUSEFOKTtcbiAgdHQoU3RhcnQsICcmJywgQU1QRVJTQU5EKTtcbiAgdHQoU3RhcnQsICcqJywgQVNURVJJU0spO1xuICB0dChTdGFydCwgJ0AnLCBBVCk7XG4gIHR0KFN0YXJ0LCAnYCcsIEJBQ0tUSUNLKTtcbiAgdHQoU3RhcnQsICdeJywgQ0FSRVQpO1xuICB0dChTdGFydCwgJzonLCBDT0xPTik7XG4gIHR0KFN0YXJ0LCAnLCcsIENPTU1BKTtcbiAgdHQoU3RhcnQsICckJywgRE9MTEFSKTtcbiAgdHQoU3RhcnQsICcuJywgRE9UKTtcbiAgdHQoU3RhcnQsICc9JywgRVFVQUxTKTtcbiAgdHQoU3RhcnQsICchJywgRVhDTEFNQVRJT04pO1xuICB0dChTdGFydCwgJy0nLCBIWVBIRU4pO1xuICB0dChTdGFydCwgJyUnLCBQRVJDRU5UKTtcbiAgdHQoU3RhcnQsICd8JywgUElQRSk7XG4gIHR0KFN0YXJ0LCAnKycsIFBMVVMpO1xuICB0dChTdGFydCwgJyMnLCBQT1VORCk7XG4gIHR0KFN0YXJ0LCAnPycsIFFVRVJZKTtcbiAgdHQoU3RhcnQsICdcIicsIFFVT1RFKTtcbiAgdHQoU3RhcnQsICcvJywgU0xBU0gpO1xuICB0dChTdGFydCwgJzsnLCBTRU1JKTtcbiAgdHQoU3RhcnQsICd+JywgVElMREUpO1xuICB0dChTdGFydCwgJ18nLCBVTkRFUlNDT1JFKTtcbiAgdHQoU3RhcnQsICdcXFxcJywgQkFDS1NMQVNIKTtcbiAgdHQoU3RhcnQsICfjg7snLCBGVUxMV0lEVEhNSURETEVET1QpO1xuICBjb25zdCBOdW0gPSB0cihTdGFydCwgRElHSVQsIE5VTSwge1xuICAgIFtudW1lcmljXTogdHJ1ZVxuICB9KTtcbiAgdHIoTnVtLCBESUdJVCwgTnVtKTtcbiAgY29uc3QgQXNjaWludW1lcmljID0gdHIoTnVtLCBBU0NJSV9MRVRURVIsIEFTQ0lJTlVNRVJJQ0FMLCB7XG4gICAgW2FzY2lpbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIGNvbnN0IEFscGhhbnVtZXJpYyA9IHRyKE51bSwgTEVUVEVSLCBBTFBIQU5VTUVSSUNBTCwge1xuICAgIFthbHBoYW51bWVyaWNdOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFN0YXRlIHdoaWNoIGVtaXRzIGEgd29yZCB0b2tlblxuICBjb25zdCBXb3JkID0gdHIoU3RhcnQsIEFTQ0lJX0xFVFRFUiwgV09SRCwge1xuICAgIFthc2NpaV06IHRydWVcbiAgfSk7XG4gIHRyKFdvcmQsIERJR0lULCBBc2NpaW51bWVyaWMpO1xuICB0cihXb3JkLCBBU0NJSV9MRVRURVIsIFdvcmQpO1xuICB0cihBc2NpaW51bWVyaWMsIERJR0lULCBBc2NpaW51bWVyaWMpO1xuICB0cihBc2NpaW51bWVyaWMsIEFTQ0lJX0xFVFRFUiwgQXNjaWludW1lcmljKTtcblxuICAvLyBTYW1lIGFzIHByZXZpb3VzLCBidXQgc3BlY2lmaWMgdG8gbm9uLWZzbS5hc2NpaSBhbHBoYWJldCB3b3Jkc1xuICBjb25zdCBVV29yZCA9IHRyKFN0YXJ0LCBMRVRURVIsIFVXT1JELCB7XG4gICAgW2FscGhhXTogdHJ1ZVxuICB9KTtcbiAgdHIoVVdvcmQsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoVVdvcmQsIERJR0lULCBBbHBoYW51bWVyaWMpO1xuICB0cihVV29yZCwgTEVUVEVSLCBVV29yZCk7XG4gIHRyKEFscGhhbnVtZXJpYywgRElHSVQsIEFscGhhbnVtZXJpYyk7XG4gIHRyKEFscGhhbnVtZXJpYywgQVNDSUlfTEVUVEVSKTsgLy8gTm9uLWFjY2VwdGluZ1xuICB0cihBbHBoYW51bWVyaWMsIExFVFRFUiwgQWxwaGFudW1lcmljKTsgLy8gTm9uLWFjY2VwdGluZ1xuXG4gIC8vIFdoaXRlc3BhY2UganVtcHNcbiAgLy8gVG9rZW5zIG9mIG9ubHkgbm9uLW5ld2xpbmUgd2hpdGVzcGFjZSBhcmUgYXJiaXRyYXJpbHkgbG9uZ1xuICAvLyBJZiBhbnkgd2hpdGVzcGFjZSBleGNlcHQgbmV3bGluZSwgbW9yZSB3aGl0ZXNwYWNlIVxuICBjb25zdCBObCA9IHR0KFN0YXJ0LCBMRiwgTkwsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIGNvbnN0IENyID0gdHQoU3RhcnQsIENSLCBXUywge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgV3MgPSB0cihTdGFydCwgU1BBQ0UsIFdTLCB7XG4gICAgW3doaXRlc3BhY2VdOiB0cnVlXG4gIH0pO1xuICB0dChTdGFydCwgT0JKRUNUX1JFUExBQ0VNRU5ULCBXcyk7XG4gIHR0KENyLCBMRiwgTmwpOyAvLyBcXHJcXG5cbiAgdHQoQ3IsIE9CSkVDVF9SRVBMQUNFTUVOVCwgV3MpO1xuICB0cihDciwgU1BBQ0UsIFdzKTtcbiAgdHQoV3MsIENSKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHQoV3MsIExGKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHIoV3MsIFNQQUNFLCBXcyk7XG4gIHR0KFdzLCBPQkpFQ1RfUkVQTEFDRU1FTlQsIFdzKTtcblxuICAvLyBFbW9qaSB0b2tlbnMuIFRoZXkgYXJlIG5vdCBncm91cGVkIGJ5IHRoZSBzY2FubmVyIGV4Y2VwdCBpbiBjYXNlcyB3aGVyZSBhXG4gIC8vIHplcm8td2lkdGggam9pbmVyIGlzIHByZXNlbnRcbiAgY29uc3QgRW1vamkgPSB0cihTdGFydCwgRU1PSkksIEVNT0pJJDEsIHtcbiAgICBbZW1vamldOiB0cnVlXG4gIH0pO1xuICB0dChFbW9qaSwgJyMnKTsgLy8gbm8gdHJhbnNpdGlvbiwgZW1vamkgcmVnZXggc2VlbXMgdG8gbWF0Y2ggI1xuICB0cihFbW9qaSwgRU1PSkksIEVtb2ppKTtcbiAgdHQoRW1vamksIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpO1xuICAvLyB0dChTdGFydCwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIFRoaXMgb25lIGlzIHNrZXRjaHlcblxuICBjb25zdCBFbW9qaUpvaW5lciA9IHR0KEVtb2ppLCBFTU9KSV9KT0lORVIpO1xuICB0dChFbW9qaUpvaW5lciwgJyMnKTtcbiAgdHIoRW1vamlKb2luZXIsIEVNT0pJLCBFbW9qaSk7XG4gIC8vIHR0KEVtb2ppSm9pbmVyLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gYWxzbyBza2V0Y2h5XG5cbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICBjb25zdCB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF0sIFtESUdJVCwgQXNjaWludW1lcmljXV07XG4gIGNvbnN0IHV3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgbnVsbF0sIFtMRVRURVIsIFVXb3JkXSwgW0RJR0lULCBBbHBoYW51bWVyaWNdXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB0bGRzW2ldLCBUTEQsIFdPUkQsIHdvcmRqcik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZhc3R0cyhTdGFydCwgdXRsZHNbaV0sIFVUTEQsIFVXT1JELCB1d29yZGpyKTtcbiAgfVxuICBhZGRUb0dyb3VwcyhUTEQsIHtcbiAgICB0bGQ6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoVVRMRCwge1xuICAgIHV0bGQ6IHRydWUsXG4gICAgYWxwaGE6IHRydWVcbiAgfSwgZ3JvdXBzKTtcblxuICAvLyBDb2xsZWN0IHRoZSBzdGF0ZXMgZ2VuZXJhdGVkIGJ5IGRpZmZlcmVudCBwcm90b2NvbHMuIE5PVEU6IElmIGFueSBuZXcgVExEc1xuICAvLyBnZXQgYWRkZWQgdGhhdCBhcmUgYWxzbyBwcm90b2NvbHMsIHNldCB0aGUgdG9rZW4gdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gIC8vIHByb3RvY29sIHRvIGVuc3VyZSBwYXJzaW5nIHdvcmtzIGFzIGV4cGVjdGVkLlxuICBmYXN0dHMoU3RhcnQsICdmaWxlJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdtYWlsdG8nLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGFkZFRvR3JvdXBzKFNDSEVNRSwge1xuICAgIHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhTTEFTSF9TQ0hFTUUsIHtcbiAgICBzbGFzaHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIFJlZ2lzdGVyIGN1c3RvbSBzY2hlbWVzLiBBc3N1bWVzIGVhY2ggc2NoZW1lIGlzIGFzY2lpbnVtZXJpYyB3aXRoIGh5cGhlbnNcbiAgY3VzdG9tU2NoZW1lcyA9IGN1c3RvbVNjaGVtZXMuc29ydCgoYSwgYikgPT4gYVswXSA+IGJbMF0gPyAxIDogLTEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1c3RvbVNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2ggPSBjdXN0b21TY2hlbWVzW2ldWzBdO1xuICAgIGNvbnN0IG9wdGlvbmFsU2xhc2hTbGFzaCA9IGN1c3RvbVNjaGVtZXNbaV1bMV07XG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25hbFNsYXNoU2xhc2ggPyB7XG4gICAgICBbc2NoZW1lXTogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBbc2xhc2hzY2hlbWVdOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoc2NoLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFBU0NJSV9MRVRURVIudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1tudW1lcmljXSA9IHRydWU7IC8vIG51bWJlcnMgb25seVxuICAgIH0gZWxzZSBpZiAoRElHSVQudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ3NbYXNjaWldID0gdHJ1ZTtcbiAgICB9XG4gICAgdHMoU3RhcnQsIHNjaCwgc2NoLCBmbGFncyk7XG4gIH1cblxuICAvLyBMb2NhbGhvc3QgdG9rZW5cbiAgdHMoU3RhcnQsICdsb2NhbGhvc3QnLCBMT0NBTEhPU1QsIHtcbiAgICBhc2NpaTogdHJ1ZVxuICB9KTtcblxuICAvLyBTZXQgZGVmYXVsdCB0cmFuc2l0aW9uIGZvciBzdGFydCBzdGF0ZSAoc29tZSBzeW1ib2wpXG4gIFN0YXJ0LmpkID0gbmV3IFN0YXRlKFNZTSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogYXNzaWduKHtcbiAgICAgIGdyb3Vwc1xuICAgIH0sIHRrKVxuICB9O1xufVxuXG4vKipcblx0R2l2ZW4gYSBzdHJpbmcsIHJldHVybnMgYW4gYXJyYXkgb2YgVE9LRU4gaW5zdGFuY2VzIHJlcHJlc2VudGluZyB0aGVcblx0Y29tcG9zaXRpb24gb2YgdGhhdCBzdHJpbmcuXG5cblx0QG1ldGhvZCBydW5cblx0QHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGFydCBzY2FubmVyIHN0YXJ0aW5nIHN0YXRlXG5cdEBwYXJhbSB7c3RyaW5nfSBzdHIgaW5wdXQgc3RyaW5nIHRvIHNjYW5cblx0QHJldHVybiB7VG9rZW5bXX0gbGlzdCBvZiB0b2tlbnMsIGVhY2ggd2l0aCBhIHR5cGUgYW5kIHZhbHVlXG4qL1xuZnVuY3Rpb24gcnVuJDEoc3RhcnQsIHN0cikge1xuICAvLyBTdGF0ZSBtYWNoaW5lIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSwgc28gaW5wdXQgaXMgdG9rZW5pemVkIGluIGxvd2VyY2FzZWRcbiAgLy8gZm9ybSAoc3RpbGwgcmV0dXJucyByZWd1bGFyIGNhc2UpLiBVc2VzIHNlbGVjdGl2ZSBgdG9Mb3dlckNhc2VgIGJlY2F1c2VcbiAgLy8gbG93ZXJjYXNpbmcgdGhlIGVudGlyZSBzdHJpbmcgY2F1c2VzIHRoZSBsZW5ndGggYW5kIGNoYXJhY3RlciBwb3NpdGlvbiB0b1xuICAvLyB2YXJ5IGluIHNvbWUgbm9uLUVuZ2xpc2ggc3RyaW5ncyB3aXRoIFY4LWJhc2VkIHJ1bnRpbWVzLlxuICBjb25zdCBpdGVyYWJsZSA9IHN0cmluZ1RvQXJyYXkoc3RyLnJlcGxhY2UoL1tBLVpdL2csIGMgPT4gYy50b0xvd2VyQ2FzZSgpKSk7XG4gIGNvbnN0IGNoYXJDb3VudCA9IGl0ZXJhYmxlLmxlbmd0aDsgLy8gPD0gbGVuIGlmIHRoZXJlIGFyZSBlbW9qaXMsIGV0Y1xuICBjb25zdCB0b2tlbnMgPSBbXTsgLy8gcmV0dXJuIHZhbHVlXG5cbiAgLy8gY3Vyc29yIHRocm91Z2ggdGhlIHN0cmluZyBpdHNlbGYsIGFjY291bnRpbmcgZm9yIGNoYXJhY3RlcnMgdGhhdCBoYXZlXG4gIC8vIHdpZHRoIHdpdGggbGVuZ3RoIDIgc3VjaCBhcyBlbW9qaXNcbiAgbGV0IGN1cnNvciA9IDA7XG5cbiAgLy8gQ3Vyc29yIHRocm91Z2ggdGhlIGFycmF5LXJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmdcbiAgbGV0IGNoYXJDdXJzb3IgPSAwO1xuXG4gIC8vIFRva2VuaXplIHRoZSBzdHJpbmdcbiAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQpIHtcbiAgICBsZXQgc3RhdGUgPSBzdGFydDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgdG9rZW5MZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICBsZXQgY2hhcnNTaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCAmJiAobmV4dFN0YXRlID0gc3RhdGUuZ28oaXRlcmFibGVbY2hhckN1cnNvcl0pKSkge1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBsYXRlc3RBY2NlcHRpbmcgPSBzdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luY2VBY2NlcHRzID49IDApIHtcbiAgICAgICAgc2luY2VBY2NlcHRzICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIHRva2VuTGVuZ3RoICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGN1cnNvciArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjaGFyQ3Vyc29yKys7XG4gICAgfVxuXG4gICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgY3Vyc29yIC09IHNpbmNlQWNjZXB0cztcbiAgICBjaGFyQ3Vyc29yIC09IGNoYXJzU2luY2VBY2NlcHRzO1xuICAgIHRva2VuTGVuZ3RoIC09IHNpbmNlQWNjZXB0cztcblxuICAgIC8vIE5vIG1vcmUganVtcHMsIGp1c3QgbWFrZSBhIG5ldyB0b2tlbiBmcm9tIHRoZSBsYXN0IGFjY2VwdGluZyBvbmVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0OiBsYXRlc3RBY2NlcHRpbmcudCxcbiAgICAgIC8vIHRva2VuIHR5cGUvbmFtZVxuICAgICAgdjogc3RyLnNsaWNlKGN1cnNvciAtIHRva2VuTGVuZ3RoLCBjdXJzb3IpLFxuICAgICAgLy8gc3RyaW5nIHZhbHVlXG4gICAgICBzOiBjdXJzb3IgLSB0b2tlbkxlbmd0aCxcbiAgICAgIC8vIHN0YXJ0IGluZGV4XG4gICAgICBlOiBjdXJzb3IgLy8gZW5kIGluZGV4IChleGNsdWRpbmcpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgU3RyaW5nIHRvIGFuIEFycmF5IG9mIGNoYXJhY3RlcnMsIHRha2luZyBpbnRvIGFjY291bnQgdGhhdCBzb21lXG4gKiBjaGFyYWN0ZXJzIGxpa2UgZW1vamlzIHRha2UgdXAgdHdvIHN0cmluZyBpbmRleGVzLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBjb3JlLWpzIChNSVQgbGljZW5zZSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvMmQ2OWNmNWY5OWFiM2VhMzQ2M2MzOTVkZjgxZTVhMTViNjhmNDlkOS9wYWNrYWdlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzXG4gKlxuICogQGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgIGxldCBmaXJzdCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICBsZXQgc2Vjb25kO1xuICAgIGxldCBjaGFyID0gZmlyc3QgPCAweGQ4MDAgfHwgZmlyc3QgPiAweGRiZmYgfHwgaW5kZXggKyAxID09PSBsZW4gfHwgKHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSkpIDwgMHhkYzAwIHx8IHNlY29uZCA+IDB4ZGZmZiA/IHN0cltpbmRleF0gLy8gc2luZ2xlIGNoYXJhY3RlclxuICAgIDogc3RyLnNsaWNlKGluZGV4LCBpbmRleCArIDIpOyAvLyB0d28taW5kZXggY2hhcmFjdGVyc1xuICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgIGluZGV4ICs9IGNoYXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmFzdCB2ZXJzaW9uIG9mIHRzIGZ1bmN0aW9uIGZvciB3aGVuIHRyYW5zaXRpb24gZGVmYXVsdHMgYXJlIHdlbGwga25vd25cbiAqIEBwYXJhbSB7U3RhdGU8c3RyaW5nPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmd9IHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0dFxuICogQHBhcmFtIHtbUmVnRXhwLCBTdGF0ZTxzdHJpbmc+XVtdfSBqclxuICogQHJldHVybnMge1N0YXRlPHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGZhc3R0cyhzdGF0ZSwgaW5wdXQsIHQsIGRlZmF1bHR0LCBqcikge1xuICBsZXQgbmV4dDtcbiAgY29uc3QgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBpZiAoc3RhdGUualtjaGFyXSkge1xuICAgICAgbmV4dCA9IHN0YXRlLmpbY2hhcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBuZXcgU3RhdGUoZGVmYXVsdHQpO1xuICAgICAgbmV4dC5qciA9IGpyLnNsaWNlKCk7XG4gICAgICBzdGF0ZS5qW2NoYXJdID0gbmV4dDtcbiAgICB9XG4gICAgc3RhdGUgPSBuZXh0O1xuICB9XG4gIG5leHQgPSBuZXcgU3RhdGUodCk7XG4gIG5leHQuanIgPSBqci5zbGljZSgpO1xuICBzdGF0ZS5qW2lucHV0W2xlbiAtIDFdXSA9IG5leHQ7XG4gIHJldHVybiBuZXh0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFRvcC1MZXZlbCBEb21haW4gbmFtZXMgZW5jb2RlZCBpbiB1cGRhdGUtdGxkcy5qcyBiYWNrXG4gKiBpbnRvIGEgbGlzdCBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJ9IGVuY29kZWQgZW5jb2RlZCBUTERzIHN0cmluZ1xuICogQHJldHVybnMge3N0cltdfSBvcmlnaW5hbCBUTERzIGxpc3RcbiAqL1xuZnVuY3Rpb24gZGVjb2RlVGxkcyhlbmNvZGVkKSB7XG4gIGNvbnN0IHdvcmRzID0gW107XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGxldCBpID0gMDtcbiAgbGV0IGRpZ2l0cyA9ICcwMTIzNDU2Nzg5JztcbiAgd2hpbGUgKGkgPCBlbmNvZGVkLmxlbmd0aCkge1xuICAgIGxldCBwb3BEaWdpdENvdW50ID0gMDtcbiAgICB3aGlsZSAoZGlnaXRzLmluZGV4T2YoZW5jb2RlZFtpICsgcG9wRGlnaXRDb3VudF0pID49IDApIHtcbiAgICAgIHBvcERpZ2l0Q291bnQrKzsgLy8gZW5jb3VudGVyZWQgc29tZSBkaWdpdHMsIGhhdmUgdG8gcG9wIHRvIGdvIG9uZSBsZXZlbCB1cCB0cmllXG4gICAgfVxuICAgIGlmIChwb3BEaWdpdENvdW50ID4gMCkge1xuICAgICAgd29yZHMucHVzaChzdGFjay5qb2luKCcnKSk7IC8vIHdoYXRldmVyIHByZWNlZGVkIHRoZSBwb3AgZGlnaXRzIG11c3QgYmUgYSB3b3JkXG4gICAgICBmb3IgKGxldCBwb3BDb3VudCA9IHBhcnNlSW50KGVuY29kZWQuc3Vic3RyaW5nKGksIGkgKyBwb3BEaWdpdENvdW50KSwgMTApOyBwb3BDb3VudCA+IDA7IHBvcENvdW50LS0pIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgICBpICs9IHBvcERpZ2l0Q291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goZW5jb2RlZFtpXSk7IC8vIGRyb3AgZG93biBhIGxldmVsIGludG8gdGhlIHRyaWVcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHZhbGlkIERPTSBFdmVudCBOYW1lIHN1Y2ggYXMgYGNsaWNrYCBvciBgZm9jdXNgXG4gKiBhbmQgZWFjaCB2YWx1ZSBpcyBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50I2V2ZW50c1xuICogQHR5cGVkZWYgez97IFtldmVudDogc3RyaW5nXTogRnVuY3Rpb24gfX0gRXZlbnRMaXN0ZW5lcnNcbiAqL1xuXG4vKipcbiAqIEFsbCBmb3JtYXR0ZWQgcHJvcGVydGllcyByZXF1aXJlZCB0byByZW5kZXIgYSBsaW5rLCBpbmNsdWRpbmcgYHRhZ05hbWVgLFxuICogYGF0dHJpYnV0ZXNgLCBgY29udGVudGAgYW5kIGBldmVudExpc3RlbmVyc2AuXG4gKiBAdHlwZWRlZiB7eyB0YWdOYW1lOiBhbnksIGF0dHJpYnV0ZXM6IHtbYXR0cjogc3RyaW5nXTogYW55fSwgY29udGVudDogc3RyaW5nLFxuICogZXZlbnRMaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzIH19IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhbiBvYmplY3QgZGVzY3JpYmVkIGJ5IHRoZSB0ZW1wbGF0ZSB0eXBlIGBPYCBvciBhIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgT2BcbiAqIEB0ZW1wbGF0ZSBPXG4gKiBAdHlwZWRlZiB7TyB8ICgodmFsdWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCB0b2tlbjogTXVsdGlUb2tlbikgPT4gTyl9IE9wdE9ialxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiBkZXNjcmliZWQgYnkgdGVtcGxhdGUgdHlwZSBgRmAgb3IgYW4gb2JqZWN0LlxuICpcbiAqIEVhY2gga2V5IGluIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuIEVhY2hcbiAqIHZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdpdGggdGVtcGxhdGUgdHlwZSBgRmAgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgbGluayB0eXBlIGlzIGVuY291bnRlcmVkLlxuICogQHRlbXBsYXRlIEZcbiAqIEB0eXBlZGVmIHtGIHwgeyBbdHlwZTogc3RyaW5nXTogRn19IE9wdEZuXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhIHZhbHVlIHdpdGggdGVtcGxhdGUgdHlwZSBgVmAsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGBWYCBvclxuICogYW4gb2JqZWN0IHdoZXJlIGVhY2ggdmFsdWUgcmVzb2x2ZXMgdG8gYFZgLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgVmBcbiAqXG4gKiBGb3IgdGhlIG9iamVjdCwgZWFjaCBrZXkgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuXG4gKiBFYWNoIHZhbHVlIHNob3VsZCBlaXRoZXIgaGF2ZSB0eXBlIGBWYCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBWLiBUaGlzXG4gKiBmdW5jdGlvbiBzaW1pbGFybHkgdGFrZXMgYSBzdHJpbmcgdmFsdWUgYW5kIGEgdG9rZW4uXG4gKlxuICogRXhhbXBsZSB2YWxpZCB0eXBlcyBmb3IgYE9wdDxzdHJpbmc+YDpcbiAqXG4gKiBgYGBqc1xuICogJ2hlbGxvJ1xuICogKHZhbHVlLCB0eXBlLCB0b2tlbikgPT4gJ3dvcmxkJ1xuICogeyB1cmw6ICdoZWxsbycsIGVtYWlsOiAodmFsdWUsIHRva2VuKSA9PiAnd29ybGQnfVxuICogYGBgXG4gKiBAdGVtcGxhdGUgVlxuICogQHR5cGVkZWYge1YgfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIHwgeyBbdHlwZTogc3RyaW5nXTogViB8ICgodmFsdWU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIH19IE9wdFxuICovXG5cbi8qKlxuICogU2VlIGF2YWlsYWJsZSBvcHRpb25zOiBodHRwczovL2xpbmtpZnkuanMub3JnL2RvY3Mvb3B0aW9ucy5odG1sXG4gKiBAdHlwZWRlZiB7e1xuICogXHRkZWZhdWx0UHJvdG9jb2w/OiBzdHJpbmcsXG4gKiAgZXZlbnRzPzogT3B0T2JqPEV2ZW50TGlzdGVuZXJzPixcbiAqIFx0Zm9ybWF0PzogT3B0PHN0cmluZz4sXG4gKiBcdGZvcm1hdEhyZWY/OiBPcHQ8c3RyaW5nPixcbiAqIFx0bmwyYnI/OiBib29sZWFuLFxuICogXHR0YWdOYW1lPzogT3B0PGFueT4sXG4gKiBcdHRhcmdldD86IE9wdDxzdHJpbmc+LFxuICogXHRyZWw/OiBPcHQ8c3RyaW5nPixcbiAqIFx0dmFsaWRhdGU/OiBPcHQ8Ym9vbGVhbj4sXG4gKiBcdHRydW5jYXRlPzogT3B0PG51bWJlcj4sXG4gKiBcdGNsYXNzTmFtZT86IE9wdDxzdHJpbmc+LFxuICogXHRhdHRyaWJ1dGVzPzogT3B0T2JqPCh7IFthdHRyOiBzdHJpbmddOiBhbnkgfSk+LFxuICogIGlnbm9yZVRhZ3M/OiBzdHJpbmdbXSxcbiAqIFx0cmVuZGVyPzogT3B0Rm48KChpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueSk+XG4gKiB9fSBPcHRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBSZXF1aXJlZDxPcHRzPlxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gIGV2ZW50czogbnVsbCxcbiAgZm9ybWF0OiBub29wLFxuICBmb3JtYXRIcmVmOiBub29wLFxuICBubDJicjogZmFsc2UsXG4gIHRhZ05hbWU6ICdhJyxcbiAgdGFyZ2V0OiBudWxsLFxuICByZWw6IG51bGwsXG4gIHZhbGlkYXRlOiB0cnVlLFxuICB0cnVuY2F0ZTogSW5maW5pdHksXG4gIGNsYXNzTmFtZTogbnVsbCxcbiAgYXR0cmlidXRlczogbnVsbCxcbiAgaWdub3JlVGFnczogW10sXG4gIHJlbmRlcjogbnVsbFxufTtcblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBsaW5raWZ5IGludGVyZmFjZXMgdG8gYXBwbHkgc3BlY2lmaWVkXG4gKiB7QGxpbmsgT3B0cyBmb3JtYXR0aW5nIGFuZCByZW5kZXJpbmcgb3B0aW9uc30uXG4gKlxuICogQHBhcmFtIHtPcHRzIHwgT3B0aW9uc30gW29wdHNdIE9wdGlvbiB2YWx1ZSBvdmVycmlkZXMuXG4gKiBAcGFyYW0geyhpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueX0gW2RlZmF1bHRSZW5kZXJdIChGb3JcbiAqICAgaW50ZXJuYWwgdXNlKSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaG93IHRvIGdlbmVyYXRlIGFuXG4gKiAgIEhUTUwgZWxlbWVudCBiYXNlZCBvbiBhIGxpbmsgdG9rZW4ncyBkZXJpdmVkIHRhZ05hbWUsIGF0dHJpYnV0ZXMgYW5kIEhUTUwuXG4gKiAgIFNpbWlsYXIgdG8gcmVuZGVyIG9wdGlvblxuICovXG5mdW5jdGlvbiBPcHRpb25zKG9wdHMsIGRlZmF1bHRSZW5kZXIgPSBudWxsKSB7XG4gIGxldCBvID0gYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIGlmIChvcHRzKSB7XG4gICAgbyA9IGFzc2lnbihvLCBvcHRzIGluc3RhbmNlb2YgT3B0aW9ucyA/IG9wdHMubyA6IG9wdHMpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuICBjb25zdCBpZ25vcmVkVGFncyA9IG8uaWdub3JlVGFncztcbiAgY29uc3QgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIHVwcGVyY2FzZUlnbm9yZWRUYWdzLnB1c2goaWdub3JlZFRhZ3NbaV0udG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgdGhpcy5vID0gbztcbiAgaWYgKGRlZmF1bHRSZW5kZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXIgPSBkZWZhdWx0UmVuZGVyO1xuICB9XG4gIHRoaXMuaWdub3JlVGFncyA9IHVwcGVyY2FzZUlnbm9yZWRUYWdzO1xufVxuT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gIG86IGRlZmF1bHRzLFxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICAvKipcbiAgICogQHBhcmFtIHtJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbn0gaXJcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGRlZmF1bHRSZW5kZXIoaXIpIHtcbiAgICByZXR1cm4gaXI7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciBhIHRva2VuIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgYVxuICAgKiBsaW5rIGJhc2VkIG9uIHRoZSB1c2VyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVjayh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmdldCgndmFsaWRhdGUnLCB0b2tlbi50b1N0cmluZygpLCB0b2tlbik7XG4gIH0sXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIG9wdGlvbidzIHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGFuZCB0aGUgZ2l2ZW5cbiAgICogcGFyYW1zLiBJZiBvcGVyYXRvciBhbmQgdG9rZW4gYXJlIHNwZWNpZmllZCBhbmQgdGhlIHRhcmdldCBvcHRpb24gaXNcbiAgICogY2FsbGFibGUsIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IEtcbiAgICogQHBhcmFtIHtLfSBrZXkgTmFtZSBvZiBvcHRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0YXJnZXQgb3B0aW9uIGlmIGl0J3MgYVxuICAgKiBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgUkFXIGZ1bmN0aW9uIHZhbHVlIGdldHMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dIFRoZSB0b2tlbiBmcm9tIGxpbmtpZnkudG9rZW5pemVcbiAgICogQHJldHVybnMge09wdHNbS10gfCBhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICBjb25zdCBpc0NhbGxhYmxlID0gb3BlcmF0b3IgIT0gbnVsbDtcbiAgICBsZXQgb3B0aW9uID0gdGhpcy5vW2tleV07XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbi50LCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqKGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMub1trZXldO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIG9wZXJhdG9yICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iaihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gdG9rZW4gdG8gYSByZW5kZXJlZCBlbGVtZW50IHRoYXQgbWF5IGJlIGFkZGVkIHRvIHRoZVxuICAgKiBjYWxsaW5nLWludGVyZmFjZSdzIERPTVxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuIFRva2VuIHRvIHJlbmRlciB0byBhbiBIVE1MIGVsZW1lbnRcbiAgICogQHJldHVybnMge2FueX0gUmVuZGVyIHJlc3VsdDsgZS5nLiwgSFRNTCBzdHJpbmcsIERPTSBlbGVtZW50LCBSZWFjdFxuICAgKiAgIENvbXBvbmVudCwgZXRjLlxuICAgKi9cbiAgcmVuZGVyKHRva2VuKSB7XG4gICAgY29uc3QgaXIgPSB0b2tlbi5yZW5kZXIodGhpcyk7IC8vIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvblxuICAgIGNvbnN0IHJlbmRlckZuID0gdGhpcy5nZXQoJ3JlbmRlcicsIG51bGwsIHRva2VuKSB8fCB0aGlzLmRlZmF1bHRSZW5kZXI7XG4gICAgcmV0dXJuIHJlbmRlckZuKGlyLCB0b2tlbi50LCB0b2tlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBub29wKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0czogZGVmYXVsdHMsXG5cdE9wdGlvbnM6IE9wdGlvbnMsXG5cdGFzc2lnbjogYXNzaWduXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRNdWx0aS1Ub2tlbnNcblx0VG9rZW5zIGNvbXBvc2VkIG9mIGFycmF5cyBvZiBUZXh0VG9rZW5zXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiBNdWx0aVRva2VuKHZhbHVlLCB0b2tlbnMpIHtcbiAgdGhpcy50ID0gJ3Rva2VuJztcbiAgdGhpcy52ID0gdmFsdWU7XG4gIHRoaXMudGsgPSB0b2tlbnM7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdXNlZCBmb3IgbWFudWZhY3R1cmluZyB0b2tlbnMgb2YgdGV4dCB0b2tlbnMuIFRoYXQgaXMgcmF0aGVyXG4gKiB0aGFuIHRoZSB2YWx1ZSBmb3IgYSB0b2tlbiBiZWluZyBhIHNtYWxsIHN0cmluZyBvZiB0ZXh0LCBpdCdzIHZhbHVlIGFuIGFycmF5XG4gKiBvZiB0ZXh0IHRva2Vucy5cbiAqXG4gKiBVc2VkIGZvciBncm91cGluZyB0b2dldGhlciBVUkxzLCBlbWFpbHMsIGhhc2h0YWdzLCBhbmQgb3RoZXIgcG90ZW50aWFsXG4gKiBjcmVhdGlvbnMuXG4gKiBAY2xhc3MgTXVsdGlUb2tlblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2XG4gKiBAcHJvcGVydHkge1Rva2VuW119IHRrXG4gKiBAYWJzdHJhY3RcbiAqL1xuTXVsdGlUb2tlbi5wcm90b3R5cGUgPSB7XG4gIGlzTGluazogZmFsc2UsXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0aGlzIHRva2VuIHJlcHJlc2VudHMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgdmFsdWUgZm9yIHRoaXMgdG9rZW4gYmUgaW4gdGhlIGBocmVmYCBIVE1MIGF0dHJpYnV0ZT9cbiAgICogUmV0dXJucyB0aGUgYC50b1N0cmluZ2AgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSHJlZihzY2hlbWUpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucykge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBjb25zdCB0cnVuY2F0ZSA9IG9wdGlvbnMuZ2V0KCd0cnVuY2F0ZScsIHZhbCwgdGhpcyk7XG4gICAgY29uc3QgZm9ybWF0dGVkID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdCcsIHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHRydW5jYXRlICYmIGZvcm1hdHRlZC5sZW5ndGggPiB0cnVuY2F0ZSA/IGZvcm1hdHRlZC5zdWJzdHJpbmcoMCwgdHJ1bmNhdGUpICsgJ+KApicgOiBmb3JtYXR0ZWQ7XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0dGVkSHJlZihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKSwgdGhpcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGFydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrWzBdLnM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZW5kIGluZGV4IG9mIHRoaXMgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyAodXAgdG8gdGhpc1xuICAgKiBpbmRleCBidXQgbm90IGluY2x1ZGluZyBpdClcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrW3RoaXMudGsubGVuZ3RoIC0gMV0uZTtcbiAgfSxcbiAgLyoqXG4gIFx0UmV0dXJucyBhbiBvYmplY3QgIG9mIHJlbGV2YW50IHZhbHVlcyBmb3IgdGhpcyB0b2tlbiwgd2hpY2ggaW5jbHVkZXMga2V5c1xuICBcdCogdHlwZSAtIEtpbmQgb2YgdG9rZW4gKCd1cmwnLCAnZW1haWwnLCBldGMuKVxuICBcdCogdmFsdWUgLSBPcmlnaW5hbCB0ZXh0XG4gIFx0KiBocmVmIC0gVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBhbmNob3IgdGFnJ3MgaHJlZlxuICBcdFx0YXR0cmlidXRlXG4gIFx0XHRAbWV0aG9kIHRvT2JqZWN0XG4gIFx0QHBhcmFtIHtzdHJpbmd9IFtwcm90b2NvbF0gYCdodHRwJ2AgYnkgZGVmYXVsdFxuICAqL1xuICB0b09iamVjdChwcm90b2NvbCA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLnQsXG4gICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpLFxuICAgICAgaXNMaW5rOiB0aGlzLmlzTGluayxcbiAgICAgIGhyZWY6IHRoaXMudG9IcmVmKHByb3RvY29sKSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0SW5kZXgoKSxcbiAgICAgIGVuZDogdGhpcy5lbmRJbmRleCgpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5nIG9wdGlvblxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRPYmplY3Qob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLnQsXG4gICAgICB2YWx1ZTogdGhpcy50b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvRm9ybWF0dGVkSHJlZihvcHRpb25zKSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0SW5kZXgoKSxcbiAgICAgIGVuZDogdGhpcy5lbmRJbmRleCgpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyB0b2tlbiBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYSBsaW5rIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZ2V0KCd2YWxpZGF0ZScsIHRoaXMudG9TdHJpbmcoKSwgdGhpcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBob3cgdGhpcyBsaW5rIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbm5nIG9wdGlvbnNcbiAgICovXG4gIHJlbmRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuICAgIGNvbnN0IGhyZWYgPSB0aGlzLnRvSHJlZihvcHRpb25zLmdldCgnZGVmYXVsdFByb3RvY29sJykpO1xuICAgIGNvbnN0IGZvcm1hdHRlZEhyZWYgPSBvcHRpb25zLmdldCgnZm9ybWF0SHJlZicsIGhyZWYsIHRoaXMpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSBvcHRpb25zLmdldCgndGFnTmFtZScsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy50b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgY29uc3QgY2xhc3NOYW1lID0gb3B0aW9ucy5nZXQoJ2NsYXNzTmFtZScsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLmdldCgndGFyZ2V0JywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IHJlbCA9IG9wdGlvbnMuZ2V0KCdyZWwnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgYXR0cnMgPSBvcHRpb25zLmdldE9iaignYXR0cmlidXRlcycsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IG9wdGlvbnMuZ2V0T2JqKCdldmVudHMnLCBocmVmLCB0b2tlbik7XG4gICAgYXR0cmlidXRlcy5ocmVmID0gZm9ybWF0dGVkSHJlZjtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBhdHRyaWJ1dGVzLnRhcmdldCA9IHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHJlbCkge1xuICAgICAgYXR0cmlidXRlcy5yZWwgPSByZWw7XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgYXNzaWduKGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgY29udGVudCxcbiAgICAgIGV2ZW50TGlzdGVuZXJzXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9rZW4gdGhhdCBjYW4gYmUgZW1pdHRlZCBieSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHJlYWRhYmxlIHR5cGUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgcHJvcGVydGllcyB0byBhc3NpZ24gb3Igb3ZlcnJpZGUsIGluY2x1ZGluZyBpc0xpbmsgPSB0cnVlIG9yIGZhbHNlXG4gKiBAcmV0dXJucyB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IG5ldyB0b2tlbiBjbGFzc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUb2tlbkNsYXNzKHR5cGUsIHByb3BzKSB7XG4gIGNsYXNzIFRva2VuIGV4dGVuZHMgTXVsdGlUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2Vucykge1xuICAgICAgc3VwZXIodmFsdWUsIHRva2Vucyk7XG4gICAgICB0aGlzLnQgPSB0eXBlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcbiAgICBUb2tlbi5wcm90b3R5cGVbcF0gPSBwcm9wc1twXTtcbiAgfVxuICBUb2tlbi50ID0gdHlwZTtcbiAgcmV0dXJuIFRva2VuO1xufVxuXG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdG9rZW5zIG1ha2luZyB1cCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcbiovXG5jb25zdCBFbWFpbCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ2VtYWlsJywge1xuICBpc0xpbms6IHRydWUsXG4gIHRvSHJlZigpIHtcbiAgICByZXR1cm4gJ21haWx0bzonICsgdGhpcy50b1N0cmluZygpO1xuICB9XG59KTtcblxuLyoqXG5cdFJlcHJlc2VudHMgc29tZSBwbGFpbiB0ZXh0XG4qL1xuY29uc3QgVGV4dCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3RleHQnKTtcblxuLyoqXG5cdE11bHRpLWxpbmVicmVhayB0b2tlbiAtIHJlcHJlc2VudHMgYSBsaW5lIGJyZWFrXG5cdEBjbGFzcyBObFxuKi9cbmNvbnN0IE5sID0gY3JlYXRlVG9rZW5DbGFzcygnbmwnKTtcblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRleHQgdG9rZW5zIG1ha2luZyB1cCBhIHZhbGlkIFVSTFxuXHRAY2xhc3MgVXJsXG4qL1xuY29uc3QgVXJsID0gY3JlYXRlVG9rZW5DbGFzcygndXJsJywge1xuICBpc0xpbms6IHRydWUsXG4gIC8qKlxuICBcdExvd2VyY2FzZXMgcmVsZXZhbnQgcGFydHMgb2YgdGhlIGRvbWFpbiBhbmQgYWRkcyB0aGUgcHJvdG9jb2wgaWZcbiAgXHRyZXF1aXJlZC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZXNjYXBlIHVuc2FmZSBIVE1MIGNoYXJhY3RlcnMgaW4gdGhlXG4gIFx0VVJMLlxuICBcdFx0QHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdIGRlZmF1bHQgc2NoZW1lIChlLmcuLCAnaHR0cHMnKVxuICBcdEByZXR1cm4ge3N0cmluZ30gdGhlIGZ1bGwgaHJlZlxuICAqL1xuICB0b0hyZWYoc2NoZW1lID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sKSB7XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBoYXMgYSBwcmVmaXggc2NoZW1lXG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2woKSA/IHRoaXMudiA6IGAke3NjaGVtZX06Ly8ke3RoaXMudn1gO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIFVSTCB0b2tlbiBoYXMgYSBwcm90b2NvbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUHJvdG9jb2woKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy50aztcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vuc1swXS50ICE9PSBMT0NBTEhPU1QgJiYgdG9rZW5zWzFdLnQgPT09IENPTE9OO1xuICB9XG59KTtcblxudmFyIG11bHRpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdE11bHRpVG9rZW46IE11bHRpVG9rZW4sXG5cdEJhc2U6IE11bHRpVG9rZW4sXG5cdGNyZWF0ZVRva2VuQ2xhc3M6IGNyZWF0ZVRva2VuQ2xhc3MsXG5cdEVtYWlsOiBFbWFpbCxcblx0VGV4dDogVGV4dCxcblx0Tmw6IE5sLFxuXHRVcmw6IFVybFxufSk7XG5cbi8qKlxuXHROb3QgZXhhY3RseSBwYXJzZXIsIG1vcmUgbGlrZSB0aGUgc2Vjb25kLXN0YWdlIHNjYW5uZXIgKGFsdGhvdWdoIHdlIGNhblxuXHR0aGVvcmV0aWNhbGx5IGhvdHN3YXAgdGhlIGNvZGUgaGVyZSB3aXRoIGEgcmVhbCBwYXJzZXIgaW4gdGhlIGZ1dHVyZS4uLiBidXRcblx0Zm9yIGEgbGl0dGxlIFVSTC1maW5kaW5nIHV0aWxpdHkgYWJzdHJhY3Qgc3ludGF4IHRyZWVzIG1heSBiZSBhIGxpdHRsZVxuXHRvdmVya2lsbCkuXG5cblx0VVJMIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdEVtYWlsIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWFpbEFkZHJlc3MgKGxpbmtzIHRvIFJGQyBpblxuXHRyZWZlcmVuY2UpXG5cblx0QG1vZHVsZSBsaW5raWZ5XG5cdEBzdWJtb2R1bGUgcGFyc2VyXG5cdEBtYWluIHJ1blxuKi9cbmNvbnN0IG1ha2VTdGF0ZSA9IGFyZyA9PiBuZXcgU3RhdGUoYXJnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgcGFyc2VyIG11bHRpIHRva2VuLWJhc2VkIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7eyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGluaXQkMSh7XG4gIGdyb3Vwc1xufSkge1xuICAvLyBUeXBlcyBvZiBjaGFyYWN0ZXJzIHRoZSBVUkwgY2FuIGRlZmluaXRlbHkgZW5kIGluXG4gIGNvbnN0IHFzQWNjZXB0aW5nID0gZ3JvdXBzLmRvbWFpbi5jb25jYXQoW0FNUEVSU0FORCwgQVNURVJJU0ssIEFULCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgTlVNLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdKTtcblxuICAvLyBUeXBlcyBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGEgVVJMIGFuZCBiZSBwYXJ0IG9mIHRoZSBxdWVyeSBzdHJpbmdcbiAgLy8gYnV0IGNhbm5vdCBiZSB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlcnNcbiAgLy8gQ2hhcmFjdGVycyB0aGF0IGNhbm5vdCBhcHBlYXIgaW4gdGhlIFVSTCBhdCBhbGwgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gIGNvbnN0IHFzTm9uQWNjZXB0aW5nID0gW0NPTE9OLCBDT01NQSwgRE9ULCBFWENMQU1BVElPTiwgUEVSQ0VOVCwgUVVFUlksIFFVT1RFLCBTRU1JLCBPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVCwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBDTE9TRUJSQUNLRVQsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIENMT1NFUEFSRU4sIEZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTiwgTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVCwgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVQsIEZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl07XG5cbiAgLy8gRm9yIGFkZHJlc3NlcyB3aXRob3V0IHRoZSBtYWlsdG8gcHJlZml4XG4gIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBsb2NhbHBhcnQgb2YgdGhlIGVtYWlsXG4gIGNvbnN0IGxvY2FscGFydEFjY2VwdGluZyA9IFtBTVBFUlNBTkQsIEFQT1NUUk9QSEUsIEFTVEVSSVNLLCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTtcblxuICAvLyBUaGUgdW5pdmVyc2FsIHN0YXJ0aW5nIHN0YXRlLlxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuICBjb25zdCBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICBjb25zdCBMb2NhbHBhcnQgPSB0dChTdGFydCwgVElMREUpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IERvbWFpbiA9IG1ha2VTdGF0ZSgpLFxuICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgIFNsYXNoU2NoZW1lID0gbWFrZVN0YXRlKCk7XG4gIHRhKFN0YXJ0LCBncm91cHMuZG9tYWluLCBEb21haW4pOyAvLyBwYXJzZWQgc3RyaW5nIGVuZHMgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZSAoQSlcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zY2hlbWUsIFNjaGVtZSk7IC8vIGUuZy4sICdtYWlsdG8nXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgTG9jYWxwYXJ0QXQgPSB0dChEb21haW4sIEFUKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzIEBcblxuICB0dChMb2NhbHBhcnQsIEFULCBMb2NhbHBhcnRBdCk7IC8vIGNsb3NlIHRvIGFuIGVtYWlsIGFkZHJlc3Mgbm93XG5cbiAgLy8gTG9jYWwgcGFydCBvZiBhbiBlbWFpbCBhZGRyZXNzIGNhbiBiZSBlLmcuICdodHRwJyBvciAnbWFpbHRvJ1xuICB0dChTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG4gIHRhKExvY2FscGFydERvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnREb3QsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICBjb25zdCBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy50bGQsIEVtYWlsJDEpO1xuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIEVtYWlsJDEpO1xuICB0dChMb2NhbHBhcnRBdCwgTE9DQUxIT1NULCBFbWFpbCQxKTtcblxuICAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG4gIGNvbnN0IEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0dChFbWFpbERvbWFpbkh5cGhlbiwgSFlQSEVOLCBFbWFpbERvbWFpbkh5cGhlbik7XG4gIHRhKEVtYWlsRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHRhKEVtYWlsJDEsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdHQoRW1haWwkMSwgRE9ULCBFbWFpbERvbWFpbkRvdCk7XG4gIHR0KEVtYWlsJDEsIEhZUEhFTiwgRW1haWxEb21haW5IeXBoZW4pO1xuXG4gIC8vIEZpbmFsIHBvc3NpYmxlIGVtYWlsIHN0YXRlc1xuICBjb25zdCBFbWFpbENvbG9uID0gdHQoRW1haWwkMSwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICAvKmNvbnN0IEVtYWlsQ29sb25Qb3J0ID0gKi9cbiAgdGEoRW1haWxDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIEVtYWlsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIGFuZCBwb3J0IG51bWJlclxuXG4gIC8vIEFjY291bnQgZm9yIGRvdHMgYW5kIGh5cGhlbnMuIEh5cGhlbnMgYXJlIHVzdWFsbHkgcGFydHMgb2YgZG9tYWluIG5hbWVzXG4gIC8vIChidXQgbm90IFRMRHMpXG4gIGNvbnN0IERvbWFpbkh5cGhlbiA9IHR0KERvbWFpbiwgSFlQSEVOKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IGh5cGhlblxuICBjb25zdCBEb21haW5Eb3QgPSB0dChEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdHQoRG9tYWluSHlwaGVuLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG4gIHRhKERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgRG9tYWluRG90VGxkID0gbWFrZVN0YXRlKFVybCk7IC8vIFNpbXBsZXN0IHBvc3NpYmxlIFVSTCB3aXRoIG5vIHF1ZXJ5IHN0cmluZ1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy50bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdFRsZCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90VGxkLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChEb21haW5Eb3RUbGQsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdHQoRG9tYWluRG90VGxkLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvbiA9IHR0KERvbWFpbkRvdFRsZCwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvblBvcnQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVExEIGZvbGxvd2VkIGJ5IGEgcG9ydCBudW1iZXJcbiAgdGEoRG9tYWluRG90VGxkQ29sb24sIGdyb3Vwcy5udW1lcmljLCBEb21haW5Eb3RUbGRDb2xvblBvcnQpO1xuXG4gIC8vIExvbmcgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBhbmQgbWF5YmUgcXVlcnkgc3RyaW5nXG4gIGNvbnN0IFVybCQxID0gbWFrZVN0YXRlKFVybCk7XG5cbiAgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcblxuICAvLyBRdWVyeSBzdHJpbmdzXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcblxuICAvLyBCZWNvbWUgcmVhbCBVUkxzIGFmdGVyIGBTTEFTSGAgb3IgYENPTE9OIE5VTSBTTEFTSGBcbiAgLy8gSGVyZSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgc2NoZW1lOi8vIHByZWZpeFxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTtcblxuICAvLyBOb3RlIHRoYXQgZG9tYWlucyB0aGF0IGJlZ2luIHdpdGggc2NoZW1lcyBhcmUgdHJlYXRlZCBzbGlnaGx5IGRpZmZlcmVudGx5XG4gIGNvbnN0IFNjaGVtZUNvbG9uID0gdHQoU2NoZW1lLCBDT0xPTik7IC8vIGUuZy4sICdtYWlsdG86J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgY29uc3QgVXJpUHJlZml4ID0gdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8vJ1xuXG4gIC8vIFNjaGVtZSBzdGF0ZXMgY2FuIHRyYW5zaXRpb24gdG8gZG9tYWluIHN0YXRlc1xuICB0YShTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoU2xhc2hTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNsYXNoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRm9yY2UgVVJMIHdpdGggc2NoZW1lIHByZWZpeCBmb2xsb3dlZCBieSBhbnl0aGluZyBzYW5lXG4gIHRhKFNjaGVtZUNvbG9uLCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBTTEFTSCwgVXJsJDEpO1xuICB0dChTY2hlbWVDb2xvbiwgUVVFUlksIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHRhKFVyaVByZWZpeCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdHQoVXJpUHJlZml4LCBTTEFTSCwgVXJsJDEpO1xuICBjb25zdCBicmFja2V0UGFpcnMgPSBbW09QRU5CUkFDRSwgQ0xPU0VCUkFDRV0sXG4gIC8vIHt9XG4gIFtPUEVOQlJBQ0tFVCwgQ0xPU0VCUkFDS0VUXSxcbiAgLy8gW11cbiAgW09QRU5QQVJFTiwgQ0xPU0VQQVJFTl0sXG4gIC8vICgpXG4gIFtPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVF0sXG4gIC8vIDw+XG4gIFtGVUxMV0lEVEhMRUZUUEFSRU4sIEZVTExXSURUSFJJR0hUUEFSRU5dLFxuICAvLyDvvIjvvIlcbiAgW0xFRlRDT1JORVJCUkFDS0VULCBSSUdIVENPUk5FUkJSQUNLRVRdLFxuICAvLyDjgIzjgI1cbiAgW0xFRlRXSElURUNPUk5FUkJSQUNLRVQsIFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUXSxcbiAgLy8g44CO44CPXG4gIFtGVUxMV0lEVEhMRVNTVEhBTiwgRlVMTFdJRFRIR1JFQVRFUlRIQU5dIC8vIO+8nO+8nlxuICBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtPUEVOLCBDTE9TRV0gPSBicmFja2V0UGFpcnNbaV07XG4gICAgY29uc3QgVXJsT3BlbiA9IHR0KFVybCQxLCBPUEVOKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IG9wZW4gYnJhY2tldFxuXG4gICAgLy8gQ29udGludWUgbm90IGFjY2VwdGluZyBmb3Igb3BlbiBicmFja2V0c1xuICAgIHR0KFVybE5vbmFjY2VwdCwgT1BFTiwgVXJsT3Blbik7XG5cbiAgICAvLyBDbG9zaW5nIGJyYWNrZXQgY29tcG9uZW50LiBUaGlzIGNoYXJhY3RlciBXSUxMIGJlIGluY2x1ZGVkIGluIHRoZSBVUkxcbiAgICB0dChVcmxPcGVuLCBDTE9TRSwgVXJsJDEpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVpbmdzIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBhIHN5bWJvbHMuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5gIChpZiB0aGUgVVJMIGhhcyBhXG4gICAgLy8gc2luZ2xlIG9wZW5pbmcgYnJhY2tldCBmb3Igc29tZSByZWFzb24pLlxuICAgIGNvbnN0IFVybE9wZW5RID0gbWFrZVN0YXRlKFVybCk7XG4gICAgdGEoVXJsT3BlbiwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICBjb25zdCBVcmxPcGVuU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyBpdCBjYW5ub3QgZW5kIGl0XG4gICAgdGEoVXJsT3BlbiwgcXNOb25BY2NlcHRpbmcpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcbiAgICB0YShVcmxPcGVuUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuUSwgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcblxuICAgIC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG4gICAgdHQoVXJsT3BlblEsIENMT1NFLCBVcmwkMSk7XG4gICAgdHQoVXJsT3BlblN5bXMsIENMT1NFLCBVcmwkMSk7XG4gIH1cbiAgdHQoU3RhcnQsIExPQ0FMSE9TVCwgRG9tYWluRG90VGxkKTsgLy8gbG9jYWxob3N0IGlzIGEgdmFsaWQgVVJMIHN0YXRlXG4gIHR0KFN0YXJ0LCBOTCwgTmwpOyAvLyBzaW5nbGUgbmV3IGxpbmVcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IHRrXG4gIH07XG59XG5cbi8qKlxuICogUnVuIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBvbiBhIGxpc3Qgb2Ygc2Nhbm5lZCBzdHJpbmctYmFzZWQgdG9rZW5zIHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIG11bHRpIHRva2VucywgZWFjaCBvZiB3aGljaCByZXByZXNlbnRzIGEgVVJMLCBlbWFpbCBhZGRyZXNzLFxuICogcGxhaW4gdGV4dCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7U3RhdGU8TXVsdGlUb2tlbj59IHN0YXJ0IHBhcnNlciBzdGFydCBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRoZSBvcmlnaW5hbCBpbnB1dCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiB0b2tlbnNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGxpc3Qgb2Ygc2Nhbm5lZCB0b2tlbnNcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VuW119XG4gKi9cbmZ1bmN0aW9uIHJ1bihzdGFydCwgaW5wdXQsIHRva2Vucykge1xuICBsZXQgbGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIGxldCBtdWx0aXMgPSBbXTtcbiAgbGV0IHRleHRUb2tlbnMgPSBbXTtcbiAgd2hpbGUgKGN1cnNvciA8IGxlbikge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBzZWNvbmRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG11bHRpTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAhKHNlY29uZFN0YXRlID0gc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBTdGFydGluZyB0b2tlbnMgd2l0aCBub3doZXJlIHRvIGp1bXAgdG8uXG4gICAgICAvLyBDb25zaWRlciB0aGVzZSB0byBiZSBqdXN0IHBsYWluIHRleHRcbiAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAobmV4dFN0YXRlID0gc2Vjb25kU3RhdGUgfHwgc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBHZXQgdGhlIG5leHQgc3RhdGVcbiAgICAgIHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrO1xuICAgICAgbXVsdGlMZW5ndGgrKztcbiAgICB9XG4gICAgaWYgKHNpbmNlQWNjZXB0cyA8IDApIHtcbiAgICAgIC8vIE5vIGFjY2VwdGluZyBzdGF0ZSB3YXMgZm91bmQsIHBhcnQgb2YgYSByZWd1bGFyIHRleHQgdG9rZW4gYWRkXG4gICAgICAvLyB0aGUgZmlyc3QgdGV4dCB0b2tlbiB0byB0aGUgdGV4dCB0b2tlbnMgYXJyYXkgYW5kIHRyeSBhZ2FpbiBmcm9tXG4gICAgICAvLyB0aGUgbmV4dFxuICAgICAgY3Vyc29yIC09IG11bHRpTGVuZ3RoO1xuICAgICAgaWYgKGN1cnNvciA8IGxlbikge1xuICAgICAgICB0ZXh0VG9rZW5zLnB1c2godG9rZW5zW2N1cnNvcl0pO1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWNjZXB0aW5nIHN0YXRlIVxuICAgICAgLy8gRmlyc3QgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG4gICAgICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gICAgICAgIHRleHRUb2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgICAgbXVsdGlMZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbXVsdGl0b2tlblxuICAgICAgY29uc3QgTXVsdGkgPSBsYXRlc3RBY2NlcHRpbmcudDtcbiAgICAgIGNvbnN0IHN1YnRva2VucyA9IHRva2Vucy5zbGljZShjdXJzb3IgLSBtdWx0aUxlbmd0aCwgY3Vyc29yKTtcbiAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgc3VidG9rZW5zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWxseSBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gIH1cbiAgcmV0dXJuIG11bHRpcztcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IG11bHRpdG9rZW4gd2l0aCBhbGwgdGhlIHJlbGV2YW50XG4gKiBmaWVsZHMgZHVyaW5nIHBhcnNpbmcuXG4gKiBAcGFyYW0ge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBNdWx0aSBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgY29uc2VjdXRpdmUgdG9rZW5zIHNjYW5uZWQgZnJvbSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VufVxuICovXG5mdW5jdGlvbiBpbml0TXVsdGlUb2tlbihNdWx0aSwgaW5wdXQsIHRva2Vucykge1xuICBjb25zdCBzdGFydElkeCA9IHRva2Vuc1swXS5zO1xuICBjb25zdCBlbmRJZHggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmU7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIHJldHVybiBuZXcgTXVsdGkodmFsdWUsIHRva2Vucyk7XG59XG5cbmNvbnN0IHdhcm4gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgKCgpID0+IHt9KTtcbmNvbnN0IHdhcm5BZHZpY2UgPSAndW50aWwgbWFudWFsIGNhbGwgb2YgbGlua2lmeS5pbml0KCkuIFJlZ2lzdGVyIGFsbCBzY2hlbWVzIGFuZCBwbHVnaW5zIGJlZm9yZSBpbnZva2luZyBsaW5raWZ5IHRoZSBmaXJzdCB0aW1lLic7XG5cbi8vIFNpZGUtZWZmZWN0IGluaXRpYWxpemF0aW9uIHN0YXRlXG5jb25zdCBJTklUID0ge1xuICBzY2FubmVyOiBudWxsLFxuICBwYXJzZXI6IG51bGwsXG4gIHRva2VuUXVldWU6IFtdLFxuICBwbHVnaW5RdWV1ZTogW10sXG4gIGN1c3RvbVNjaGVtZXM6IFtdLFxuICBpbml0aWFsaXplZDogZmFsc2Vcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPHN0cmluZz4sXG4gKiBcdHRva2VuczogeyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfSAmIHR5cGVvZiB0a1xuICogfX0gU2Nhbm5lckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxNdWx0aVRva2VuPixcbiAqIFx0dG9rZW5zOiB0eXBlb2YgbXVsdGlcbiAqIH19IFBhcnNlckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0IH0pID0+IHZvaWR9IFRva2VuUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCwgcGFyc2VyOiBQYXJzZXJJbml0IH0pID0+IHZvaWR9IFBsdWdpblxuICovXG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYWxsIHBsdWdpbnMgYW5kIHJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZS1tYWNoaW5lLiBVc2VkIGZvclxuICogdGVzdGluZzsgbm90IHJlcXVpcmVkIGluIHByYWN0aWNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIFN0YXRlLmdyb3VwcyA9IHt9O1xuICBJTklULnNjYW5uZXIgPSBudWxsO1xuICBJTklULnBhcnNlciA9IG51bGw7XG4gIElOSVQudG9rZW5RdWV1ZSA9IFtdO1xuICBJTklULnBsdWdpblF1ZXVlID0gW107XG4gIElOSVQuY3VzdG9tU2NoZW1lcyA9IFtdO1xuICBJTklULmluaXRpYWxpemVkID0gZmFsc2U7XG4gIHJldHVybiBJTklUO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG9rZW4gcGx1Z2luIHRvIGFsbG93IHRoZSBzY2FubmVyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VuXG4gKiB0eXBlcyBiZWZvcmUgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7VG9rZW5QbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHNjYW5uZXIgc3RhdGUgbWFjaGluZVxuICogYW5kIGF2YWlsYWJsZSBzY2FubmVyIHRva2VucyBhbmQgY29sbGVjdGlvbnMgYW5kIGV4dGVuZHMgdGhlIHN0YXRlIG1hY2hpbmUgdG9cbiAqIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VucyBvciBncm91cHMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVG9rZW5QbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgdG9rZW4gcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnRva2VuUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oYGxpbmtpZnlqczogdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5gKTtcbiAgICAgIElOSVQudG9rZW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnRva2VuUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbGlua2lmeSBwbHVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtQbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZFxuICogZXh0ZW5kcyB0aGUgcGFyc2VyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIGxpbmsgdHlwZXNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQucGx1Z2luUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC5wbHVnaW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC5wbHVnaW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnBsdWdpblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHBsdWdpbiBcIiR7bmFtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgVVJMcyB3aXRoIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBwcm90b2NvbC4gQW55dGhpbmcgd2l0aCBmb3JtYXRcbiAqIFwicHJvdG9jb2w6Ly8uLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLiBJZiBgb3B0aW9uYWxTbGFzaFNsYXNoYCBpcyBzZXQgdG9cbiAqIGB0cnVlYCwgYW55dGhpbmcgd2l0aCBmb3JtYXQgXCJwcm90b2NvbDouLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWxTbGFzaFNsYXNoXVxuICovXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbVByb3RvY29sKHNjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoID0gZmFsc2UpIHtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBjdXN0b20gc2NoZW1lIFwiJHtzY2hlbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG4gIGlmICghL15bMC05YS16XSsoLVswLTlhLXpdKykqJC8udGVzdChzY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IGluY29ycmVjdCBzY2hlbWUgZm9ybWF0LlxuMS4gTXVzdCBvbmx5IGNvbnRhaW4gZGlnaXRzLCBsb3dlcmNhc2UgQVNDSUkgbGV0dGVycyBvciBcIi1cIlxuMi4gQ2Fubm90IHN0YXJ0IG9yIGVuZCB3aXRoIFwiLVwiXG4zLiBcIi1cIiBjYW5ub3QgcmVwZWF0YCk7XG4gIH1cbiAgSU5JVC5jdXN0b21TY2hlbWVzLnB1c2goW3NjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoXSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGlua2lmeSBzdGF0ZSBtYWNoaW5lLiBDYWxsZWQgYXV0b21hdGljYWxseSB0aGUgZmlyc3QgdGltZVxuICogbGlua2lmeSBpcyBjYWxsZWQgb24gYSBzdHJpbmcsIGJ1dCBtYXkgYmUgY2FsbGVkIG1hbnVhbGx5IGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vIEluaXRpYWxpemUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG4gIElOSVQuc2Nhbm5lciA9IGluaXQkMihJTklULmN1c3RvbVNjaGVtZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQudG9rZW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXJcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5wYXJzZXIgPSBpbml0JDEoSU5JVC5zY2FubmVyLnRva2Vucyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQucGx1Z2luUXVldWVbaV1bMV0oe1xuICAgICAgc2Nhbm5lcjogSU5JVC5zY2FubmVyLFxuICAgICAgcGFyc2VyOiBJTklULnBhcnNlclxuICAgIH0pO1xuICB9XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICByZXR1cm4gSU5JVDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIHRva2VucyB0aGF0IHJlcHJlc2VudCBsaW5rYWJsZSBhbmQgbm9uLWxpbmthYmxlIHN1Yi1jb21wb25lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNdWx0aVRva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcbiAgaWYgKCFJTklULmluaXRpYWxpemVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHJldHVybiBydW4oSU5JVC5wYXJzZXIuc3RhcnQsIHN0ciwgcnVuJDEoSU5JVC5zY2FubmVyLnN0YXJ0LCBzdHIpKTtcbn1cbnRva2VuaXplLnNjYW4gPSBydW4kMTsgLy8gZm9yIHRlc3RpbmdcblxuLyoqXG4gKiBGaW5kIGEgbGlzdCBvZiBsaW5rYWJsZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gZmluZCBsaW5rcyBpblxuICogQHBhcmFtIHtzdHJpbmcgfCBPcHRzfSBbdHlwZV0gZWl0aGVyIGZvcm1hdHRpbmcgb3B0aW9ucyBvciBzcGVjaWZpYyB0eXBlIG9mXG4gKiBsaW5rcyB0byBmaW5kLCBlLmcuLCAndXJsJyBvciAnZW1haWwnXG4gKiBAcGFyYW0ge09wdHN9IFtvcHRzXSBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIGZpbmFsIG91dHB1dC4gQ2Fubm90IGJlIHNwZWNpZmllZFxuICogaWYgb3B0cyBhbHJlYWR5IHByb3ZpZGVkIGluIGB0eXBlYCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBmaW5kKHN0ciwgdHlwZSA9IG51bGwsIG9wdHMgPSBudWxsKSB7XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICB0aHJvdyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIGxpbmsgdHlwZSAke3R5cGV9OyBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgfVxuICAgIG9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRzKTtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbi50ID09PSB0eXBlKSAmJiBvcHRpb25zLmNoZWNrKHRva2VuKSkge1xuICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbi50b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIHZhbGlkIGxpbmthYmxlIHRleHQgb2Ygc29tZSBzb3J0LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdFxuICogdHJpbSB0aGUgdGV4dCBmb3IgeW91LlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHNlY29uZCBgdHlwZWAgcGFyYW0sIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGxpbmsgdG8gdGVzdFxuICogZm9yLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICpcbiAqICAgICBsaW5raWZ5LnRlc3Qoc3RyLCAnZW1haWwnKTtcbiAqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBzdHIgaXMgYSB2YWxpZCBlbWFpbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIHRlc3QgZm9yIGxpbmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIHNwZWNpZmljIGxpbmsgdHlwZSB0byBsb29rIGZvclxuICogQHJldHVybnMgYm9vbGVhbiB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIHRlc3Qoc3RyLCB0eXBlID0gbnVsbCkge1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbnNbMF0udCA9PT0gdHlwZSk7XG59XG5cbmV4cG9ydCB7IE11bHRpVG9rZW4sIE9wdGlvbnMsIFN0YXRlLCBjcmVhdGVUb2tlbkNsYXNzLCBmaW5kLCBpbml0LCBtdWx0aSwgb3B0aW9ucywgcmVnZXhwLCByZWdpc3RlckN1c3RvbVByb3RvY29sLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0ZXJUb2tlblBsdWdpbiwgcmVzZXQsIHN0cmluZ1RvQXJyYXksIHRlc3QsIG11bHRpIGFzIHRleHQsIHRva2VuaXplIH07XG4iXSwibmFtZXMiOlsiZW5jb2RlZFRsZHMiLCJlbmNvZGVkVXRsZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJwcm9wZXJ0aWVzIiwia2V5IiwibnVtZXJpYyIsImFzY2lpIiwiYWxwaGEiLCJhc2NpaW51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJkb21haW4iLCJlbW9qaSIsInNjaGVtZSIsInNsYXNoc2NoZW1lIiwid2hpdGVzcGFjZSIsInJlZ2lzdGVyR3JvdXAiLCJuYW1lIiwiZ3JvdXBzIiwiYWRkVG9Hcm91cHMiLCJ0IiwiZmxhZ3MiLCJrIiwiZ3JvdXAiLCJpbmRleE9mIiwicHVzaCIsImZsYWdzRm9yVG9rZW4iLCJyZXN1bHQiLCJjIiwiU3RhdGUiLCJ0b2tlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImoiLCJqciIsImpkIiwicHJvdG90eXBlIiwiYWNjZXB0cyIsImdvIiwiaW5wdXQiLCJzdGF0ZSIsIm5leHRTdGF0ZSIsImkiLCJyZWdleCIsInRlc3QiLCJoYXMiLCJleGFjdE9ubHkiLCJ0YSIsImlucHV0cyIsIm5leHQiLCJ0dCIsInRyIiwicmVnZXhwIiwidHMiLCJsZW4iLCJ0ZW1wbGF0ZVN0YXRlIiwiYXBwbHkiLCJhbGxGbGFncyIsIldPUkQiLCJVV09SRCIsIkFTQ0lJTlVNRVJJQ0FMIiwiQUxQSEFOVU1FUklDQUwiLCJMT0NBTEhPU1QiLCJUTEQiLCJVVExEIiwiU0NIRU1FIiwiU0xBU0hfU0NIRU1FIiwiTlVNIiwiV1MiLCJOTCIsIk9QRU5CUkFDRSIsIkNMT1NFQlJBQ0UiLCJPUEVOQlJBQ0tFVCIsIkNMT1NFQlJBQ0tFVCIsIk9QRU5QQVJFTiIsIkNMT1NFUEFSRU4iLCJPUEVOQU5HTEVCUkFDS0VUIiwiQ0xPU0VBTkdMRUJSQUNLRVQiLCJGVUxMV0lEVEhMRUZUUEFSRU4iLCJGVUxMV0lEVEhSSUdIVFBBUkVOIiwiTEVGVENPUk5FUkJSQUNLRVQiLCJSSUdIVENPUk5FUkJSQUNLRVQiLCJMRUZUV0hJVEVDT1JORVJCUkFDS0VUIiwiUklHSFRXSElURUNPUk5FUkJSQUNLRVQiLCJGVUxMV0lEVEhMRVNTVEhBTiIsIkZVTExXSURUSEdSRUFURVJUSEFOIiwiQU1QRVJTQU5EIiwiQVBPU1RST1BIRSIsIkFTVEVSSVNLIiwiQVQiLCJCQUNLU0xBU0giLCJCQUNLVElDSyIsIkNBUkVUIiwiQ09MT04iLCJDT01NQSIsIkRPTExBUiIsIkRPVCIsIkVRVUFMUyIsIkVYQ0xBTUFUSU9OIiwiSFlQSEVOIiwiUEVSQ0VOVCIsIlBJUEUiLCJQTFVTIiwiUE9VTkQiLCJRVUVSWSIsIlFVT1RFIiwiRlVMTFdJRFRITUlERExFRE9UIiwiU0VNSSIsIlNMQVNIIiwiVElMREUiLCJVTkRFUlNDT1JFIiwiRU1PSkkkMSIsIlNZTSIsInRrIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiRU1PSkkiLCJBU0NJSV9MRVRURVIiLCJMRVRURVIiLCJFTU9KSV9WQVJJQVRJT04kMSIsIkRJR0lUIiwiU1BBQ0UiLCJFTU9KSV9WQVJJQVRJT04iLCJDUiIsIkxGIiwiRU1PSklfSk9JTkVSIiwiT0JKRUNUX1JFUExBQ0VNRU5UIiwidGxkcyIsInV0bGRzIiwiaW5pdCQyIiwiY3VzdG9tU2NoZW1lcyIsIlN0YXJ0IiwiZGVjb2RlVGxkcyIsIk51bSIsIl9kZWZpbmVQcm9wZXJ0eSIsIkFzY2lpbnVtZXJpYyIsIkFscGhhbnVtZXJpYyIsIldvcmQiLCJVV29yZCIsIk5sIiwiQ3IiLCJXcyIsIkVtb2ppIiwiRW1vamlKb2luZXIiLCJ3b3JkanIiLCJ1d29yZGpyIiwiZmFzdHRzIiwidGxkIiwidXRsZCIsInNvcnQiLCJhIiwiYiIsInNjaCIsIm9wdGlvbmFsU2xhc2hTbGFzaCIsInN0YXJ0IiwidG9rZW5zIiwicnVuJDEiLCJzdHIiLCJpdGVyYWJsZSIsInN0cmluZ1RvQXJyYXkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJjaGFyQ291bnQiLCJjdXJzb3IiLCJjaGFyQ3Vyc29yIiwidG9rZW5MZW5ndGgiLCJsYXRlc3RBY2NlcHRpbmciLCJzaW5jZUFjY2VwdHMiLCJjaGFyc1NpbmNlQWNjZXB0cyIsInYiLCJzbGljZSIsInMiLCJlIiwiaW5kZXgiLCJmaXJzdCIsImNoYXJDb2RlQXQiLCJzZWNvbmQiLCJjaGFyIiwiZGVmYXVsdHQiLCJlbmNvZGVkIiwid29yZHMiLCJzdGFjayIsImRpZ2l0cyIsInBvcERpZ2l0Q291bnQiLCJqb2luIiwicG9wQ291bnQiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInBvcCIsImRlZmF1bHRzIiwiZGVmYXVsdFByb3RvY29sIiwiZXZlbnRzIiwiZm9ybWF0Iiwibm9vcCIsImZvcm1hdEhyZWYiLCJubDJiciIsInRhZ05hbWUiLCJyZWwiLCJ2YWxpZGF0ZSIsInRydW5jYXRlIiwiSW5maW5pdHkiLCJjbGFzc05hbWUiLCJhdHRyaWJ1dGVzIiwiaWdub3JlVGFncyIsInJlbmRlciIsIk9wdGlvbnMiLCJvcHRzIiwiZGVmYXVsdFJlbmRlciIsIm8iLCJpZ25vcmVkVGFncyIsInVwcGVyY2FzZUlnbm9yZWRUYWdzIiwidG9VcHBlckNhc2UiLCJpciIsImNoZWNrIiwiZ2V0IiwidG9TdHJpbmciLCJvcGVyYXRvciIsImlzQ2FsbGFibGUiLCJvcHRpb24iLCJfdHlwZW9mIiwiZ2V0T2JqIiwib2JqIiwicmVuZGVyRm4iLCJ2YWwiLCJvcHRpb25zIiwiTXVsdGlUb2tlbiIsInZhbHVlIiwiaXNMaW5rIiwidG9IcmVmIiwidG9Gb3JtYXR0ZWRTdHJpbmciLCJmb3JtYXR0ZWQiLCJ0b0Zvcm1hdHRlZEhyZWYiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJ0b09iamVjdCIsInByb3RvY29sIiwidHlwZSIsImhyZWYiLCJlbmQiLCJ0b0Zvcm1hdHRlZE9iamVjdCIsImZvcm1hdHRlZEhyZWYiLCJjb250ZW50IiwiYXR0cnMiLCJldmVudExpc3RlbmVycyIsImNyZWF0ZVRva2VuQ2xhc3MiLCJwcm9wcyIsIlRva2VuIiwiX011bHRpVG9rZW4iLCJfdGhpczIiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbFN1cGVyIiwiX2luaGVyaXRzIiwiX2NyZWF0ZUNsYXNzIiwicCIsIkVtYWlsIiwiVGV4dCIsIlVybCIsImhhc1Byb3RvY29sIiwiY29uY2F0IiwibXVsdGkiLCJCYXNlIiwibWFrZVN0YXRlIiwiYXJnIiwiaW5pdCQxIiwiX3JlZjMiLCJxc0FjY2VwdGluZyIsInFzTm9uQWNjZXB0aW5nIiwibG9jYWxwYXJ0QWNjZXB0aW5nIiwiTG9jYWxwYXJ0IiwiRG9tYWluIiwiU2NoZW1lIiwiU2xhc2hTY2hlbWUiLCJMb2NhbHBhcnRBdCIsIkxvY2FscGFydERvdCIsIkVtYWlsRG9tYWluIiwiRW1haWxEb21haW5Eb3QiLCJFbWFpbCQxIiwiRW1haWxEb21haW5IeXBoZW4iLCJFbWFpbENvbG9uIiwiRG9tYWluSHlwaGVuIiwiRG9tYWluRG90IiwiRG9tYWluRG90VGxkIiwiRG9tYWluRG90VGxkQ29sb24iLCJEb21haW5Eb3RUbGRDb2xvblBvcnQiLCJVcmwkMSIsIlVybE5vbmFjY2VwdCIsIlNjaGVtZUNvbG9uIiwiU2xhc2hTY2hlbWVDb2xvbiIsIlNsYXNoU2NoZW1lQ29sb25TbGFzaCIsIlVyaVByZWZpeCIsImJyYWNrZXRQYWlycyIsIl9icmFja2V0UGFpcnMkaSIsIl9zbGljZWRUb0FycmF5IiwiT1BFTiIsIkNMT1NFIiwiVXJsT3BlbiIsIlVybE9wZW5RIiwiVXJsT3BlblN5bXMiLCJydW4iLCJtdWx0aXMiLCJ0ZXh0VG9rZW5zIiwic2Vjb25kU3RhdGUiLCJtdWx0aUxlbmd0aCIsImluaXRNdWx0aVRva2VuIiwiTXVsdGkiLCJzdWJ0b2tlbnMiLCJzdGFydElkeCIsImVuZElkeCIsIndhcm4iLCJjb25zb2xlIiwid2FybkFkdmljZSIsIklOSVQiLCJzY2FubmVyIiwicGFyc2VyIiwidG9rZW5RdWV1ZSIsInBsdWdpblF1ZXVlIiwiaW5pdGlhbGl6ZWQiLCJyZXNldCIsInJlZ2lzdGVyVG9rZW5QbHVnaW4iLCJwbHVnaW4iLCJFcnJvciIsInJlZ2lzdGVyUGx1Z2luIiwicmVnaXN0ZXJDdXN0b21Qcm90b2NvbCIsImluaXQiLCJ0b2tlbml6ZSIsInNjYW4iLCJmaW5kIiwiZmlsdGVyZWQiLCJ0ZXh0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/linkifyjs/dist/linkify.es.js\n");

/***/ })

};
;